/**
 * JSON to Database Seeder for JEE Content
 * 
 * This script processes the JSON files generated by the PDF/Image converter
 * and seeds them into the database with proper categorization, tagging,
 * and relationship management.
 * 
 * Features:
 * - Batch processing of JSON files
 * - Automatic topic/subtopic creation
 * - Smart question categorization
 * - Tag management and creation
 * - Progress tracking and error handling
 * - Duplicate detection and prevention
 * - Rich text formatting for TinyMCE compatibility
 */

const fs = require('fs-extra');
const path = require('path');
const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

const CONFIG = {
  // Input configuration
  jsonInputDir: './json-output',
  
  // Processing options
  processing: {
    batchSize: 10,
    skipExisting: true,
    createMissingTopics: true,
    createMissingTags: true,
    validateQuestions: true,
    
    // Duplicate prevention settings
    duplicatePrevention: {
      enabled: true,
      questionSimilarityThreshold: 0.8,  // 80% similarity threshold for questions
      allowSimilarLessons: true,          // Allow similar lesson names
      allowSimilarTopics: true,           // Allow similar topic names
      allowSimilarSubtopics: true,        // Allow similar subtopic names
      allowSimilarTags: true,             // Allow similar tag names
      caseInsensitiveMatching: true       // Use case-insensitive matching
    }
  },
  
  // Question processing options
  questionProcessing: {
    defaultDifficulty: 'MEDIUM',
    autoDetectDifficulty: true,
    includeImages: true,
    formatForTinyMCE: true
  },
  
  // Logging options
  logging: {
    verbose: true,
    saveProgress: true,
    errorReporting: true
  }
};

/**
 * Main seeding function
 */
async function seedFromJsonFiles() {
  console.log('üå± Starting JSON to Database seeding...');
  
  try {
    // Verify database connection
    await verifyDatabaseConnection();
    
    // Find all JSON files
    const jsonFiles = await findAllJsonFiles();
    console.log(`Found ${jsonFiles.length} JSON files to process`);
    
    // Process files in batches
    const results = await processFilesInBatches(jsonFiles);
    
    // Generate seeding report
    await generateSeedingReport(results);
    
    console.log('‚úÖ Seeding completed successfully!');
    
  } catch (error) {
    console.error('‚ùå Seeding failed:', error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

/**
 * Verify database connection and required data
 */
async function verifyDatabaseConnection() {
  console.log('üîç Verifying database connection...');
  
  try {
    // Test connection
    await prisma.$queryRaw`SELECT 1`;
    
    // Check if JEE stream exists
    const jeeStream = await prisma.stream.findUnique({
      where: { code: 'JEE' }
    });
    
    if (!jeeStream) {
      throw new Error('JEE Stream not found. Please run main seed first.');
    }
    
    // Check if subjects exist
    const subjects = await prisma.subject.findMany({
      where: { streamId: jeeStream.id }
    });
    
    if (subjects.length === 0) {
      throw new Error('No subjects found. Please run main seed first.');
    }
    
    console.log('‚úÖ Database connection verified');
    console.log(`üìö Found ${subjects.length} subjects: ${subjects.map(s => s.name).join(', ')}`);
    
  } catch (error) {
    console.error('‚ùå Database verification failed:', error.message);
    throw error;
  }
}

/**
 * Find all JSON files in the input directory
 */
async function findAllJsonFiles() {
  const files = [];
  
  async function searchDirectory(dir) {
    try {
      const items = await fs.readdir(dir);
      
      for (const item of items) {
        const fullPath = path.join(dir, item);
        const stat = await fs.stat(fullPath);
        
        if (stat.isDirectory()) {
          await searchDirectory(fullPath);
        } else if (path.extname(item) === '.json' && !item.includes('all-') && !item.includes('summary') && !item.includes('.backup')) {
          files.push(fullPath);
        }
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è Cannot read directory ${dir}:`, error.message);
    }
  }
  
  await searchDirectory(CONFIG.jsonInputDir);
  return files;
}

/**
 * Process files in batches
 */
async function processFilesInBatches(jsonFiles) {
  const results = [];
  const batchSize = CONFIG.processing.batchSize;
  
  for (let i = 0; i < jsonFiles.length; i += batchSize) {
    const batch = jsonFiles.slice(i, i + batchSize);
    console.log(`\nüì¶ Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(jsonFiles.length / batchSize)}`);
    
    const batchResults = await Promise.allSettled(
      batch.map(file => processJsonFile(file))
    );
    
    results.push(...batchResults.map((result, index) => ({
      file: batch[index],
      success: result.status === 'fulfilled',
      data: result.status === 'fulfilled' ? result.value : null,
      error: result.status === 'rejected' ? result.reason.message : null
    })));
    
    // Save progress
    if (CONFIG.logging.saveProgress) {
      await saveProgress(results);
    }
  }
  
  return results;
}

/**
 * Process individual JSON file
 */
async function processJsonFile(jsonFilePath) {
  const fileName = path.basename(jsonFilePath);
  console.log(`  üìÑ Processing: ${fileName}`);
  
  try {
    // Read and validate JSON file
    const jsonData = await fs.readJSON(jsonFilePath);
    
    if (!jsonData.success) {
      throw new Error('JSON file indicates failed processing');
    }
    
    // Process based on file type
    if (jsonData.metadata?.fileType === 'pdf') {
      return await processPDFJson(jsonData);
    } else if (jsonData.metadata?.fileType === 'image') {
      return await processImageJson(jsonData);
    } else {
      throw new Error('Unknown file type in JSON data');
    }
    
  } catch (error) {
    console.error(`‚ùå Failed to process ${fileName}:`, error.message);
    throw error;
  }
}

/**
 * Process PDF JSON data
 */
async function processPDFJson(jsonData) {
  const result = {
    fileType: 'pdf',
    questionsCreated: 0,
    topicsCreated: 0,
    subtopicsCreated: 0,
    tagsCreated: 0,
    lmsContentCreated: 0,
    duplicatesSkipped: 0,
    errors: []
  };
  
  try {
    // Get or create subject
    const subject = await getOrCreateSubject(jsonData.metadata.subject);
    
    // Process topics and subtopics
    if (jsonData.content?.topics) {
      for (const topicData of jsonData.content.topics) {
        try {
          const topic = await getOrCreateTopic(topicData.name, subject.id);
          if (topic.wasCreated) result.topicsCreated++;
          
          // Process subtopics for this topic
          if (jsonData.content?.subtopics) {
            const topicSubtopics = jsonData.content.subtopics.filter(
              st => st.parentTopic === topicData.name
            );
            for (const subtopicData of topicSubtopics) {
              try {
                const subtopic = await getOrCreateSubtopic(subtopicData.name, topic.id);
                if (subtopic.wasCreated) result.subtopicsCreated = (result.subtopicsCreated || 0) + 1;
              } catch (error) {
                result.errors.push(`Subtopic creation failed: ${error.message}`);
              }
            }
          }
        } catch (error) {
          result.errors.push(`Topic creation failed: ${error.message}`);
        }
      }
    }
    
    // Process tags
    if (jsonData.content?.tags) {
      for (const tagName of jsonData.content.tags) {
        try {
          const tag = await getOrCreateTag(tagName);
          if (tag.wasCreated) result.tagsCreated++;
        } catch (error) {
          result.errors.push(`Tag creation failed: ${error.message}`);
        }
      }
    }
    
    // Process questions
    if (jsonData.content?.questions) {
      for (const questionData of jsonData.content.questions) {
        try {
          const questionResult = await createQuestion(questionData, jsonData, subject.id);
          if (questionResult.isDuplicate) {
            result.duplicatesSkipped++;
          } else {
            result.questionsCreated++;
          }
        } catch (error) {
          result.errors.push(`Question creation failed: ${error.message}`);
        }
      }
    }
    
    // Process LMS Content (create learning materials from PDF)
    if (jsonData.metadata?.fileType === 'pdf') {
      try {
        await createLMSContentFromPDF(jsonData, subject.id, result);
      } catch (error) {
        result.errors.push(`LMS Content creation failed: ${error.message}`);
      }
    }
    
    const duplicatesSkipped = result.duplicatesSkipped || 0;
    console.log(`  ‚úÖ Created ${result.questionsCreated} questions, ${result.topicsCreated} topics, ${result.subtopicsCreated} subtopics, ${result.tagsCreated} tags, ${result.lmsContentCreated} LMS content`);
    if (duplicatesSkipped > 0) {
      console.log(`  ‚è≠Ô∏è Skipped ${duplicatesSkipped} duplicates`);
    }
    
  } catch (error) {
    result.errors.push(`PDF processing failed: ${error.message}`);
  }
  
  return result;
}

/**
 * Process Image JSON data
 */
async function processImageJson(jsonData) {
  const result = {
    fileType: 'image',
    questionsCreated: 0,
    topicsCreated: 0,
    subtopicsCreated: 0,
    tagsCreated: 0,
    lmsContentCreated: 0,
    duplicatesSkipped: 0,
    errors: []
  };
  
  try {
    // Get or create subject
    const subject = await getOrCreateSubject(jsonData.metadata.subject);
    
    // For images, we typically create content entries or process OCR text
    if (jsonData.content?.questions && jsonData.content.questions.length > 0) {
      for (const questionData of jsonData.content.questions) {
        try {
          await createQuestion(questionData, jsonData, subject.id);
          result.questionsCreated++;
        } catch (error) {
          result.errors.push(`Question creation failed: ${error.message}`);
        }
      }
    }
    
    // Process topics and tags if available
    if (jsonData.content?.topics) {
      for (const topicData of jsonData.content.topics) {
        try {
          const topic = await getOrCreateTopic(topicData.name, subject.id);
          if (topic.wasCreated) result.topicsCreated++;
        } catch (error) {
          result.errors.push(`Topic creation failed: ${error.message}`);
        }
      }
    }
    
    if (jsonData.content?.tags) {
      for (const tagName of jsonData.content.tags) {
        try {
          const tag = await getOrCreateTag(tagName);
          if (tag.wasCreated) result.tagsCreated++;
        } catch (error) {
          result.errors.push(`Tag creation failed: ${error.message}`);
        }
      }
    }
    
    console.log(`  ‚úÖ Processed image content: ${result.questionsCreated} questions`);
    
  } catch (error) {
    result.errors.push(`Image processing failed: ${error.message}`);
  }
  
  return result;
}

/**
 * Get or create subject
 */
async function getOrCreateSubject(subjectName) {
  if (!subjectName || subjectName === 'Unknown') {
    throw new Error('Subject name is required');
  }
  
  const jeeStream = await prisma.stream.findUnique({
    where: { code: 'JEE' }
  });
  
  let subject = await prisma.subject.findFirst({
    where: {
      name: subjectName,
      streamId: jeeStream.id
    }
  });
  
  if (!subject && CONFIG.processing.createMissingTopics) {
    subject = await prisma.subject.create({
      data: {
        name: subjectName,
        streamId: jeeStream.id,
        description: `Auto-created subject for ${subjectName}`
      }
    });
    console.log(`  üìö Created subject: ${subjectName}`);
  }
  
  if (!subject) {
    throw new Error(`Subject '${subjectName}' not found and creation is disabled`);
  }
  
  return subject;
}

/**
 * Get or create lesson for a subject with duplicate prevention
 */
async function getOrCreateLesson(lessonName, subjectId, order = 1) {
  // First check if lesson already exists
  let lesson = await prisma.lesson.findFirst({
    where: {
      name: lessonName,
      subjectId: subjectId
    }
  });
  
  const wasCreated = false;
  
  if (!lesson && CONFIG.processing.createMissingTopics) {
    // Check if a lesson with similar name exists (case-insensitive)
    const existingLesson = await prisma.lesson.findFirst({
      where: {
        subjectId: subjectId,
        name: {
          mode: 'insensitive',
          contains: lessonName
        }
      }
    });
    
    if (existingLesson) {
      console.log(`  ‚è≠Ô∏è Using existing similar lesson: ${existingLesson.name} (instead of creating ${lessonName})`);
      return { ...existingLesson, wasCreated: false };
    }
    
    // Create new lesson only if no similar one exists
    lesson = await prisma.lesson.create({
      data: {
        name: lessonName,
        subjectId: subjectId,
        order: order,
        description: `Auto-created lesson for ${lessonName}`
      }
    });
    console.log(`  üìö Created lesson: ${lessonName}`);
    wasCreated = true;
  }
  
  if (!lesson) {
    throw new Error(`Lesson '${lessonName}' not found and creation is disabled`);
  }
  
  return { ...lesson, wasCreated };
}

/**
 * Get or create topic following the proper hierarchy with duplicate prevention
 */
async function getOrCreateTopic(topicName, subjectId, lessonId = null, order = 1) {
  // If no lessonId provided, find or create appropriate lesson based on topic
  if (!lessonId) {
    const lessonName = getLessonNameForTopic(topicName);
    const lesson = await getOrCreateLesson(lessonName, subjectId);
    lessonId = lesson.id;
  }
  
  // First check if topic already exists
  let topic = await prisma.topic.findFirst({
    where: {
      name: topicName,
      lessonId: lessonId
    }
  });
  
  const wasCreated = false;
  
  if (!topic && CONFIG.processing.createMissingTopics) {
    // Check if a topic with similar name exists in the same lesson
    const existingTopic = await prisma.topic.findFirst({
      where: {
        lessonId: lessonId,
        name: {
          mode: 'insensitive',
          contains: topicName
        }
      }
    });
    
    if (existingTopic) {
      console.log(`  ‚è≠Ô∏è Using existing similar topic: ${existingTopic.name} (instead of creating ${topicName})`);
      return { ...existingTopic, wasCreated: false };
    }
    
    // Also check across all lessons in the subject for potential duplicates
    const duplicateTopic = await prisma.topic.findFirst({
      where: {
        subjectId: subjectId,
        name: {
          mode: 'insensitive',
          equals: topicName
        }
      }
    });
    
    if (duplicateTopic) {
      console.log(`  ‚è≠Ô∏è Using existing topic from another lesson: ${duplicateTopic.name}`);
      return { ...duplicateTopic, wasCreated: false };
    }
    
    // Create new topic only if no similar one exists
    topic = await prisma.topic.create({
      data: {
        name: topicName,
        lessonId: lessonId,
        subjectId: subjectId,
        order: order,
        description: `Auto-created topic for ${topicName}`
      }
    });
    console.log(`  üìñ Created topic: ${topicName}`);
    wasCreated = true;
  }
  
  if (!topic) {
    throw new Error(`Topic '${topicName}' not found and creation is disabled`);
  }
  
  return { ...topic, wasCreated };
}

/**
 * Get or create subtopic following the proper hierarchy with duplicate prevention
 */
async function getOrCreateSubtopic(subtopicName, topicId) {
  // First check if subtopic already exists
  let subtopic = await prisma.subtopic.findFirst({
    where: {
      name: subtopicName,
      topicId: topicId
    }
  });
  
  const wasCreated = false;
  
  if (!subtopic && CONFIG.processing.createMissingTopics) {
    // Check if a subtopic with similar name exists in the same topic
    const existingSubtopic = await prisma.subtopic.findFirst({
      where: {
        topicId: topicId,
        name: {
          mode: 'insensitive',
          contains: subtopicName
        }
      }
    });
    
    if (existingSubtopic) {
      console.log(`  ‚è≠Ô∏è Using existing similar subtopic: ${existingSubtopic.name} (instead of creating ${subtopicName})`);
      return { ...existingSubtopic, wasCreated: false };
    }
    
    // Also check across all topics in the same subject for potential duplicates
    const topic = await prisma.topic.findUnique({
      where: { id: topicId },
      include: { subject: true }
    });
    
    if (topic) {
      const duplicateSubtopic = await prisma.subtopic.findFirst({
        where: {
          topic: {
            subjectId: topic.subjectId
          },
          name: {
            mode: 'insensitive',
            equals: subtopicName
          }
        },
        include: {
          topic: true
        }
      });
      
      if (duplicateSubtopic) {
        console.log(`  ‚è≠Ô∏è Using existing subtopic from another topic: ${duplicateSubtopic.name} (in ${duplicateSubtopic.topic.name})`);
        return { ...duplicateSubtopic, wasCreated: false };
      }
    }
    
    // Create new subtopic only if no similar one exists
    subtopic = await prisma.subtopic.create({
      data: {
        name: subtopicName,
        topicId: topicId,
        description: `Auto-created subtopic for ${subtopicName}`
      }
    });
    console.log(`  üìù Created subtopic: ${subtopicName}`);
    wasCreated = true;
  }
  
  if (!subtopic) {
    throw new Error(`Subtopic '${subtopicName}' not found and creation is disabled`);
  }
  
  return { ...subtopic, wasCreated };
}

/**
 * Determine appropriate lesson name based on topic
 */
function getLessonNameForTopic(topicName) {
  const lessonMappings = {
    // Mathematics topics
    'Algebra': 'Fundamentals of Mathematics',
    'Calculus': 'Advanced Mathematics',
    'Geometry': 'Fundamentals of Mathematics',
    'Trigonometry': 'Fundamentals of Mathematics',
    'Probability': 'Advanced Mathematics',
    'Statistics': 'Advanced Mathematics',
    
    // Physics topics
    'Mechanics': 'Classical Physics',
    'Kinematics': 'Classical Physics',
    'Dynamics': 'Classical Physics',
    'Electricity': 'Modern Physics',
    'Magnetism': 'Modern Physics',
    'Thermodynamics': 'Classical Physics',
    'Waves': 'Modern Physics',
    'Optics': 'Modern Physics',
    'Modern Physics': 'Modern Physics',
    
    // Chemistry topics
    'Physical Chemistry': 'Physical and Inorganic Chemistry',
    'Inorganic Chemistry': 'Physical and Inorganic Chemistry',
    'Organic Chemistry': 'Organic Chemistry',
    'Chemical Bonding': 'Physical and Inorganic Chemistry',
    'Chemical Kinetics': 'Physical and Inorganic Chemistry',
    'Thermodynamics': 'Physical and Inorganic Chemistry'
  };
  
  return lessonMappings[topicName] || 'General';
}

/**
 * Get or create tag with duplicate prevention
 */
async function getOrCreateTag(tagName) {
  // First check if tag already exists (exact match)
  let tag = await prisma.tag.findUnique({
    where: { name: tagName }
  });
  
  const wasCreated = false;
  
  if (!tag && CONFIG.processing.createMissingTags) {
    // Check if a tag with similar name exists (case-insensitive)
    const existingTag = await prisma.tag.findFirst({
      where: {
        name: {
          mode: 'insensitive',
          equals: tagName
        }
      }
    });
    
    if (existingTag) {
      console.log(`  ‚è≠Ô∏è Using existing similar tag: ${existingTag.name} (instead of creating ${tagName})`);
      return { ...existingTag, wasCreated: false };
    }
    
    // Check for partial matches that might be duplicates
    const similarTag = await prisma.tag.findFirst({
      where: {
        name: {
          mode: 'insensitive',
          contains: tagName
        }
      }
    });
    
    if (similarTag && tagName.length > 3) { // Only for longer tag names to avoid false positives
      console.log(`  ‚è≠Ô∏è Using existing similar tag: ${similarTag.name} (instead of creating ${tagName})`);
      return { ...similarTag, wasCreated: false };
    }
    
    // Create new tag only if no similar one exists
    tag = await prisma.tag.create({
      data: { name: tagName }
    });
    console.log(`  üè∑Ô∏è Created tag: ${tagName}`);
    wasCreated = true;
  }
  
  if (!tag) {
    throw new Error(`Tag '${tagName}' not found and creation is disabled`);
  }
  
  return { ...tag, wasCreated };
}

/**
 * Create question from processed data following proper hierarchy
 */
async function createQuestion(questionData, jsonData, subjectId) {
  // Skip if question already exists (based on content hash)
  if (CONFIG.processing.skipExisting) {
    const existingQuestion = await findExistingQuestion(questionData.text, subjectId);
    if (existingQuestion) {
      console.log(`  ‚è≠Ô∏è Skipping duplicate question`);
      return { ...existingQuestion, isDuplicate: true };
    }
  }
  
  // Find appropriate topic and subtopic following hierarchy
  const { topic, subtopic } = await findBestMatchingTopicAndSubtopic(questionData, subjectId);
  
  // Determine difficulty
  const difficulty = CONFIG.questionProcessing.autoDetectDifficulty 
    ? detectDifficulty(questionData.text)
    : CONFIG.questionProcessing.defaultDifficulty;
  
  // Format content for TinyMCE - use pre-formatted if available
  const formattedStem = questionData.formattedText || (CONFIG.questionProcessing.formatForTinyMCE
    ? formatForTinyMCE(questionData.text)
    : questionData.text);
  
  // Create question with proper hierarchy
  const question = await prisma.question.create({
    data: {
      stem: formattedStem,
      explanation: questionData.explanation || '',
      tip_formula: questionData.tip_formula || '',
      difficulty: difficulty,
      yearAppeared: jsonData.metadata?.year || null,
      isPreviousYear: true,
      subjectId: subjectId,
      lessonId: topic?.lessonId || null,
      topicId: topic?.id || null,
      subtopicId: subtopic?.id || null
    }
  });
  
  // Create options if available
  if (questionData.options && questionData.options.length > 0) {
    await createQuestionOptions(question.id, questionData.options);
  }
  
  // Create tags
  if (jsonData.content?.tags && jsonData.content.tags.length > 0) {
    await createQuestionTags(question.id, jsonData.content.tags);
  }
  
  // Create additional tags based on question content
  const autoTags = generateAutoTags(questionData, jsonData);
  if (autoTags.length > 0) {
    await createQuestionTags(question.id, autoTags);
  }
  
  return { ...question, isDuplicate: false };
}

/**
 * Find existing question to prevent duplicates with enhanced matching
 */
async function findExistingQuestion(questionText, subjectId) {
  // Clean the question text for comparison
  const cleanText = questionText
    .toLowerCase()
    .replace(/\s+/g, ' ')
    .replace(/[^\w\s]/g, '')
    .trim();
  
  // Get first 100 characters for initial matching
  const searchText = cleanText.substring(0, 100);
  
  // Check for exact or very similar questions
  const existingQuestions = await prisma.question.findMany({
    where: {
      subjectId: subjectId
    },
    select: {
      id: true,
      stem: true
    }
  });
  
  // Find the most similar question
  let bestMatch = null;
  let bestSimilarity = 0;
  
  for (const question of existingQuestions) {
    const existingCleanText = question.stem
      .toLowerCase()
      .replace(/\s+/g, ' ')
      .replace(/[^\w\s]/g, '')
      .trim();
    
    const similarity = calculateTextSimilarity(cleanText, existingCleanText);
    
    if (similarity > bestSimilarity && similarity > CONFIG.processing.duplicatePrevention.questionSimilarityThreshold) {
      bestMatch = question;
      bestSimilarity = similarity;
    }
  }
  
  if (bestMatch) {
    console.log(`  üîç Found similar question (${Math.round(bestSimilarity * 100)}% similarity)`);
  }
  
  return bestMatch;
}

/**
 * Calculate text similarity using simple algorithm
 */
function calculateTextSimilarity(text1, text2) {
  const words1 = new Set(text1.split(/\s+/));
  const words2 = new Set(text2.split(/\s+/));
  
  const intersection = new Set([...words1].filter(x => words2.has(x)));
  const union = new Set([...words1, ...words2]);
  
  return intersection.size / union.size;
}

/**
 * Find best matching topic and subtopic for question following hierarchy
 */
async function findBestMatchingTopicAndSubtopic(questionData, subjectId) {
  // Get all topics with their lessons for the subject
  const topics = await prisma.topic.findMany({
    where: { subjectId: subjectId },
    include: {
      lesson: true,
      subtopics: true
    }
  });
  
  const questionText = questionData.text.toLowerCase();
  let bestTopic = null;
  let bestSubtopic = null;
  let bestScore = 0;
  
  // Enhanced keyword matching with scoring
  for (const topic of topics) {
    let topicScore = 0;
    
    // Check topic name match
    if (questionText.includes(topic.name.toLowerCase())) {
      topicScore += 10;
    }
    
    // Check lesson name match
    if (questionText.includes(topic.lesson.name.toLowerCase())) {
      topicScore += 5;
    }
    
    // Check subtopic matches
    for (const subtopic of topic.subtopics) {
      if (questionText.includes(subtopic.name.toLowerCase())) {
        topicScore += 15;
        if (topicScore > bestScore) {
          bestTopic = topic;
          bestSubtopic = subtopic;
          bestScore = topicScore;
        }
      }
    }
    
    // If no subtopic match but topic match, still consider it
    if (topicScore > bestScore && !bestSubtopic) {
      bestTopic = topic;
      bestScore = topicScore;
    }
  }
  
  // If no matches found, create default topic based on subject
  if (!bestTopic) {
    const defaultTopicName = getDefaultTopicForSubject(subjectId);
    if (defaultTopicName) {
      bestTopic = await getOrCreateTopic(defaultTopicName, subjectId);
    }
  }
  
  return { topic: bestTopic, subtopic: bestSubtopic };
}

/**
 * Get default topic name for a subject
 */
async function getDefaultTopicForSubject(subjectId) {
  const subject = await prisma.subject.findUnique({
    where: { id: subjectId }
  });
  
  const defaultTopics = {
    'Mathematics': 'Algebra',
    'Physics': 'Mechanics',
    'Chemistry': 'Physical Chemistry'
  };
  
  return defaultTopics[subject?.name] || null;
}

/**
 * Detect question difficulty
 */
function detectDifficulty(questionText) {
  const text = questionText.toLowerCase();
  
  // Simple heuristics for difficulty detection
  if (text.includes('complex') || text.includes('advanced') || text.includes('derivative') || text.includes('integral')) {
    return 'HARD';
  } else if (text.includes('simple') || text.includes('basic') || text.includes('easy')) {
    return 'EASY';
  } else {
    return 'MEDIUM';
  }
}

/**
 * Format text for TinyMCE compatibility
 */
function formatForTinyMCE(text) {
  // Convert basic formatting and mathematical expressions
  return text
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
    .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic
    .replace(/\n\n/g, '</p><p>') // Paragraphs
    .replace(/\n/g, '<br>') // Line breaks
    .replace(/^/, '<p>') // Start with paragraph
    .replace(/$/, '</p>'); // End with paragraph
}

/**
 * Create question options
 */
async function createQuestionOptions(questionId, options) {
  for (let i = 0; i < options.length; i++) {
    const option = options[i];
    
    // Use formatted text if available, otherwise use original text
    const optionText = option.formattedText || option.text;
    
    await prisma.questionOption.create({
      data: {
        questionId: questionId,
        text: optionText,
        isCorrect: option.isCorrect || false,
        order: option.order || i + 1
      }
    });
  }
}

/**
 * Create question tags
 */
async function createQuestionTags(questionId, tagNames) {
  for (const tagName of tagNames) {
    try {
      const tag = await getOrCreateTag(tagName);
      await prisma.questionTag.create({
        data: {
          questionId: questionId,
          tagId: tag.id
        }
      });
    } catch (error) {
      console.warn(`‚ö†Ô∏è Failed to create tag relationship: ${error.message}`);
    }
  }
}

/**
 * Create LMS Content from PDF data
 */
async function createLMSContentFromPDF(jsonData, subjectId, result) {
  console.log(`  üìö Creating LMS Content from PDF...`);
  
  // Determine content type based on subject
  const contentType = getContentTypeForSubject(jsonData.metadata.subject);
  
  // Create main LMS Content entry for the PDF
  const lmsContent = await prisma.lMSContent.create({
    data: {
      title: generateLMSTitle(jsonData),
      description: generateLMSDescription(jsonData),
      contentType: contentType,
      status: 'PUBLISHED',
      accessType: 'FREE',
      contentData: {
        originalPdf: jsonData.relativePath,
        totalPages: jsonData.metadata.totalPages,
        questionsCount: jsonData.content?.questions?.length || 0,
        topics: jsonData.content?.topics || [],
        mathEquations: jsonData.content?.mathEquations || [],
        chemicalEquations: jsonData.content?.chemicalEquations || []
      },
      streamId: await getStreamId('JEE'),
      subjectId: subjectId,
      tags: jsonData.content?.tags || [],
      difficulty: determineContentDifficulty(jsonData),
      duration: estimateContentDuration(jsonData)
    }
  });
  
  result.lmsContentCreated++;
  console.log(`  üìö Created LMS Content: ${lmsContent.title}`);
  
  // Create content entries for each topic if they exist
  if (jsonData.content?.topics && jsonData.content.topics.length > 0) {
    for (const topicData of jsonData.content.topics) {
      try {
        const topic = await getOrCreateTopic(topicData.name, subjectId);
        
        // Create topic-specific LMS content
        const topicContent = await prisma.lMSContent.create({
          data: {
            title: `${topicData.name} - ${jsonData.metadata.year} Paper`,
            description: `Topic-specific content from ${jsonData.metadata.subject} paper`,
            contentType: 'TEXT',
            status: 'PUBLISHED',
            accessType: 'FREE',
            contentData: {
              parentPdf: jsonData.relativePath,
              topic: topicData.name,
              confidence: topicData.confidence,
              matchedKeywords: topicData.matchedKeywords
            },
            streamId: await getStreamId('JEE'),
            subjectId: subjectId,
            lessonId: topic.lessonId,
            topicId: topic.id,
            parentId: lmsContent.id,
            tags: ['Topic Content', 'Previous Year'],
            difficulty: determineContentDifficulty(jsonData)
          }
        });
        
        result.lmsContentCreated++;
        console.log(`  üìñ Created topic content: ${topicContent.title}`);
        
      } catch (error) {
        console.warn(`‚ö†Ô∏è Failed to create topic content: ${error.message}`);
      }
    }
  }
  
  return lmsContent;
}

/**
 * Get content type based on subject
 */
function getContentTypeForSubject(subject) {
  const contentTypes = {
    'Mathematics': 'TEXT',
    'Physics': 'TEXT',
    'Chemistry': 'TEXT'
  };
  return contentTypes[subject] || 'TEXT';
}

/**
 * Generate LMS title from PDF metadata
 */
function generateLMSTitle(jsonData) {
  const { subject, year, session, shift } = jsonData.metadata;
  return `${subject} - ${year} ${session} ${shift} Paper`;
}

/**
 * Generate LMS description from PDF metadata
 */
function generateLMSDescription(jsonData) {
  const { subject, year, session, shift, paperType } = jsonData.metadata;
  return `${paperType} for ${subject} ${year} ${session} ${shift} shift. Contains ${jsonData.content?.questions?.length || 0} questions with solutions.`;
}

/**
 * Determine content difficulty based on questions
 */
function determineContentDifficulty(jsonData) {
  if (!jsonData.content?.questions) return 'MEDIUM';
  
  const difficulties = jsonData.content.questions.map(q => q.difficulty || 'MEDIUM');
  const hardCount = difficulties.filter(d => d === 'HARD').length;
  const mediumCount = difficulties.filter(d => d === 'MEDIUM').length;
  const easyCount = difficulties.filter(d => d === 'EASY').length;
  
  if (hardCount > mediumCount && hardCount > easyCount) return 'HARD';
  if (easyCount > mediumCount && easyCount > hardCount) return 'EASY';
  return 'MEDIUM';
}

/**
 * Estimate content duration based on questions count
 */
function estimateContentDuration(jsonData) {
  const questionCount = jsonData.content?.questions?.length || 0;
  const pagesCount = jsonData.metadata?.totalPages || 1;
  
  // Estimate: 2 minutes per question + 1 minute per page for reading
  return (questionCount * 2 + pagesCount * 1) * 60; // in seconds
}

/**
 * Get stream ID by code
 */
async function getStreamId(streamCode) {
  const stream = await prisma.stream.findUnique({
    where: { code: streamCode }
  });
  return stream?.id || null;
}

/**
 * Generate automatic tags based on content
 */
function generateAutoTags(questionData, jsonData) {
  const tags = [];
  
  // Add subject-based tags
  if (jsonData.metadata?.subject) {
    tags.push(jsonData.metadata.subject);
  }
  
  // Add year-based tags
  if (jsonData.metadata?.year) {
    tags.push(`Year ${jsonData.metadata.year}`);
  }
  
  // Add session-based tags
  if (jsonData.metadata?.session) {
    tags.push(jsonData.metadata.session);
  }
  
  // Add shift-based tags
  if (jsonData.metadata?.shift) {
    tags.push(jsonData.metadata.shift);
  }
  
  // Add content-based tags
  if (questionData.hasMath) {
    tags.push('Mathematical');
  }
  
  if (questionData.hasChemistry) {
    tags.push('Chemical');
  }
  
  return tags;
}

/**
 * Generate hash for text content
 */
function generateTextHash(text) {
  // Simple hash function - in production, use a proper hashing library
  let hash = 0;
  for (let i = 0; i < text.length; i++) {
    const char = text.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return hash.toString();
}

/**
 * Save progress to file
 */
async function saveProgress(results) {
  const progressFile = path.join(CONFIG.jsonInputDir, 'seeding-progress.json');
  await fs.writeJSON(progressFile, {
    timestamp: new Date().toISOString(),
    results: results
  }, { spaces: 2 });
}

/**
 * Generate seeding report
 */
async function generateSeedingReport(results) {
  console.log('\nüìä Generating seeding report...');
  
  const successful = results.filter(r => r.success);
  const failed = results.filter(r => !r.success);
  
  const report = {
    generatedAt: new Date().toISOString(),
    summary: {
      totalFiles: results.length,
      successfulFiles: successful.length,
      failedFiles: failed.length,
      totalQuestionsCreated: successful.reduce((sum, r) => sum + (r.data?.questionsCreated || 0), 0),
      totalTopicsCreated: successful.reduce((sum, r) => sum + (r.data?.topicsCreated || 0), 0),
      totalSubtopicsCreated: successful.reduce((sum, r) => sum + (r.data?.subtopicsCreated || 0), 0),
      totalTagsCreated: successful.reduce((sum, r) => sum + (r.data?.tagsCreated || 0), 0),
      totalLMSContentCreated: successful.reduce((sum, r) => sum + (r.data?.lmsContentCreated || 0), 0),
      totalDuplicatesSkipped: successful.reduce((sum, r) => sum + (r.data?.duplicatesSkipped || 0), 0)
    },
    errors: failed.map(f => ({
      file: f.file,
      error: f.error
    })),
    successfulFiles: successful.map(s => ({
      file: s.file,
      questionsCreated: s.data?.questionsCreated || 0,
      topicsCreated: s.data?.topicsCreated || 0,
      subtopicsCreated: s.data?.subtopicsCreated || 0,
      tagsCreated: s.data?.tagsCreated || 0
    }))
  };
  
  const reportPath = path.join(CONFIG.jsonInputDir, 'seeding-report.json');
  await fs.writeJSON(reportPath, report, { spaces: 2 });
  
  console.log('‚úÖ Seeding report generated');
  console.log(`üìä Summary:`);
  console.log(`  - Total files processed: ${report.summary.totalFiles}`);
  console.log(`  - Successful: ${report.summary.successfulFiles}`);
  console.log(`  - Failed: ${report.summary.failedFiles}`);
  console.log(`  - Questions created: ${report.summary.totalQuestionsCreated}`);
  console.log(`  - Topics created: ${report.summary.totalTopicsCreated}`);
  console.log(`  - Subtopics created: ${report.summary.totalSubtopicsCreated}`);
  console.log(`  - Tags created: ${report.summary.totalTagsCreated}`);
  console.log(`  - LMS Content created: ${report.summary.totalLMSContentCreated}`);
  console.log(`  - Duplicates skipped: ${report.summary.totalDuplicatesSkipped}`);
}

// CLI execution
if (require.main === module) {
  console.log('üå± JSON to Database Seeder for JEE Content');
  console.log('==========================================');
  
  seedFromJsonFiles()
    .then(() => {
      console.log('üéâ Seeding completed successfully!');
      process.exit(0);
    })
    .catch(error => {
      console.error('‚ùå Seeding failed:', error);
      process.exit(1);
    });
}

module.exports = {
  seedFromJsonFiles,
  processJsonFile,
  CONFIG
};
