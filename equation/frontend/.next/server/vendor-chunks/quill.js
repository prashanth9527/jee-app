/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/quill";
exports.ids = ["vendor-chunks/quill"];
exports.modules = {

/***/ "(ssr)/./node_modules/quill/dist/quill.js":
/*!******************************************!*\
  !*** ./node_modules/quill/dist/quill.js ***!
  \******************************************/
/***/ (function(module) {

eval("/*!\n * Quill Editor v1.3.7\n * https://quilljs.com/\n * Copyright (c) 2014, Jason Chen\n * Copyright (c) 2013, salesforce.com\n */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory();\n    else {}\n})(typeof self !== \"undefined\" ? self : this, function() {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_715__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_715__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_715__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_715__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_715__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_715__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_715__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_715__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_715__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_715__.p = \"\";\n        /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_715__(__nested_webpack_require_715__.s = 109);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1, __nested_webpack_require_3404__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var container_1 = __nested_webpack_require_3404__(17);\n            var format_1 = __nested_webpack_require_3404__(18);\n            var leaf_1 = __nested_webpack_require_3404__(19);\n            var scroll_1 = __nested_webpack_require_3404__(45);\n            var inline_1 = __nested_webpack_require_3404__(46);\n            var block_1 = __nested_webpack_require_3404__(47);\n            var embed_1 = __nested_webpack_require_3404__(48);\n            var text_1 = __nested_webpack_require_3404__(49);\n            var attributor_1 = __nested_webpack_require_3404__(12);\n            var class_1 = __nested_webpack_require_3404__(32);\n            var style_1 = __nested_webpack_require_3404__(33);\n            var store_1 = __nested_webpack_require_3404__(31);\n            var Registry = __nested_webpack_require_3404__(1);\n            var Parchment = {\n                Scope: Registry.Scope,\n                create: Registry.create,\n                find: Registry.find,\n                query: Registry.query,\n                register: Registry.register,\n                Container: container_1.default,\n                Format: format_1.default,\n                Leaf: leaf_1.default,\n                Embed: embed_1.default,\n                Scroll: scroll_1.default,\n                Block: block_1.default,\n                Inline: inline_1.default,\n                Text: text_1.default,\n                Attributor: {\n                    Attribute: attributor_1.default,\n                    Class: class_1.default,\n                    Style: style_1.default,\n                    Store: store_1.default\n                }\n            };\n            exports1.default = Parchment;\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var ParchmentError = /** @class */ function(_super) {\n                __extends(ParchmentError, _super);\n                function ParchmentError(message) {\n                    var _this = this;\n                    message = \"[Parchment] \" + message;\n                    _this = _super.call(this, message) || this;\n                    _this.message = message;\n                    _this.name = _this.constructor.name;\n                    return _this;\n                }\n                return ParchmentError;\n            }(Error);\n            exports1.ParchmentError = ParchmentError;\n            var attributes = {};\n            var classes = {};\n            var tags = {};\n            var types = {};\n            exports1.DATA_KEY = \"__blot\";\n            var Scope;\n            (function(Scope) {\n                Scope[Scope[\"TYPE\"] = 3] = \"TYPE\";\n                Scope[Scope[\"LEVEL\"] = 12] = \"LEVEL\";\n                Scope[Scope[\"ATTRIBUTE\"] = 13] = \"ATTRIBUTE\";\n                Scope[Scope[\"BLOT\"] = 14] = \"BLOT\";\n                Scope[Scope[\"INLINE\"] = 7] = \"INLINE\";\n                Scope[Scope[\"BLOCK\"] = 11] = \"BLOCK\";\n                Scope[Scope[\"BLOCK_BLOT\"] = 10] = \"BLOCK_BLOT\";\n                Scope[Scope[\"INLINE_BLOT\"] = 6] = \"INLINE_BLOT\";\n                Scope[Scope[\"BLOCK_ATTRIBUTE\"] = 9] = \"BLOCK_ATTRIBUTE\";\n                Scope[Scope[\"INLINE_ATTRIBUTE\"] = 5] = \"INLINE_ATTRIBUTE\";\n                Scope[Scope[\"ANY\"] = 15] = \"ANY\";\n            })(Scope = exports1.Scope || (exports1.Scope = {}));\n            function create(input, value) {\n                var match = query(input);\n                if (match == null) {\n                    throw new ParchmentError(\"Unable to create \" + input + \" blot\");\n                }\n                var BlotClass = match;\n                var node = // @ts-ignore\n                input instanceof Node || input[\"nodeType\"] === Node.TEXT_NODE ? input : BlotClass.create(value);\n                return new BlotClass(node, value);\n            }\n            exports1.create = create;\n            function find(node, bubble) {\n                if (bubble === void 0) {\n                    bubble = false;\n                }\n                if (node == null) return null;\n                // @ts-ignore\n                if (node[exports1.DATA_KEY] != null) return node[exports1.DATA_KEY].blot;\n                if (bubble) return find(node.parentNode, bubble);\n                return null;\n            }\n            exports1.find = find;\n            function query(query, scope) {\n                if (scope === void 0) {\n                    scope = Scope.ANY;\n                }\n                var match;\n                if (typeof query === \"string\") {\n                    match = types[query] || attributes[query];\n                // @ts-ignore\n                } else if (query instanceof Text || query[\"nodeType\"] === Node.TEXT_NODE) {\n                    match = types[\"text\"];\n                } else if (typeof query === \"number\") {\n                    if (query & Scope.LEVEL & Scope.BLOCK) {\n                        match = types[\"block\"];\n                    } else if (query & Scope.LEVEL & Scope.INLINE) {\n                        match = types[\"inline\"];\n                    }\n                } else if (query instanceof HTMLElement) {\n                    var names = (query.getAttribute(\"class\") || \"\").split(/\\s+/);\n                    for(var i in names){\n                        match = classes[names[i]];\n                        if (match) break;\n                    }\n                    match = match || tags[query.tagName];\n                }\n                if (match == null) return null;\n                // @ts-ignore\n                if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope) return match;\n                return null;\n            }\n            exports1.query = query;\n            function register() {\n                var Definitions = [];\n                for(var _i = 0; _i < arguments.length; _i++){\n                    Definitions[_i] = arguments[_i];\n                }\n                if (Definitions.length > 1) {\n                    return Definitions.map(function(d) {\n                        return register(d);\n                    });\n                }\n                var Definition = Definitions[0];\n                if (typeof Definition.blotName !== \"string\" && typeof Definition.attrName !== \"string\") {\n                    throw new ParchmentError(\"Invalid definition\");\n                } else if (Definition.blotName === \"abstract\") {\n                    throw new ParchmentError(\"Cannot register abstract class\");\n                }\n                types[Definition.blotName || Definition.attrName] = Definition;\n                if (typeof Definition.keyName === \"string\") {\n                    attributes[Definition.keyName] = Definition;\n                } else {\n                    if (Definition.className != null) {\n                        classes[Definition.className] = Definition;\n                    }\n                    if (Definition.tagName != null) {\n                        if (Array.isArray(Definition.tagName)) {\n                            Definition.tagName = Definition.tagName.map(function(tagName) {\n                                return tagName.toUpperCase();\n                            });\n                        } else {\n                            Definition.tagName = Definition.tagName.toUpperCase();\n                        }\n                        var tagNames = Array.isArray(Definition.tagName) ? Definition.tagName : [\n                            Definition.tagName\n                        ];\n                        tagNames.forEach(function(tag) {\n                            if (tags[tag] == null || Definition.className == null) {\n                                tags[tag] = Definition;\n                            }\n                        });\n                    }\n                }\n                return Definition;\n            }\n            exports1.register = register;\n        /***/ },\n        /* 2 */ /***/ function(module1, exports1, __nested_webpack_require_12128__) {\n            var diff = __nested_webpack_require_12128__(51);\n            var equal = __nested_webpack_require_12128__(11);\n            var extend = __nested_webpack_require_12128__(3);\n            var op = __nested_webpack_require_12128__(20);\n            var NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\n            var Delta = function(ops) {\n                // Assume we are given a well formed ops\n                if (Array.isArray(ops)) {\n                    this.ops = ops;\n                } else if (ops != null && Array.isArray(ops.ops)) {\n                    this.ops = ops.ops;\n                } else {\n                    this.ops = [];\n                }\n            };\n            Delta.prototype.insert = function(text, attributes) {\n                var newOp = {};\n                if (text.length === 0) return this;\n                newOp.insert = text;\n                if (attributes != null && typeof attributes === \"object\" && Object.keys(attributes).length > 0) {\n                    newOp.attributes = attributes;\n                }\n                return this.push(newOp);\n            };\n            Delta.prototype[\"delete\"] = function(length) {\n                if (length <= 0) return this;\n                return this.push({\n                    \"delete\": length\n                });\n            };\n            Delta.prototype.retain = function(length, attributes) {\n                if (length <= 0) return this;\n                var newOp = {\n                    retain: length\n                };\n                if (attributes != null && typeof attributes === \"object\" && Object.keys(attributes).length > 0) {\n                    newOp.attributes = attributes;\n                }\n                return this.push(newOp);\n            };\n            Delta.prototype.push = function(newOp) {\n                var index = this.ops.length;\n                var lastOp = this.ops[index - 1];\n                newOp = extend(true, {}, newOp);\n                if (typeof lastOp === \"object\") {\n                    if (typeof newOp[\"delete\"] === \"number\" && typeof lastOp[\"delete\"] === \"number\") {\n                        this.ops[index - 1] = {\n                            \"delete\": lastOp[\"delete\"] + newOp[\"delete\"]\n                        };\n                        return this;\n                    }\n                    // Since it does not matter if we insert before or after deleting at the same index,\n                    // always prefer to insert first\n                    if (typeof lastOp[\"delete\"] === \"number\" && newOp.insert != null) {\n                        index -= 1;\n                        lastOp = this.ops[index - 1];\n                        if (typeof lastOp !== \"object\") {\n                            this.ops.unshift(newOp);\n                            return this;\n                        }\n                    }\n                    if (equal(newOp.attributes, lastOp.attributes)) {\n                        if (typeof newOp.insert === \"string\" && typeof lastOp.insert === \"string\") {\n                            this.ops[index - 1] = {\n                                insert: lastOp.insert + newOp.insert\n                            };\n                            if (typeof newOp.attributes === \"object\") this.ops[index - 1].attributes = newOp.attributes;\n                            return this;\n                        } else if (typeof newOp.retain === \"number\" && typeof lastOp.retain === \"number\") {\n                            this.ops[index - 1] = {\n                                retain: lastOp.retain + newOp.retain\n                            };\n                            if (typeof newOp.attributes === \"object\") this.ops[index - 1].attributes = newOp.attributes;\n                            return this;\n                        }\n                    }\n                }\n                if (index === this.ops.length) {\n                    this.ops.push(newOp);\n                } else {\n                    this.ops.splice(index, 0, newOp);\n                }\n                return this;\n            };\n            Delta.prototype.chop = function() {\n                var lastOp = this.ops[this.ops.length - 1];\n                if (lastOp && lastOp.retain && !lastOp.attributes) {\n                    this.ops.pop();\n                }\n                return this;\n            };\n            Delta.prototype.filter = function(predicate) {\n                return this.ops.filter(predicate);\n            };\n            Delta.prototype.forEach = function(predicate) {\n                this.ops.forEach(predicate);\n            };\n            Delta.prototype.map = function(predicate) {\n                return this.ops.map(predicate);\n            };\n            Delta.prototype.partition = function(predicate) {\n                var passed = [], failed = [];\n                this.forEach(function(op) {\n                    var target = predicate(op) ? passed : failed;\n                    target.push(op);\n                });\n                return [\n                    passed,\n                    failed\n                ];\n            };\n            Delta.prototype.reduce = function(predicate, initial) {\n                return this.ops.reduce(predicate, initial);\n            };\n            Delta.prototype.changeLength = function() {\n                return this.reduce(function(length, elem) {\n                    if (elem.insert) {\n                        return length + op.length(elem);\n                    } else if (elem.delete) {\n                        return length - elem.delete;\n                    }\n                    return length;\n                }, 0);\n            };\n            Delta.prototype.length = function() {\n                return this.reduce(function(length, elem) {\n                    return length + op.length(elem);\n                }, 0);\n            };\n            Delta.prototype.slice = function(start, end) {\n                start = start || 0;\n                if (typeof end !== \"number\") end = Infinity;\n                var ops = [];\n                var iter = op.iterator(this.ops);\n                var index = 0;\n                while(index < end && iter.hasNext()){\n                    var nextOp;\n                    if (index < start) {\n                        nextOp = iter.next(start - index);\n                    } else {\n                        nextOp = iter.next(end - index);\n                        ops.push(nextOp);\n                    }\n                    index += op.length(nextOp);\n                }\n                return new Delta(ops);\n            };\n            Delta.prototype.compose = function(other) {\n                var thisIter = op.iterator(this.ops);\n                var otherIter = op.iterator(other.ops);\n                var ops = [];\n                var firstOther = otherIter.peek();\n                if (firstOther != null && typeof firstOther.retain === \"number\" && firstOther.attributes == null) {\n                    var firstLeft = firstOther.retain;\n                    while(thisIter.peekType() === \"insert\" && thisIter.peekLength() <= firstLeft){\n                        firstLeft -= thisIter.peekLength();\n                        ops.push(thisIter.next());\n                    }\n                    if (firstOther.retain - firstLeft > 0) {\n                        otherIter.next(firstOther.retain - firstLeft);\n                    }\n                }\n                var delta = new Delta(ops);\n                while(thisIter.hasNext() || otherIter.hasNext()){\n                    if (otherIter.peekType() === \"insert\") {\n                        delta.push(otherIter.next());\n                    } else if (thisIter.peekType() === \"delete\") {\n                        delta.push(thisIter.next());\n                    } else {\n                        var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                        var thisOp = thisIter.next(length);\n                        var otherOp = otherIter.next(length);\n                        if (typeof otherOp.retain === \"number\") {\n                            var newOp = {};\n                            if (typeof thisOp.retain === \"number\") {\n                                newOp.retain = length;\n                            } else {\n                                newOp.insert = thisOp.insert;\n                            }\n                            // Preserve null when composing with a retain, otherwise remove it for inserts\n                            var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === \"number\");\n                            if (attributes) newOp.attributes = attributes;\n                            delta.push(newOp);\n                            // Optimization if rest of other is just retain\n                            if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {\n                                var rest = new Delta(thisIter.rest());\n                                return delta.concat(rest).chop();\n                            }\n                        // Other op should be delete, we could be an insert or retain\n                        // Insert + delete cancels out\n                        } else if (typeof otherOp[\"delete\"] === \"number\" && typeof thisOp.retain === \"number\") {\n                            delta.push(otherOp);\n                        }\n                    }\n                }\n                return delta.chop();\n            };\n            Delta.prototype.concat = function(other) {\n                var delta = new Delta(this.ops.slice());\n                if (other.ops.length > 0) {\n                    delta.push(other.ops[0]);\n                    delta.ops = delta.ops.concat(other.ops.slice(1));\n                }\n                return delta;\n            };\n            Delta.prototype.diff = function(other, index) {\n                if (this.ops === other.ops) {\n                    return new Delta();\n                }\n                var strings = [\n                    this,\n                    other\n                ].map(function(delta) {\n                    return delta.map(function(op) {\n                        if (op.insert != null) {\n                            return typeof op.insert === \"string\" ? op.insert : NULL_CHARACTER;\n                        }\n                        var prep = delta === other ? \"on\" : \"with\";\n                        throw new Error(\"diff() called \" + prep + \" non-document\");\n                    }).join(\"\");\n                });\n                var delta = new Delta();\n                var diffResult = diff(strings[0], strings[1], index);\n                var thisIter = op.iterator(this.ops);\n                var otherIter = op.iterator(other.ops);\n                diffResult.forEach(function(component) {\n                    var length = component[1].length;\n                    while(length > 0){\n                        var opLength = 0;\n                        switch(component[0]){\n                            case diff.INSERT:\n                                opLength = Math.min(otherIter.peekLength(), length);\n                                delta.push(otherIter.next(opLength));\n                                break;\n                            case diff.DELETE:\n                                opLength = Math.min(length, thisIter.peekLength());\n                                thisIter.next(opLength);\n                                delta[\"delete\"](opLength);\n                                break;\n                            case diff.EQUAL:\n                                opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n                                var thisOp = thisIter.next(opLength);\n                                var otherOp = otherIter.next(opLength);\n                                if (equal(thisOp.insert, otherOp.insert)) {\n                                    delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));\n                                } else {\n                                    delta.push(otherOp)[\"delete\"](opLength);\n                                }\n                                break;\n                        }\n                        length -= opLength;\n                    }\n                });\n                return delta.chop();\n            };\n            Delta.prototype.eachLine = function(predicate, newline) {\n                newline = newline || \"\\n\";\n                var iter = op.iterator(this.ops);\n                var line = new Delta();\n                var i = 0;\n                while(iter.hasNext()){\n                    if (iter.peekType() !== \"insert\") return;\n                    var thisOp = iter.peek();\n                    var start = op.length(thisOp) - iter.peekLength();\n                    var index = typeof thisOp.insert === \"string\" ? thisOp.insert.indexOf(newline, start) - start : -1;\n                    if (index < 0) {\n                        line.push(iter.next());\n                    } else if (index > 0) {\n                        line.push(iter.next(index));\n                    } else {\n                        if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n                            return;\n                        }\n                        i += 1;\n                        line = new Delta();\n                    }\n                }\n                if (line.length() > 0) {\n                    predicate(line, {}, i);\n                }\n            };\n            Delta.prototype.transform = function(other, priority) {\n                priority = !!priority;\n                if (typeof other === \"number\") {\n                    return this.transformPosition(other, priority);\n                }\n                var thisIter = op.iterator(this.ops);\n                var otherIter = op.iterator(other.ops);\n                var delta = new Delta();\n                while(thisIter.hasNext() || otherIter.hasNext()){\n                    if (thisIter.peekType() === \"insert\" && (priority || otherIter.peekType() !== \"insert\")) {\n                        delta.retain(op.length(thisIter.next()));\n                    } else if (otherIter.peekType() === \"insert\") {\n                        delta.push(otherIter.next());\n                    } else {\n                        var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                        var thisOp = thisIter.next(length);\n                        var otherOp = otherIter.next(length);\n                        if (thisOp[\"delete\"]) {\n                            continue;\n                        } else if (otherOp[\"delete\"]) {\n                            delta.push(otherOp);\n                        } else {\n                            // We retain either their retain or insert\n                            delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));\n                        }\n                    }\n                }\n                return delta.chop();\n            };\n            Delta.prototype.transformPosition = function(index, priority) {\n                priority = !!priority;\n                var thisIter = op.iterator(this.ops);\n                var offset = 0;\n                while(thisIter.hasNext() && offset <= index){\n                    var length = thisIter.peekLength();\n                    var nextType = thisIter.peekType();\n                    thisIter.next();\n                    if (nextType === \"delete\") {\n                        index -= Math.min(length, index - offset);\n                        continue;\n                    } else if (nextType === \"insert\" && (offset < index || !priority)) {\n                        index += length;\n                    }\n                    offset += length;\n                }\n                return index;\n            };\n            module1.exports = Delta;\n        /***/ },\n        /* 3 */ /***/ function(module1, exports1) {\n            \"use strict\";\n            var hasOwn = Object.prototype.hasOwnProperty;\n            var toStr = Object.prototype.toString;\n            var defineProperty = Object.defineProperty;\n            var gOPD = Object.getOwnPropertyDescriptor;\n            var isArray = function isArray(arr) {\n                if (typeof Array.isArray === \"function\") {\n                    return Array.isArray(arr);\n                }\n                return toStr.call(arr) === \"[object Array]\";\n            };\n            var isPlainObject = function isPlainObject(obj) {\n                if (!obj || toStr.call(obj) !== \"[object Object]\") {\n                    return false;\n                }\n                var hasOwnConstructor = hasOwn.call(obj, \"constructor\");\n                var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\");\n                // Not own constructor property must be Object\n                if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n                    return false;\n                }\n                // Own properties are enumerated firstly, so to speed up,\n                // if last one is own, then all properties are own.\n                var key;\n                for(key in obj){}\n                return typeof key === \"undefined\" || hasOwn.call(obj, key);\n            };\n            // If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\n            var setProperty = function setProperty(target, options) {\n                if (defineProperty && options.name === \"__proto__\") {\n                    defineProperty(target, options.name, {\n                        enumerable: true,\n                        configurable: true,\n                        value: options.newValue,\n                        writable: true\n                    });\n                } else {\n                    target[options.name] = options.newValue;\n                }\n            };\n            // Return undefined instead of __proto__ if '__proto__' is not an own property\n            var getProperty = function getProperty(obj, name) {\n                if (name === \"__proto__\") {\n                    if (!hasOwn.call(obj, name)) {\n                        return void 0;\n                    } else if (gOPD) {\n                        // In early versions of node, obj['__proto__'] is buggy when obj has\n                        // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n                        return gOPD(obj, name).value;\n                    }\n                }\n                return obj[name];\n            };\n            module1.exports = function extend() {\n                var options, name, src, copy, copyIsArray, clone;\n                var target = arguments[0];\n                var i = 1;\n                var length = arguments.length;\n                var deep = false;\n                // Handle a deep copy situation\n                if (typeof target === \"boolean\") {\n                    deep = target;\n                    target = arguments[1] || {};\n                    // skip the boolean and the target\n                    i = 2;\n                }\n                if (target == null || typeof target !== \"object\" && typeof target !== \"function\") {\n                    target = {};\n                }\n                for(; i < length; ++i){\n                    options = arguments[i];\n                    // Only deal with non-null/undefined values\n                    if (options != null) {\n                        // Extend the base object\n                        for(name in options){\n                            src = getProperty(target, name);\n                            copy = getProperty(options, name);\n                            // Prevent never-ending loop\n                            if (target !== copy) {\n                                // Recurse if we're merging plain objects or arrays\n                                if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n                                    if (copyIsArray) {\n                                        copyIsArray = false;\n                                        clone = src && isArray(src) ? src : [];\n                                    } else {\n                                        clone = src && isPlainObject(src) ? src : {};\n                                    }\n                                    // Never move original objects, clone them\n                                    setProperty(target, {\n                                        name: name,\n                                        newValue: extend(deep, clone, copy)\n                                    });\n                                // Don't bring in undefined values\n                                } else if (typeof copy !== \"undefined\") {\n                                    setProperty(target, {\n                                        name: name,\n                                        newValue: copy\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n                // Return the modified object\n                return target;\n            };\n        /***/ },\n        /* 4 */ /***/ function(module1, exports1, __nested_webpack_require_33519__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.BlockEmbed = exports1.bubbleFormats = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _extend = __nested_webpack_require_33519__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _quillDelta = __nested_webpack_require_33519__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _parchment = __nested_webpack_require_33519__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _break = __nested_webpack_require_33519__(16);\n            var _break2 = _interopRequireDefault(_break);\n            var _inline = __nested_webpack_require_33519__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            var _text = __nested_webpack_require_33519__(7);\n            var _text2 = _interopRequireDefault(_text);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var NEWLINE_LENGTH = 1;\n            var BlockEmbed = function(_Parchment$Embed) {\n                _inherits(BlockEmbed, _Parchment$Embed);\n                function BlockEmbed() {\n                    _classCallCheck(this, BlockEmbed);\n                    return _possibleConstructorReturn(this, (BlockEmbed.__proto__ || Object.getPrototypeOf(BlockEmbed)).apply(this, arguments));\n                }\n                _createClass(BlockEmbed, [\n                    {\n                        key: \"attach\",\n                        value: function attach() {\n                            _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), \"attach\", this).call(this);\n                            this.attributes = new _parchment2.default.Attributor.Store(this.domNode);\n                        }\n                    },\n                    {\n                        key: \"delta\",\n                        value: function delta() {\n                            return new _quillDelta2.default().insert(this.value(), (0, _extend2.default)(this.formats(), this.attributes.values()));\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            var attribute = _parchment2.default.query(name, _parchment2.default.Scope.BLOCK_ATTRIBUTE);\n                            if (attribute != null) {\n                                this.attributes.attribute(attribute, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"formatAt\",\n                        value: function formatAt(index, length, name, value) {\n                            this.format(name, value);\n                        }\n                    },\n                    {\n                        key: \"insertAt\",\n                        value: function insertAt(index, value, def) {\n                            if (typeof value === \"string\" && value.endsWith(\"\\n\")) {\n                                var block = _parchment2.default.create(Block.blotName);\n                                this.parent.insertBefore(block, index === 0 ? this : this.next);\n                                block.insertAt(0, value.slice(0, -1));\n                            } else {\n                                _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), \"insertAt\", this).call(this, index, value, def);\n                            }\n                        }\n                    }\n                ]);\n                return BlockEmbed;\n            }(_parchment2.default.Embed);\n            BlockEmbed.scope = _parchment2.default.Scope.BLOCK_BLOT;\n            // It is important for cursor behavior BlockEmbeds use tags that are block level elements\n            var Block = function(_Parchment$Block) {\n                _inherits(Block, _Parchment$Block);\n                function Block(domNode) {\n                    _classCallCheck(this, Block);\n                    var _this2 = _possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).call(this, domNode));\n                    _this2.cache = {};\n                    return _this2;\n                }\n                _createClass(Block, [\n                    {\n                        key: \"delta\",\n                        value: function delta() {\n                            if (this.cache.delta == null) {\n                                this.cache.delta = this.descendants(_parchment2.default.Leaf).reduce(function(delta, leaf) {\n                                    if (leaf.length() === 0) {\n                                        return delta;\n                                    } else {\n                                        return delta.insert(leaf.value(), bubbleFormats(leaf));\n                                    }\n                                }, new _quillDelta2.default()).insert(\"\\n\", bubbleFormats(this));\n                            }\n                            return this.cache.delta;\n                        }\n                    },\n                    {\n                        key: \"deleteAt\",\n                        value: function deleteAt(index, length) {\n                            _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"deleteAt\", this).call(this, index, length);\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"formatAt\",\n                        value: function formatAt(index, length, name, value) {\n                            if (length <= 0) return;\n                            if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {\n                                if (index + length === this.length()) {\n                                    this.format(name, value);\n                                }\n                            } else {\n                                _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"formatAt\", this).call(this, index, Math.min(length, this.length() - index - 1), name, value);\n                            }\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"insertAt\",\n                        value: function insertAt(index, value, def) {\n                            if (def != null) return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"insertAt\", this).call(this, index, value, def);\n                            if (value.length === 0) return;\n                            var lines = value.split(\"\\n\");\n                            var text = lines.shift();\n                            if (text.length > 0) {\n                                if (index < this.length() - 1 || this.children.tail == null) {\n                                    _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"insertAt\", this).call(this, Math.min(index, this.length() - 1), text);\n                                } else {\n                                    this.children.tail.insertAt(this.children.tail.length(), text);\n                                }\n                                this.cache = {};\n                            }\n                            var block = this;\n                            lines.reduce(function(index, line) {\n                                block = block.split(index, true);\n                                block.insertAt(0, line);\n                                return line.length;\n                            }, index + text.length);\n                        }\n                    },\n                    {\n                        key: \"insertBefore\",\n                        value: function insertBefore(blot, ref) {\n                            var head = this.children.head;\n                            _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"insertBefore\", this).call(this, blot, ref);\n                            if (head instanceof _break2.default) {\n                                head.remove();\n                            }\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"length\",\n                        value: function length() {\n                            if (this.cache.length == null) {\n                                this.cache.length = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"length\", this).call(this) + NEWLINE_LENGTH;\n                            }\n                            return this.cache.length;\n                        }\n                    },\n                    {\n                        key: \"moveChildren\",\n                        value: function moveChildren(target, ref) {\n                            _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"moveChildren\", this).call(this, target, ref);\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"optimize\",\n                        value: function optimize(context) {\n                            _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"optimize\", this).call(this, context);\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"path\",\n                        value: function path(index) {\n                            return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"path\", this).call(this, index, true);\n                        }\n                    },\n                    {\n                        key: \"removeChild\",\n                        value: function removeChild(child) {\n                            _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"removeChild\", this).call(this, child);\n                            this.cache = {};\n                        }\n                    },\n                    {\n                        key: \"split\",\n                        value: function split(index) {\n                            var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                            if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {\n                                var clone = this.clone();\n                                if (index === 0) {\n                                    this.parent.insertBefore(clone, this);\n                                    return this;\n                                } else {\n                                    this.parent.insertBefore(clone, this.next);\n                                    return clone;\n                                }\n                            } else {\n                                var next = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), \"split\", this).call(this, index, force);\n                                this.cache = {};\n                                return next;\n                            }\n                        }\n                    }\n                ]);\n                return Block;\n            }(_parchment2.default.Block);\n            Block.blotName = \"block\";\n            Block.tagName = \"P\";\n            Block.defaultChild = \"break\";\n            Block.allowedChildren = [\n                _inline2.default,\n                _parchment2.default.Embed,\n                _text2.default\n            ];\n            function bubbleFormats(blot) {\n                var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                if (blot == null) return formats;\n                if (typeof blot.formats === \"function\") {\n                    formats = (0, _extend2.default)(formats, blot.formats());\n                }\n                if (blot.parent == null || blot.parent.blotName == \"scroll\" || blot.parent.statics.scope !== blot.statics.scope) {\n                    return formats;\n                }\n                return bubbleFormats(blot.parent, formats);\n            }\n            exports1.bubbleFormats = bubbleFormats;\n            exports1.BlockEmbed = BlockEmbed;\n            exports1.default = Block;\n        /***/ },\n        /* 5 */ /***/ function(module1, exports1, __nested_webpack_require_49250__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.overload = exports1.expandConfig = undefined;\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            __nested_webpack_require_49250__(50);\n            var _quillDelta = __nested_webpack_require_49250__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _editor = __nested_webpack_require_49250__(14);\n            var _editor2 = _interopRequireDefault(_editor);\n            var _emitter3 = __nested_webpack_require_49250__(8);\n            var _emitter4 = _interopRequireDefault(_emitter3);\n            var _module = __nested_webpack_require_49250__(9);\n            var _module2 = _interopRequireDefault(_module);\n            var _parchment = __nested_webpack_require_49250__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _selection = __nested_webpack_require_49250__(15);\n            var _selection2 = _interopRequireDefault(_selection);\n            var _extend = __nested_webpack_require_49250__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _logger = __nested_webpack_require_49250__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            var _theme = __nested_webpack_require_49250__(34);\n            var _theme2 = _interopRequireDefault(_theme);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var debug = (0, _logger2.default)(\"quill\");\n            var Quill = function() {\n                _createClass(Quill, null, [\n                    {\n                        key: \"debug\",\n                        value: function debug(limit) {\n                            if (limit === true) {\n                                limit = \"log\";\n                            }\n                            _logger2.default.level(limit);\n                        }\n                    },\n                    {\n                        key: \"find\",\n                        value: function find(node) {\n                            return node.__quill || _parchment2.default.find(node);\n                        }\n                    },\n                    {\n                        key: \"import\",\n                        value: function _import(name) {\n                            if (this.imports[name] == null) {\n                                debug.error(\"Cannot import \" + name + \". Are you sure it was registered?\");\n                            }\n                            return this.imports[name];\n                        }\n                    },\n                    {\n                        key: \"register\",\n                        value: function register(path, target) {\n                            var _this = this;\n                            var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                            if (typeof path !== \"string\") {\n                                var name = path.attrName || path.blotName;\n                                if (typeof name === \"string\") {\n                                    // register(Blot | Attributor, overwrite)\n                                    this.register(\"formats/\" + name, path, target);\n                                } else {\n                                    Object.keys(path).forEach(function(key) {\n                                        _this.register(key, path[key], target);\n                                    });\n                                }\n                            } else {\n                                if (this.imports[path] != null && !overwrite) {\n                                    debug.warn(\"Overwriting \" + path + \" with\", target);\n                                }\n                                this.imports[path] = target;\n                                if ((path.startsWith(\"blots/\") || path.startsWith(\"formats/\")) && target.blotName !== \"abstract\") {\n                                    _parchment2.default.register(target);\n                                } else if (path.startsWith(\"modules\") && typeof target.register === \"function\") {\n                                    target.register();\n                                }\n                            }\n                        }\n                    }\n                ]);\n                function Quill(container) {\n                    var _this2 = this;\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    _classCallCheck(this, Quill);\n                    this.options = expandConfig(container, options);\n                    this.container = this.options.container;\n                    if (this.container == null) {\n                        return debug.error(\"Invalid Quill container\", container);\n                    }\n                    if (this.options.debug) {\n                        Quill.debug(this.options.debug);\n                    }\n                    var html = this.container.innerHTML.trim();\n                    this.container.classList.add(\"ql-container\");\n                    this.container.innerHTML = \"\";\n                    this.container.__quill = this;\n                    this.root = this.addContainer(\"ql-editor\");\n                    this.root.classList.add(\"ql-blank\");\n                    this.root.setAttribute(\"data-gramm\", false);\n                    this.scrollingContainer = this.options.scrollingContainer || this.root;\n                    this.emitter = new _emitter4.default();\n                    this.scroll = _parchment2.default.create(this.root, {\n                        emitter: this.emitter,\n                        whitelist: this.options.formats\n                    });\n                    this.editor = new _editor2.default(this.scroll);\n                    this.selection = new _selection2.default(this.scroll, this.emitter);\n                    this.theme = new this.options.theme(this, this.options);\n                    this.keyboard = this.theme.addModule(\"keyboard\");\n                    this.clipboard = this.theme.addModule(\"clipboard\");\n                    this.history = this.theme.addModule(\"history\");\n                    this.theme.init();\n                    this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function(type) {\n                        if (type === _emitter4.default.events.TEXT_CHANGE) {\n                            _this2.root.classList.toggle(\"ql-blank\", _this2.editor.isBlank());\n                        }\n                    });\n                    this.emitter.on(_emitter4.default.events.SCROLL_UPDATE, function(source, mutations) {\n                        var range = _this2.selection.lastRange;\n                        var index = range && range.length === 0 ? range.index : undefined;\n                        modify.call(_this2, function() {\n                            return _this2.editor.update(null, mutations, index);\n                        }, source);\n                    });\n                    var contents = this.clipboard.convert(\"<div class='ql-editor' style=\\\"white-space: normal;\\\">\" + html + \"<p><br></p></div>\");\n                    this.setContents(contents);\n                    this.history.clear();\n                    if (this.options.placeholder) {\n                        this.root.setAttribute(\"data-placeholder\", this.options.placeholder);\n                    }\n                    if (this.options.readOnly) {\n                        this.disable();\n                    }\n                }\n                _createClass(Quill, [\n                    {\n                        key: \"addContainer\",\n                        value: function addContainer(container) {\n                            var refNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n                            if (typeof container === \"string\") {\n                                var className = container;\n                                container = document.createElement(\"div\");\n                                container.classList.add(className);\n                            }\n                            this.container.insertBefore(container, refNode);\n                            return container;\n                        }\n                    },\n                    {\n                        key: \"blur\",\n                        value: function blur() {\n                            this.selection.setRange(null);\n                        }\n                    },\n                    {\n                        key: \"deleteText\",\n                        value: function deleteText(index, length, source) {\n                            var _this3 = this;\n                            var _overload = overload(index, length, source);\n                            var _overload2 = _slicedToArray(_overload, 4);\n                            index = _overload2[0];\n                            length = _overload2[1];\n                            source = _overload2[3];\n                            return modify.call(this, function() {\n                                return _this3.editor.deleteText(index, length);\n                            }, source, index, -1 * length);\n                        }\n                    },\n                    {\n                        key: \"disable\",\n                        value: function disable() {\n                            this.enable(false);\n                        }\n                    },\n                    {\n                        key: \"enable\",\n                        value: function enable() {\n                            var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n                            this.scroll.enable(enabled);\n                            this.container.classList.toggle(\"ql-disabled\", !enabled);\n                        }\n                    },\n                    {\n                        key: \"focus\",\n                        value: function focus() {\n                            var scrollTop = this.scrollingContainer.scrollTop;\n                            this.selection.focus();\n                            this.scrollingContainer.scrollTop = scrollTop;\n                            this.scrollIntoView();\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            var _this4 = this;\n                            var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;\n                            return modify.call(this, function() {\n                                var range = _this4.getSelection(true);\n                                var change = new _quillDelta2.default();\n                                if (range == null) {\n                                    return change;\n                                } else if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {\n                                    change = _this4.editor.formatLine(range.index, range.length, _defineProperty({}, name, value));\n                                } else if (range.length === 0) {\n                                    _this4.selection.format(name, value);\n                                    return change;\n                                } else {\n                                    change = _this4.editor.formatText(range.index, range.length, _defineProperty({}, name, value));\n                                }\n                                _this4.setSelection(range, _emitter4.default.sources.SILENT);\n                                return change;\n                            }, source);\n                        }\n                    },\n                    {\n                        key: \"formatLine\",\n                        value: function formatLine(index, length, name, value, source) {\n                            var _this5 = this;\n                            var formats = void 0;\n                            var _overload3 = overload(index, length, name, value, source);\n                            var _overload4 = _slicedToArray(_overload3, 4);\n                            index = _overload4[0];\n                            length = _overload4[1];\n                            formats = _overload4[2];\n                            source = _overload4[3];\n                            return modify.call(this, function() {\n                                return _this5.editor.formatLine(index, length, formats);\n                            }, source, index, 0);\n                        }\n                    },\n                    {\n                        key: \"formatText\",\n                        value: function formatText(index, length, name, value, source) {\n                            var _this6 = this;\n                            var formats = void 0;\n                            var _overload5 = overload(index, length, name, value, source);\n                            var _overload6 = _slicedToArray(_overload5, 4);\n                            index = _overload6[0];\n                            length = _overload6[1];\n                            formats = _overload6[2];\n                            source = _overload6[3];\n                            return modify.call(this, function() {\n                                return _this6.editor.formatText(index, length, formats);\n                            }, source, index, 0);\n                        }\n                    },\n                    {\n                        key: \"getBounds\",\n                        value: function getBounds(index) {\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                            var bounds = void 0;\n                            if (typeof index === \"number\") {\n                                bounds = this.selection.getBounds(index, length);\n                            } else {\n                                bounds = this.selection.getBounds(index.index, index.length);\n                            }\n                            var containerBounds = this.container.getBoundingClientRect();\n                            return {\n                                bottom: bounds.bottom - containerBounds.top,\n                                height: bounds.height,\n                                left: bounds.left - containerBounds.left,\n                                right: bounds.right - containerBounds.left,\n                                top: bounds.top - containerBounds.top,\n                                width: bounds.width\n                            };\n                        }\n                    },\n                    {\n                        key: \"getContents\",\n                        value: function getContents() {\n                            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;\n                            var _overload7 = overload(index, length);\n                            var _overload8 = _slicedToArray(_overload7, 2);\n                            index = _overload8[0];\n                            length = _overload8[1];\n                            return this.editor.getContents(index, length);\n                        }\n                    },\n                    {\n                        key: \"getFormat\",\n                        value: function getFormat() {\n                            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getSelection(true);\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                            if (typeof index === \"number\") {\n                                return this.editor.getFormat(index, length);\n                            } else {\n                                return this.editor.getFormat(index.index, index.length);\n                            }\n                        }\n                    },\n                    {\n                        key: \"getIndex\",\n                        value: function getIndex(blot) {\n                            return blot.offset(this.scroll);\n                        }\n                    },\n                    {\n                        key: \"getLength\",\n                        value: function getLength() {\n                            return this.scroll.length();\n                        }\n                    },\n                    {\n                        key: \"getLeaf\",\n                        value: function getLeaf(index) {\n                            return this.scroll.leaf(index);\n                        }\n                    },\n                    {\n                        key: \"getLine\",\n                        value: function getLine(index) {\n                            return this.scroll.line(index);\n                        }\n                    },\n                    {\n                        key: \"getLines\",\n                        value: function getLines() {\n                            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;\n                            if (typeof index !== \"number\") {\n                                return this.scroll.lines(index.index, index.length);\n                            } else {\n                                return this.scroll.lines(index, length);\n                            }\n                        }\n                    },\n                    {\n                        key: \"getModule\",\n                        value: function getModule(name) {\n                            return this.theme.modules[name];\n                        }\n                    },\n                    {\n                        key: \"getSelection\",\n                        value: function getSelection() {\n                            var focus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n                            if (focus) this.focus();\n                            this.update(); // Make sure we access getRange with editor in consistent state\n                            return this.selection.getRange()[0];\n                        }\n                    },\n                    {\n                        key: \"getText\",\n                        value: function getText() {\n                            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;\n                            var _overload9 = overload(index, length);\n                            var _overload10 = _slicedToArray(_overload9, 2);\n                            index = _overload10[0];\n                            length = _overload10[1];\n                            return this.editor.getText(index, length);\n                        }\n                    },\n                    {\n                        key: \"hasFocus\",\n                        value: function hasFocus() {\n                            return this.selection.hasFocus();\n                        }\n                    },\n                    {\n                        key: \"insertEmbed\",\n                        value: function insertEmbed(index, embed, value) {\n                            var _this7 = this;\n                            var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Quill.sources.API;\n                            return modify.call(this, function() {\n                                return _this7.editor.insertEmbed(index, embed, value);\n                            }, source, index);\n                        }\n                    },\n                    {\n                        key: \"insertText\",\n                        value: function insertText(index, text, name, value, source) {\n                            var _this8 = this;\n                            var formats = void 0;\n                            var _overload11 = overload(index, 0, name, value, source);\n                            var _overload12 = _slicedToArray(_overload11, 4);\n                            index = _overload12[0];\n                            formats = _overload12[2];\n                            source = _overload12[3];\n                            return modify.call(this, function() {\n                                return _this8.editor.insertText(index, text, formats);\n                            }, source, index, text.length);\n                        }\n                    },\n                    {\n                        key: \"isEnabled\",\n                        value: function isEnabled() {\n                            return !this.container.classList.contains(\"ql-disabled\");\n                        }\n                    },\n                    {\n                        key: \"off\",\n                        value: function off() {\n                            return this.emitter.off.apply(this.emitter, arguments);\n                        }\n                    },\n                    {\n                        key: \"on\",\n                        value: function on() {\n                            return this.emitter.on.apply(this.emitter, arguments);\n                        }\n                    },\n                    {\n                        key: \"once\",\n                        value: function once() {\n                            return this.emitter.once.apply(this.emitter, arguments);\n                        }\n                    },\n                    {\n                        key: \"pasteHTML\",\n                        value: function pasteHTML(index, html, source) {\n                            this.clipboard.dangerouslyPasteHTML(index, html, source);\n                        }\n                    },\n                    {\n                        key: \"removeFormat\",\n                        value: function removeFormat(index, length, source) {\n                            var _this9 = this;\n                            var _overload13 = overload(index, length, source);\n                            var _overload14 = _slicedToArray(_overload13, 4);\n                            index = _overload14[0];\n                            length = _overload14[1];\n                            source = _overload14[3];\n                            return modify.call(this, function() {\n                                return _this9.editor.removeFormat(index, length);\n                            }, source, index);\n                        }\n                    },\n                    {\n                        key: \"scrollIntoView\",\n                        value: function scrollIntoView() {\n                            this.selection.scrollIntoView(this.scrollingContainer);\n                        }\n                    },\n                    {\n                        key: \"setContents\",\n                        value: function setContents(delta) {\n                            var _this10 = this;\n                            var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;\n                            return modify.call(this, function() {\n                                delta = new _quillDelta2.default(delta);\n                                var length = _this10.getLength();\n                                var deleted = _this10.editor.deleteText(0, length);\n                                var applied = _this10.editor.applyDelta(delta);\n                                var lastOp = applied.ops[applied.ops.length - 1];\n                                if (lastOp != null && typeof lastOp.insert === \"string\" && lastOp.insert[lastOp.insert.length - 1] === \"\\n\") {\n                                    _this10.editor.deleteText(_this10.getLength() - 1, 1);\n                                    applied.delete(1);\n                                }\n                                var ret = deleted.compose(applied);\n                                return ret;\n                            }, source);\n                        }\n                    },\n                    {\n                        key: \"setSelection\",\n                        value: function setSelection(index, length, source) {\n                            if (index == null) {\n                                this.selection.setRange(null, length || Quill.sources.API);\n                            } else {\n                                var _overload15 = overload(index, length, source);\n                                var _overload16 = _slicedToArray(_overload15, 4);\n                                index = _overload16[0];\n                                length = _overload16[1];\n                                source = _overload16[3];\n                                this.selection.setRange(new _selection.Range(index, length), source);\n                                if (source !== _emitter4.default.sources.SILENT) {\n                                    this.selection.scrollIntoView(this.scrollingContainer);\n                                }\n                            }\n                        }\n                    },\n                    {\n                        key: \"setText\",\n                        value: function setText(text) {\n                            var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;\n                            var delta = new _quillDelta2.default().insert(text);\n                            return this.setContents(delta, source);\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update() {\n                            var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;\n                            var change = this.scroll.update(source); // Will update selection before selection.update() does if text changes\n                            this.selection.update(source);\n                            return change;\n                        }\n                    },\n                    {\n                        key: \"updateContents\",\n                        value: function updateContents(delta) {\n                            var _this11 = this;\n                            var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;\n                            return modify.call(this, function() {\n                                delta = new _quillDelta2.default(delta);\n                                return _this11.editor.applyDelta(delta, source);\n                            }, source, true);\n                        }\n                    }\n                ]);\n                return Quill;\n            }();\n            Quill.DEFAULTS = {\n                bounds: null,\n                formats: null,\n                modules: {},\n                placeholder: \"\",\n                readOnly: false,\n                scrollingContainer: null,\n                strict: true,\n                theme: \"default\"\n            };\n            Quill.events = _emitter4.default.events;\n            Quill.sources = _emitter4.default.sources;\n            // eslint-disable-next-line no-undef\n            Quill.version =  false ? 0 : \"1.3.7\";\n            Quill.imports = {\n                \"delta\": _quillDelta2.default,\n                \"parchment\": _parchment2.default,\n                \"core/module\": _module2.default,\n                \"core/theme\": _theme2.default\n            };\n            function expandConfig(container, userConfig) {\n                userConfig = (0, _extend2.default)(true, {\n                    container: container,\n                    modules: {\n                        clipboard: true,\n                        keyboard: true,\n                        history: true\n                    }\n                }, userConfig);\n                if (!userConfig.theme || userConfig.theme === Quill.DEFAULTS.theme) {\n                    userConfig.theme = _theme2.default;\n                } else {\n                    userConfig.theme = Quill.import(\"themes/\" + userConfig.theme);\n                    if (userConfig.theme == null) {\n                        throw new Error(\"Invalid theme \" + userConfig.theme + \". Did you register it?\");\n                    }\n                }\n                var themeConfig = (0, _extend2.default)(true, {}, userConfig.theme.DEFAULTS);\n                [\n                    themeConfig,\n                    userConfig\n                ].forEach(function(config) {\n                    config.modules = config.modules || {};\n                    Object.keys(config.modules).forEach(function(module1) {\n                        if (config.modules[module1] === true) {\n                            config.modules[module1] = {};\n                        }\n                    });\n                });\n                var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));\n                var moduleConfig = moduleNames.reduce(function(config, name) {\n                    var moduleClass = Quill.import(\"modules/\" + name);\n                    if (moduleClass == null) {\n                        debug.error(\"Cannot load \" + name + \" module. Are you sure you registered it?\");\n                    } else {\n                        config[name] = moduleClass.DEFAULTS || {};\n                    }\n                    return config;\n                }, {});\n                // Special case toolbar shorthand\n                if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {\n                    userConfig.modules.toolbar = {\n                        container: userConfig.modules.toolbar\n                    };\n                }\n                userConfig = (0, _extend2.default)(true, {}, Quill.DEFAULTS, {\n                    modules: moduleConfig\n                }, themeConfig, userConfig);\n                [\n                    \"bounds\",\n                    \"container\",\n                    \"scrollingContainer\"\n                ].forEach(function(key) {\n                    if (typeof userConfig[key] === \"string\") {\n                        userConfig[key] = document.querySelector(userConfig[key]);\n                    }\n                });\n                userConfig.modules = Object.keys(userConfig.modules).reduce(function(config, name) {\n                    if (userConfig.modules[name]) {\n                        config[name] = userConfig.modules[name];\n                    }\n                    return config;\n                }, {});\n                return userConfig;\n            }\n            // Handle selection preservation and TEXT_CHANGE emission\n            // common to modification APIs\n            function modify(modifier, source, index, shift) {\n                if (this.options.strict && !this.isEnabled() && source === _emitter4.default.sources.USER) {\n                    return new _quillDelta2.default();\n                }\n                var range = index == null ? null : this.getSelection();\n                var oldDelta = this.editor.delta;\n                var change = modifier();\n                if (range != null) {\n                    if (index === true) index = range.index;\n                    if (shift == null) {\n                        range = shiftRange(range, change, source);\n                    } else if (shift !== 0) {\n                        range = shiftRange(range, index, shift, source);\n                    }\n                    this.setSelection(range, _emitter4.default.sources.SILENT);\n                }\n                if (change.length() > 0) {\n                    var _emitter;\n                    var args = [\n                        _emitter4.default.events.TEXT_CHANGE,\n                        change,\n                        oldDelta,\n                        source\n                    ];\n                    (_emitter = this.emitter).emit.apply(_emitter, [\n                        _emitter4.default.events.EDITOR_CHANGE\n                    ].concat(args));\n                    if (source !== _emitter4.default.sources.SILENT) {\n                        var _emitter2;\n                        (_emitter2 = this.emitter).emit.apply(_emitter2, args);\n                    }\n                }\n                return change;\n            }\n            function overload(index, length, name, value, source) {\n                var formats = {};\n                if (typeof index.index === \"number\" && typeof index.length === \"number\") {\n                    // Allow for throwaway end (used by insertText/insertEmbed)\n                    if (typeof length !== \"number\") {\n                        source = value, value = name, name = length, length = index.length, index = index.index;\n                    } else {\n                        length = index.length, index = index.index;\n                    }\n                } else if (typeof length !== \"number\") {\n                    source = value, value = name, name = length, length = 0;\n                }\n                // Handle format being object, two format name/value strings or excluded\n                if ((typeof name === \"undefined\" ? \"undefined\" : _typeof(name)) === \"object\") {\n                    formats = name;\n                    source = value;\n                } else if (typeof name === \"string\") {\n                    if (value != null) {\n                        formats[name] = value;\n                    } else {\n                        source = name;\n                    }\n                }\n                // Handle optional source\n                source = source || _emitter4.default.sources.API;\n                return [\n                    index,\n                    length,\n                    formats,\n                    source\n                ];\n            }\n            function shiftRange(range, index, length, source) {\n                if (range == null) return null;\n                var start = void 0, end = void 0;\n                if (index instanceof _quillDelta2.default) {\n                    var _map = [\n                        range.index,\n                        range.index + range.length\n                    ].map(function(pos) {\n                        return index.transformPosition(pos, source !== _emitter4.default.sources.USER);\n                    });\n                    var _map2 = _slicedToArray(_map, 2);\n                    start = _map2[0];\n                    end = _map2[1];\n                } else {\n                    var _map3 = [\n                        range.index,\n                        range.index + range.length\n                    ].map(function(pos) {\n                        if (pos < index || pos === index && source === _emitter4.default.sources.USER) return pos;\n                        if (length >= 0) {\n                            return pos + length;\n                        } else {\n                            return Math.max(index, pos + length);\n                        }\n                    });\n                    var _map4 = _slicedToArray(_map3, 2);\n                    start = _map4[0];\n                    end = _map4[1];\n                }\n                return new _selection.Range(start, end - start);\n            }\n            exports1.expandConfig = expandConfig;\n            exports1.overload = overload;\n            exports1.default = Quill;\n        /***/ },\n        /* 6 */ /***/ function(module1, exports1, __nested_webpack_require_88453__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _text = __nested_webpack_require_88453__(7);\n            var _text2 = _interopRequireDefault(_text);\n            var _parchment = __nested_webpack_require_88453__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Inline = function(_Parchment$Inline) {\n                _inherits(Inline, _Parchment$Inline);\n                function Inline() {\n                    _classCallCheck(this, Inline);\n                    return _possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));\n                }\n                _createClass(Inline, [\n                    {\n                        key: \"formatAt\",\n                        value: function formatAt(index, length, name, value) {\n                            if (Inline.compare(this.statics.blotName, name) < 0 && _parchment2.default.query(name, _parchment2.default.Scope.BLOT)) {\n                                var blot = this.isolate(index, length);\n                                if (value) {\n                                    blot.wrap(name, value);\n                                }\n                            } else {\n                                _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), \"formatAt\", this).call(this, index, length, name, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"optimize\",\n                        value: function optimize(context) {\n                            _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), \"optimize\", this).call(this, context);\n                            if (this.parent instanceof Inline && Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {\n                                var parent = this.parent.isolate(this.offset(), this.length());\n                                this.moveChildren(parent);\n                                parent.wrap(this);\n                            }\n                        }\n                    }\n                ], [\n                    {\n                        key: \"compare\",\n                        value: function compare(self1, other) {\n                            var selfIndex = Inline.order.indexOf(self1);\n                            var otherIndex = Inline.order.indexOf(other);\n                            if (selfIndex >= 0 || otherIndex >= 0) {\n                                return selfIndex - otherIndex;\n                            } else if (self1 === other) {\n                                return 0;\n                            } else if (self1 < other) {\n                                return -1;\n                            } else {\n                                return 1;\n                            }\n                        }\n                    }\n                ]);\n                return Inline;\n            }(_parchment2.default.Inline);\n            Inline.allowedChildren = [\n                Inline,\n                _parchment2.default.Embed,\n                _text2.default\n            ];\n            // Lower index means deeper in the DOM tree, since not found (-1) is for embeds\n            Inline.order = [\n                \"cursor\",\n                \"inline\",\n                \"underline\",\n                \"strike\",\n                \"italic\",\n                \"bold\",\n                \"script\",\n                \"link\",\n                \"code\" // Must be higher\n            ];\n            exports1.default = Inline;\n        /***/ },\n        /* 7 */ /***/ function(module1, exports1, __nested_webpack_require_95438__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _parchment = __nested_webpack_require_95438__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var TextBlot = function(_Parchment$Text) {\n                _inherits(TextBlot, _Parchment$Text);\n                function TextBlot() {\n                    _classCallCheck(this, TextBlot);\n                    return _possibleConstructorReturn(this, (TextBlot.__proto__ || Object.getPrototypeOf(TextBlot)).apply(this, arguments));\n                }\n                return TextBlot;\n            }(_parchment2.default.Text);\n            exports1.default = TextBlot;\n        /***/ },\n        /* 8 */ /***/ function(module1, exports1, __nested_webpack_require_97744__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _eventemitter = __nested_webpack_require_97744__(54);\n            var _eventemitter2 = _interopRequireDefault(_eventemitter);\n            var _logger = __nested_webpack_require_97744__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var debug = (0, _logger2.default)(\"quill:events\");\n            var EVENTS = [\n                \"selectionchange\",\n                \"mousedown\",\n                \"mouseup\",\n                \"click\"\n            ];\n            EVENTS.forEach(function(eventName) {\n                document.addEventListener(eventName, function() {\n                    for(var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    [].slice.call(document.querySelectorAll(\".ql-container\")).forEach(function(node) {\n                        // TODO use WeakMap\n                        if (node.__quill && node.__quill.emitter) {\n                            var _node$__quill$emitter;\n                            (_node$__quill$emitter = node.__quill.emitter).handleDOM.apply(_node$__quill$emitter, args);\n                        }\n                    });\n                });\n            });\n            var Emitter = function(_EventEmitter) {\n                _inherits(Emitter, _EventEmitter);\n                function Emitter() {\n                    _classCallCheck(this, Emitter);\n                    var _this = _possibleConstructorReturn(this, (Emitter.__proto__ || Object.getPrototypeOf(Emitter)).call(this));\n                    _this.listeners = {};\n                    _this.on(\"error\", debug.error);\n                    return _this;\n                }\n                _createClass(Emitter, [\n                    {\n                        key: \"emit\",\n                        value: function emit() {\n                            debug.log.apply(debug, arguments);\n                            _get(Emitter.prototype.__proto__ || Object.getPrototypeOf(Emitter.prototype), \"emit\", this).apply(this, arguments);\n                        }\n                    },\n                    {\n                        key: \"handleDOM\",\n                        value: function handleDOM(event) {\n                            for(var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                                args[_key2 - 1] = arguments[_key2];\n                            }\n                            (this.listeners[event.type] || []).forEach(function(_ref) {\n                                var node = _ref.node, handler = _ref.handler;\n                                if (event.target === node || node.contains(event.target)) {\n                                    handler.apply(undefined, [\n                                        event\n                                    ].concat(args));\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"listenDOM\",\n                        value: function listenDOM(eventName, node, handler) {\n                            if (!this.listeners[eventName]) {\n                                this.listeners[eventName] = [];\n                            }\n                            this.listeners[eventName].push({\n                                node: node,\n                                handler: handler\n                            });\n                        }\n                    }\n                ]);\n                return Emitter;\n            }(_eventemitter2.default);\n            Emitter.events = {\n                EDITOR_CHANGE: \"editor-change\",\n                SCROLL_BEFORE_UPDATE: \"scroll-before-update\",\n                SCROLL_OPTIMIZE: \"scroll-optimize\",\n                SCROLL_UPDATE: \"scroll-update\",\n                SELECTION_CHANGE: \"selection-change\",\n                TEXT_CHANGE: \"text-change\"\n            };\n            Emitter.sources = {\n                API: \"api\",\n                SILENT: \"silent\",\n                USER: \"user\"\n            };\n            exports1.default = Emitter;\n        /***/ },\n        /* 9 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var Module = function Module(quill) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                _classCallCheck(this, Module);\n                this.quill = quill;\n                this.options = options;\n            };\n            Module.DEFAULTS = {};\n            exports1.default = Module;\n        /***/ },\n        /* 10 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var levels = [\n                \"error\",\n                \"warn\",\n                \"log\",\n                \"info\"\n            ];\n            var level = \"warn\";\n            function debug(method) {\n                if (levels.indexOf(method) <= levels.indexOf(level)) {\n                    var _console;\n                    for(var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    (_console = console)[method].apply(_console, args); // eslint-disable-line no-console\n                }\n            }\n            function namespace(ns) {\n                return levels.reduce(function(logger, method) {\n                    logger[method] = debug.bind(console, method, ns);\n                    return logger;\n                }, {});\n            }\n            debug.level = namespace.level = function(newLevel) {\n                level = newLevel;\n            };\n            exports1.default = namespace;\n        /***/ },\n        /* 11 */ /***/ function(module1, exports1, __nested_webpack_require_107434__) {\n            var pSlice = Array.prototype.slice;\n            var objectKeys = __nested_webpack_require_107434__(52);\n            var isArguments = __nested_webpack_require_107434__(53);\n            var deepEqual = module1.exports = function(actual, expected, opts) {\n                if (!opts) opts = {};\n                // 7.1. All identical values are equivalent, as determined by ===.\n                if (actual === expected) {\n                    return true;\n                } else if (actual instanceof Date && expected instanceof Date) {\n                    return actual.getTime() === expected.getTime();\n                // 7.3. Other pairs that do not both pass typeof value == 'object',\n                // equivalence is determined by ==.\n                } else if (!actual || !expected || typeof actual != \"object\" && typeof expected != \"object\") {\n                    return opts.strict ? actual === expected : actual == expected;\n                // 7.4. For all other Object pairs, including Array objects, equivalence is\n                // determined by having the same number of owned properties (as verified\n                // with Object.prototype.hasOwnProperty.call), the same set of keys\n                // (although not necessarily the same order), equivalent values for every\n                // corresponding key, and an identical 'prototype' property. Note: this\n                // accounts for both named and indexed properties on Arrays.\n                } else {\n                    return objEquiv(actual, expected, opts);\n                }\n            };\n            function isUndefinedOrNull(value) {\n                return value === null || value === undefined;\n            }\n            function isBuffer(x) {\n                if (!x || typeof x !== \"object\" || typeof x.length !== \"number\") return false;\n                if (typeof x.copy !== \"function\" || typeof x.slice !== \"function\") {\n                    return false;\n                }\n                if (x.length > 0 && typeof x[0] !== \"number\") return false;\n                return true;\n            }\n            function objEquiv(a, b, opts) {\n                var i, key;\n                if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;\n                // an identical 'prototype' property.\n                if (a.prototype !== b.prototype) return false;\n                //~~~I've managed to break Object.keys through screwy arguments passing.\n                //   Converting to array solves the problem.\n                if (isArguments(a)) {\n                    if (!isArguments(b)) {\n                        return false;\n                    }\n                    a = pSlice.call(a);\n                    b = pSlice.call(b);\n                    return deepEqual(a, b, opts);\n                }\n                if (isBuffer(a)) {\n                    if (!isBuffer(b)) {\n                        return false;\n                    }\n                    if (a.length !== b.length) return false;\n                    for(i = 0; i < a.length; i++){\n                        if (a[i] !== b[i]) return false;\n                    }\n                    return true;\n                }\n                try {\n                    var ka = objectKeys(a), kb = objectKeys(b);\n                } catch (e) {\n                    return false;\n                }\n                // having the same number of owned properties (keys incorporates\n                // hasOwnProperty)\n                if (ka.length != kb.length) return false;\n                //the same set of keys (although not necessarily the same order),\n                ka.sort();\n                kb.sort();\n                //~~~cheap key test\n                for(i = ka.length - 1; i >= 0; i--){\n                    if (ka[i] != kb[i]) return false;\n                }\n                //equivalent values for every corresponding key, and\n                //~~~possibly expensive deep test\n                for(i = ka.length - 1; i >= 0; i--){\n                    key = ka[i];\n                    if (!deepEqual(a[key], b[key], opts)) return false;\n                }\n                return typeof a === typeof b;\n            }\n        /***/ },\n        /* 12 */ /***/ function(module1, exports1, __nested_webpack_require_111667__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var Registry = __nested_webpack_require_111667__(1);\n            var Attributor = /** @class */ function() {\n                function Attributor(attrName, keyName, options) {\n                    if (options === void 0) {\n                        options = {};\n                    }\n                    this.attrName = attrName;\n                    this.keyName = keyName;\n                    var attributeBit = Registry.Scope.TYPE & Registry.Scope.ATTRIBUTE;\n                    if (options.scope != null) {\n                        // Ignore type bits, force attribute bit\n                        this.scope = options.scope & Registry.Scope.LEVEL | attributeBit;\n                    } else {\n                        this.scope = Registry.Scope.ATTRIBUTE;\n                    }\n                    if (options.whitelist != null) this.whitelist = options.whitelist;\n                }\n                Attributor.keys = function(node) {\n                    return [].map.call(node.attributes, function(item) {\n                        return item.name;\n                    });\n                };\n                Attributor.prototype.add = function(node, value) {\n                    if (!this.canAdd(node, value)) return false;\n                    node.setAttribute(this.keyName, value);\n                    return true;\n                };\n                Attributor.prototype.canAdd = function(node, value) {\n                    var match = Registry.query(node, Registry.Scope.BLOT & (this.scope | Registry.Scope.TYPE));\n                    if (match == null) return false;\n                    if (this.whitelist == null) return true;\n                    if (typeof value === \"string\") {\n                        return this.whitelist.indexOf(value.replace(/[\"']/g, \"\")) > -1;\n                    } else {\n                        return this.whitelist.indexOf(value) > -1;\n                    }\n                };\n                Attributor.prototype.remove = function(node) {\n                    node.removeAttribute(this.keyName);\n                };\n                Attributor.prototype.value = function(node) {\n                    var value = node.getAttribute(this.keyName);\n                    if (this.canAdd(node, value) && value) {\n                        return value;\n                    }\n                    return \"\";\n                };\n                return Attributor;\n            }();\n            exports1.default = Attributor;\n        /***/ },\n        /* 13 */ /***/ function(module1, exports1, __nested_webpack_require_114325__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.Code = undefined;\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _quillDelta = __nested_webpack_require_114325__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _parchment = __nested_webpack_require_114325__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _block = __nested_webpack_require_114325__(4);\n            var _block2 = _interopRequireDefault(_block);\n            var _inline = __nested_webpack_require_114325__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            var _text = __nested_webpack_require_114325__(7);\n            var _text2 = _interopRequireDefault(_text);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Code = function(_Inline) {\n                _inherits(Code, _Inline);\n                function Code() {\n                    _classCallCheck(this, Code);\n                    return _possibleConstructorReturn(this, (Code.__proto__ || Object.getPrototypeOf(Code)).apply(this, arguments));\n                }\n                return Code;\n            }(_inline2.default);\n            Code.blotName = \"code\";\n            Code.tagName = \"CODE\";\n            var CodeBlock = function(_Block) {\n                _inherits(CodeBlock, _Block);\n                function CodeBlock() {\n                    _classCallCheck(this, CodeBlock);\n                    return _possibleConstructorReturn(this, (CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock)).apply(this, arguments));\n                }\n                _createClass(CodeBlock, [\n                    {\n                        key: \"delta\",\n                        value: function delta() {\n                            var _this3 = this;\n                            var text = this.domNode.textContent;\n                            if (text.endsWith(\"\\n\")) {\n                                // Should always be true\n                                text = text.slice(0, -1);\n                            }\n                            return text.split(\"\\n\").reduce(function(delta, frag) {\n                                return delta.insert(frag).insert(\"\\n\", _this3.formats());\n                            }, new _quillDelta2.default());\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (name === this.statics.blotName && value) return;\n                            var _descendant = this.descendant(_text2.default, this.length() - 1), _descendant2 = _slicedToArray(_descendant, 1), text = _descendant2[0];\n                            if (text != null) {\n                                text.deleteAt(text.length() - 1, 1);\n                            }\n                            _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), \"format\", this).call(this, name, value);\n                        }\n                    },\n                    {\n                        key: \"formatAt\",\n                        value: function formatAt(index, length, name, value) {\n                            if (length === 0) return;\n                            if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK) == null || name === this.statics.blotName && value === this.statics.formats(this.domNode)) {\n                                return;\n                            }\n                            var nextNewline = this.newlineIndex(index);\n                            if (nextNewline < 0 || nextNewline >= index + length) return;\n                            var prevNewline = this.newlineIndex(index, true) + 1;\n                            var isolateLength = nextNewline - prevNewline + 1;\n                            var blot = this.isolate(prevNewline, isolateLength);\n                            var next = blot.next;\n                            blot.format(name, value);\n                            if (next instanceof CodeBlock) {\n                                next.formatAt(0, index - prevNewline + length - isolateLength, name, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"insertAt\",\n                        value: function insertAt(index, value, def) {\n                            if (def != null) return;\n                            var _descendant3 = this.descendant(_text2.default, index), _descendant4 = _slicedToArray(_descendant3, 2), text = _descendant4[0], offset = _descendant4[1];\n                            text.insertAt(offset, value);\n                        }\n                    },\n                    {\n                        key: \"length\",\n                        value: function length() {\n                            var length = this.domNode.textContent.length;\n                            if (!this.domNode.textContent.endsWith(\"\\n\")) {\n                                return length + 1;\n                            }\n                            return length;\n                        }\n                    },\n                    {\n                        key: \"newlineIndex\",\n                        value: function newlineIndex(searchIndex) {\n                            var reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                            if (!reverse) {\n                                var offset = this.domNode.textContent.slice(searchIndex).indexOf(\"\\n\");\n                                return offset > -1 ? searchIndex + offset : -1;\n                            } else {\n                                return this.domNode.textContent.slice(0, searchIndex).lastIndexOf(\"\\n\");\n                            }\n                        }\n                    },\n                    {\n                        key: \"optimize\",\n                        value: function optimize(context) {\n                            if (!this.domNode.textContent.endsWith(\"\\n\")) {\n                                this.appendChild(_parchment2.default.create(\"text\", \"\\n\"));\n                            }\n                            _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), \"optimize\", this).call(this, context);\n                            var next = this.next;\n                            if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {\n                                next.optimize(context);\n                                next.moveChildren(this);\n                                next.remove();\n                            }\n                        }\n                    },\n                    {\n                        key: \"replace\",\n                        value: function replace(target) {\n                            _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), \"replace\", this).call(this, target);\n                            [].slice.call(this.domNode.querySelectorAll(\"*\")).forEach(function(node) {\n                                var blot = _parchment2.default.find(node);\n                                if (blot == null) {\n                                    node.parentNode.removeChild(node);\n                                } else if (blot instanceof _parchment2.default.Embed) {\n                                    blot.remove();\n                                } else {\n                                    blot.unwrap();\n                                }\n                            });\n                        }\n                    }\n                ], [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var domNode = _get(CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock), \"create\", this).call(this, value);\n                            domNode.setAttribute(\"spellcheck\", false);\n                            return domNode;\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats() {\n                            return true;\n                        }\n                    }\n                ]);\n                return CodeBlock;\n            }(_block2.default);\n            CodeBlock.blotName = \"code-block\";\n            CodeBlock.tagName = \"PRE\";\n            CodeBlock.TAB = \"  \";\n            exports1.Code = Code;\n            exports1.default = CodeBlock;\n        /***/ },\n        /* 14 */ /***/ function(module1, exports1, __nested_webpack_require_127639__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _quillDelta = __nested_webpack_require_127639__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _op = __nested_webpack_require_127639__(20);\n            var _op2 = _interopRequireDefault(_op);\n            var _parchment = __nested_webpack_require_127639__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _code = __nested_webpack_require_127639__(13);\n            var _code2 = _interopRequireDefault(_code);\n            var _cursor = __nested_webpack_require_127639__(24);\n            var _cursor2 = _interopRequireDefault(_cursor);\n            var _block = __nested_webpack_require_127639__(4);\n            var _block2 = _interopRequireDefault(_block);\n            var _break = __nested_webpack_require_127639__(16);\n            var _break2 = _interopRequireDefault(_break);\n            var _clone = __nested_webpack_require_127639__(21);\n            var _clone2 = _interopRequireDefault(_clone);\n            var _deepEqual = __nested_webpack_require_127639__(11);\n            var _deepEqual2 = _interopRequireDefault(_deepEqual);\n            var _extend = __nested_webpack_require_127639__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var ASCII = /^[ -~]*$/;\n            var Editor = function() {\n                function Editor(scroll) {\n                    _classCallCheck(this, Editor);\n                    this.scroll = scroll;\n                    this.delta = this.getDelta();\n                }\n                _createClass(Editor, [\n                    {\n                        key: \"applyDelta\",\n                        value: function applyDelta(delta) {\n                            var _this = this;\n                            var consumeNextNewline = false;\n                            this.scroll.update();\n                            var scrollLength = this.scroll.length();\n                            this.scroll.batchStart();\n                            delta = normalizeDelta(delta);\n                            delta.reduce(function(index, op) {\n                                var length = op.retain || op.delete || op.insert.length || 1;\n                                var attributes = op.attributes || {};\n                                if (op.insert != null) {\n                                    if (typeof op.insert === \"string\") {\n                                        var text = op.insert;\n                                        if (text.endsWith(\"\\n\") && consumeNextNewline) {\n                                            consumeNextNewline = false;\n                                            text = text.slice(0, -1);\n                                        }\n                                        if (index >= scrollLength && !text.endsWith(\"\\n\")) {\n                                            consumeNextNewline = true;\n                                        }\n                                        _this.scroll.insertAt(index, text);\n                                        var _scroll$line = _this.scroll.line(index), _scroll$line2 = _slicedToArray(_scroll$line, 2), line = _scroll$line2[0], offset = _scroll$line2[1];\n                                        var formats = (0, _extend2.default)({}, (0, _block.bubbleFormats)(line));\n                                        if (line instanceof _block2.default) {\n                                            var _line$descendant = line.descendant(_parchment2.default.Leaf, offset), _line$descendant2 = _slicedToArray(_line$descendant, 1), leaf = _line$descendant2[0];\n                                            formats = (0, _extend2.default)(formats, (0, _block.bubbleFormats)(leaf));\n                                        }\n                                        attributes = _op2.default.attributes.diff(formats, attributes) || {};\n                                    } else if (_typeof(op.insert) === \"object\") {\n                                        var key = Object.keys(op.insert)[0]; // There should only be one key\n                                        if (key == null) return index;\n                                        _this.scroll.insertAt(index, key, op.insert[key]);\n                                    }\n                                    scrollLength += length;\n                                }\n                                Object.keys(attributes).forEach(function(name) {\n                                    _this.scroll.formatAt(index, length, name, attributes[name]);\n                                });\n                                return index + length;\n                            }, 0);\n                            delta.reduce(function(index, op) {\n                                if (typeof op.delete === \"number\") {\n                                    _this.scroll.deleteAt(index, op.delete);\n                                    return index;\n                                }\n                                return index + (op.retain || op.insert.length || 1);\n                            }, 0);\n                            this.scroll.batchEnd();\n                            return this.update(delta);\n                        }\n                    },\n                    {\n                        key: \"deleteText\",\n                        value: function deleteText(index, length) {\n                            this.scroll.deleteAt(index, length);\n                            return this.update(new _quillDelta2.default().retain(index).delete(length));\n                        }\n                    },\n                    {\n                        key: \"formatLine\",\n                        value: function formatLine(index, length) {\n                            var _this2 = this;\n                            var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            this.scroll.update();\n                            Object.keys(formats).forEach(function(format) {\n                                if (_this2.scroll.whitelist != null && !_this2.scroll.whitelist[format]) return;\n                                var lines = _this2.scroll.lines(index, Math.max(length, 1));\n                                var lengthRemaining = length;\n                                lines.forEach(function(line) {\n                                    var lineLength = line.length();\n                                    if (!(line instanceof _code2.default)) {\n                                        line.format(format, formats[format]);\n                                    } else {\n                                        var codeIndex = index - line.offset(_this2.scroll);\n                                        var codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;\n                                        line.formatAt(codeIndex, codeLength, format, formats[format]);\n                                    }\n                                    lengthRemaining -= lineLength;\n                                });\n                            });\n                            this.scroll.optimize();\n                            return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));\n                        }\n                    },\n                    {\n                        key: \"formatText\",\n                        value: function formatText(index, length) {\n                            var _this3 = this;\n                            var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            Object.keys(formats).forEach(function(format) {\n                                _this3.scroll.formatAt(index, length, format, formats[format]);\n                            });\n                            return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));\n                        }\n                    },\n                    {\n                        key: \"getContents\",\n                        value: function getContents(index, length) {\n                            return this.delta.slice(index, index + length);\n                        }\n                    },\n                    {\n                        key: \"getDelta\",\n                        value: function getDelta() {\n                            return this.scroll.lines().reduce(function(delta, line) {\n                                return delta.concat(line.delta());\n                            }, new _quillDelta2.default());\n                        }\n                    },\n                    {\n                        key: \"getFormat\",\n                        value: function getFormat(index) {\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                            var lines = [], leaves = [];\n                            if (length === 0) {\n                                this.scroll.path(index).forEach(function(path) {\n                                    var _path = _slicedToArray(path, 1), blot = _path[0];\n                                    if (blot instanceof _block2.default) {\n                                        lines.push(blot);\n                                    } else if (blot instanceof _parchment2.default.Leaf) {\n                                        leaves.push(blot);\n                                    }\n                                });\n                            } else {\n                                lines = this.scroll.lines(index, length);\n                                leaves = this.scroll.descendants(_parchment2.default.Leaf, index, length);\n                            }\n                            var formatsArr = [\n                                lines,\n                                leaves\n                            ].map(function(blots) {\n                                if (blots.length === 0) return {};\n                                var formats = (0, _block.bubbleFormats)(blots.shift());\n                                while(Object.keys(formats).length > 0){\n                                    var blot = blots.shift();\n                                    if (blot == null) return formats;\n                                    formats = combineFormats((0, _block.bubbleFormats)(blot), formats);\n                                }\n                                return formats;\n                            });\n                            return _extend2.default.apply(_extend2.default, formatsArr);\n                        }\n                    },\n                    {\n                        key: \"getText\",\n                        value: function getText(index, length) {\n                            return this.getContents(index, length).filter(function(op) {\n                                return typeof op.insert === \"string\";\n                            }).map(function(op) {\n                                return op.insert;\n                            }).join(\"\");\n                        }\n                    },\n                    {\n                        key: \"insertEmbed\",\n                        value: function insertEmbed(index, embed, value) {\n                            this.scroll.insertAt(index, embed, value);\n                            return this.update(new _quillDelta2.default().retain(index).insert(_defineProperty({}, embed, value)));\n                        }\n                    },\n                    {\n                        key: \"insertText\",\n                        value: function insertText(index, text) {\n                            var _this4 = this;\n                            var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            text = text.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n                            this.scroll.insertAt(index, text);\n                            Object.keys(formats).forEach(function(format) {\n                                _this4.scroll.formatAt(index, text.length, format, formats[format]);\n                            });\n                            return this.update(new _quillDelta2.default().retain(index).insert(text, (0, _clone2.default)(formats)));\n                        }\n                    },\n                    {\n                        key: \"isBlank\",\n                        value: function isBlank() {\n                            if (this.scroll.children.length == 0) return true;\n                            if (this.scroll.children.length > 1) return false;\n                            var block = this.scroll.children.head;\n                            if (block.statics.blotName !== _block2.default.blotName) return false;\n                            if (block.children.length > 1) return false;\n                            return block.children.head instanceof _break2.default;\n                        }\n                    },\n                    {\n                        key: \"removeFormat\",\n                        value: function removeFormat(index, length) {\n                            var text = this.getText(index, length);\n                            var _scroll$line3 = this.scroll.line(index + length), _scroll$line4 = _slicedToArray(_scroll$line3, 2), line = _scroll$line4[0], offset = _scroll$line4[1];\n                            var suffixLength = 0, suffix = new _quillDelta2.default();\n                            if (line != null) {\n                                if (!(line instanceof _code2.default)) {\n                                    suffixLength = line.length() - offset;\n                                } else {\n                                    suffixLength = line.newlineIndex(offset) - offset + 1;\n                                }\n                                suffix = line.delta().slice(offset, offset + suffixLength - 1).insert(\"\\n\");\n                            }\n                            var contents = this.getContents(index, length + suffixLength);\n                            var diff = contents.diff(new _quillDelta2.default().insert(text).concat(suffix));\n                            var delta = new _quillDelta2.default().retain(index).concat(diff);\n                            return this.applyDelta(delta);\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update(change) {\n                            var mutations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n                            var cursorIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n                            var oldDelta = this.delta;\n                            if (mutations.length === 1 && mutations[0].type === \"characterData\" && mutations[0].target.data.match(ASCII) && _parchment2.default.find(mutations[0].target)) {\n                                // Optimization for character changes\n                                var textBlot = _parchment2.default.find(mutations[0].target);\n                                var formats = (0, _block.bubbleFormats)(textBlot);\n                                var index = textBlot.offset(this.scroll);\n                                var oldValue = mutations[0].oldValue.replace(_cursor2.default.CONTENTS, \"\");\n                                var oldText = new _quillDelta2.default().insert(oldValue);\n                                var newText = new _quillDelta2.default().insert(textBlot.value());\n                                var diffDelta = new _quillDelta2.default().retain(index).concat(oldText.diff(newText, cursorIndex));\n                                change = diffDelta.reduce(function(delta, op) {\n                                    if (op.insert) {\n                                        return delta.insert(op.insert, formats);\n                                    } else {\n                                        return delta.push(op);\n                                    }\n                                }, new _quillDelta2.default());\n                                this.delta = oldDelta.compose(change);\n                            } else {\n                                this.delta = this.getDelta();\n                                if (!change || !(0, _deepEqual2.default)(oldDelta.compose(change), this.delta)) {\n                                    change = oldDelta.diff(this.delta, cursorIndex);\n                                }\n                            }\n                            return change;\n                        }\n                    }\n                ]);\n                return Editor;\n            }();\n            function combineFormats(formats, combined) {\n                return Object.keys(combined).reduce(function(merged, name) {\n                    if (formats[name] == null) return merged;\n                    if (combined[name] === formats[name]) {\n                        merged[name] = combined[name];\n                    } else if (Array.isArray(combined[name])) {\n                        if (combined[name].indexOf(formats[name]) < 0) {\n                            merged[name] = combined[name].concat([\n                                formats[name]\n                            ]);\n                        }\n                    } else {\n                        merged[name] = [\n                            combined[name],\n                            formats[name]\n                        ];\n                    }\n                    return merged;\n                }, {});\n            }\n            function normalizeDelta(delta) {\n                return delta.reduce(function(delta, op) {\n                    if (op.insert === 1) {\n                        var attributes = (0, _clone2.default)(op.attributes);\n                        delete attributes[\"image\"];\n                        return delta.insert({\n                            image: op.attributes.image\n                        }, attributes);\n                    }\n                    if (op.attributes != null && (op.attributes.list === true || op.attributes.bullet === true)) {\n                        op = (0, _clone2.default)(op);\n                        if (op.attributes.list) {\n                            op.attributes.list = \"ordered\";\n                        } else {\n                            op.attributes.list = \"bullet\";\n                            delete op.attributes.bullet;\n                        }\n                    }\n                    if (typeof op.insert === \"string\") {\n                        var text = op.insert.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n                        return delta.insert(text, op.attributes);\n                    }\n                    return delta.push(op);\n                }, new _quillDelta2.default());\n            }\n            exports1.default = Editor;\n        /***/ },\n        /* 15 */ /***/ function(module1, exports1, __nested_webpack_require_150070__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.Range = undefined;\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _parchment = __nested_webpack_require_150070__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _clone = __nested_webpack_require_150070__(21);\n            var _clone2 = _interopRequireDefault(_clone);\n            var _deepEqual = __nested_webpack_require_150070__(11);\n            var _deepEqual2 = _interopRequireDefault(_deepEqual);\n            var _emitter3 = __nested_webpack_require_150070__(8);\n            var _emitter4 = _interopRequireDefault(_emitter3);\n            var _logger = __nested_webpack_require_150070__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _toConsumableArray(arr) {\n                if (Array.isArray(arr)) {\n                    for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++){\n                        arr2[i] = arr[i];\n                    }\n                    return arr2;\n                } else {\n                    return Array.from(arr);\n                }\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var debug = (0, _logger2.default)(\"quill:selection\");\n            var Range = function Range(index) {\n                var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                _classCallCheck(this, Range);\n                this.index = index;\n                this.length = length;\n            };\n            var Selection = function() {\n                function Selection(scroll, emitter) {\n                    var _this = this;\n                    _classCallCheck(this, Selection);\n                    this.emitter = emitter;\n                    this.scroll = scroll;\n                    this.composing = false;\n                    this.mouseDown = false;\n                    this.root = this.scroll.domNode;\n                    this.cursor = _parchment2.default.create(\"cursor\", this);\n                    // savedRange is last non-null range\n                    this.lastRange = this.savedRange = new Range(0, 0);\n                    this.handleComposition();\n                    this.handleDragging();\n                    this.emitter.listenDOM(\"selectionchange\", document, function() {\n                        if (!_this.mouseDown) {\n                            setTimeout(_this.update.bind(_this, _emitter4.default.sources.USER), 1);\n                        }\n                    });\n                    this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function(type, delta) {\n                        if (type === _emitter4.default.events.TEXT_CHANGE && delta.length() > 0) {\n                            _this.update(_emitter4.default.sources.SILENT);\n                        }\n                    });\n                    this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE, function() {\n                        if (!_this.hasFocus()) return;\n                        var native = _this.getNativeRange();\n                        if (native == null) return;\n                        if (native.start.node === _this.cursor.textNode) return; // cursor.restore() will handle\n                        // TODO unclear if this has negative side effects\n                        _this.emitter.once(_emitter4.default.events.SCROLL_UPDATE, function() {\n                            try {\n                                _this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);\n                            } catch (ignored) {}\n                        });\n                    });\n                    this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE, function(mutations, context) {\n                        if (context.range) {\n                            var _context$range = context.range, startNode = _context$range.startNode, startOffset = _context$range.startOffset, endNode = _context$range.endNode, endOffset = _context$range.endOffset;\n                            _this.setNativeRange(startNode, startOffset, endNode, endOffset);\n                        }\n                    });\n                    this.update(_emitter4.default.sources.SILENT);\n                }\n                _createClass(Selection, [\n                    {\n                        key: \"handleComposition\",\n                        value: function handleComposition() {\n                            var _this2 = this;\n                            this.root.addEventListener(\"compositionstart\", function() {\n                                _this2.composing = true;\n                            });\n                            this.root.addEventListener(\"compositionend\", function() {\n                                _this2.composing = false;\n                                if (_this2.cursor.parent) {\n                                    var range = _this2.cursor.restore();\n                                    if (!range) return;\n                                    setTimeout(function() {\n                                        _this2.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);\n                                    }, 1);\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"handleDragging\",\n                        value: function handleDragging() {\n                            var _this3 = this;\n                            this.emitter.listenDOM(\"mousedown\", document.body, function() {\n                                _this3.mouseDown = true;\n                            });\n                            this.emitter.listenDOM(\"mouseup\", document.body, function() {\n                                _this3.mouseDown = false;\n                                _this3.update(_emitter4.default.sources.USER);\n                            });\n                        }\n                    },\n                    {\n                        key: \"focus\",\n                        value: function focus() {\n                            if (this.hasFocus()) return;\n                            this.root.focus();\n                            this.setRange(this.savedRange);\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(_format, value) {\n                            if (this.scroll.whitelist != null && !this.scroll.whitelist[_format]) return;\n                            this.scroll.update();\n                            var nativeRange = this.getNativeRange();\n                            if (nativeRange == null || !nativeRange.native.collapsed || _parchment2.default.query(_format, _parchment2.default.Scope.BLOCK)) return;\n                            if (nativeRange.start.node !== this.cursor.textNode) {\n                                var blot = _parchment2.default.find(nativeRange.start.node, false);\n                                if (blot == null) return;\n                                // TODO Give blot ability to not split\n                                if (blot instanceof _parchment2.default.Leaf) {\n                                    var after = blot.split(nativeRange.start.offset);\n                                    blot.parent.insertBefore(this.cursor, after);\n                                } else {\n                                    blot.insertBefore(this.cursor, nativeRange.start.node); // Should never happen\n                                }\n                                this.cursor.attach();\n                            }\n                            this.cursor.format(_format, value);\n                            this.scroll.optimize();\n                            this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);\n                            this.update();\n                        }\n                    },\n                    {\n                        key: \"getBounds\",\n                        value: function getBounds(index) {\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                            var scrollLength = this.scroll.length();\n                            index = Math.min(index, scrollLength - 1);\n                            length = Math.min(index + length, scrollLength - 1) - index;\n                            var node = void 0, _scroll$leaf = this.scroll.leaf(index), _scroll$leaf2 = _slicedToArray(_scroll$leaf, 2), leaf = _scroll$leaf2[0], offset = _scroll$leaf2[1];\n                            if (leaf == null) return null;\n                            var _leaf$position = leaf.position(offset, true);\n                            var _leaf$position2 = _slicedToArray(_leaf$position, 2);\n                            node = _leaf$position2[0];\n                            offset = _leaf$position2[1];\n                            var range = document.createRange();\n                            if (length > 0) {\n                                range.setStart(node, offset);\n                                var _scroll$leaf3 = this.scroll.leaf(index + length);\n                                var _scroll$leaf4 = _slicedToArray(_scroll$leaf3, 2);\n                                leaf = _scroll$leaf4[0];\n                                offset = _scroll$leaf4[1];\n                                if (leaf == null) return null;\n                                var _leaf$position3 = leaf.position(offset, true);\n                                var _leaf$position4 = _slicedToArray(_leaf$position3, 2);\n                                node = _leaf$position4[0];\n                                offset = _leaf$position4[1];\n                                range.setEnd(node, offset);\n                                return range.getBoundingClientRect();\n                            } else {\n                                var side = \"left\";\n                                var rect = void 0;\n                                if (node instanceof Text) {\n                                    if (offset < node.data.length) {\n                                        range.setStart(node, offset);\n                                        range.setEnd(node, offset + 1);\n                                    } else {\n                                        range.setStart(node, offset - 1);\n                                        range.setEnd(node, offset);\n                                        side = \"right\";\n                                    }\n                                    rect = range.getBoundingClientRect();\n                                } else {\n                                    rect = leaf.domNode.getBoundingClientRect();\n                                    if (offset > 0) side = \"right\";\n                                }\n                                return {\n                                    bottom: rect.top + rect.height,\n                                    height: rect.height,\n                                    left: rect[side],\n                                    right: rect[side],\n                                    top: rect.top,\n                                    width: 0\n                                };\n                            }\n                        }\n                    },\n                    {\n                        key: \"getNativeRange\",\n                        value: function getNativeRange() {\n                            var selection = document.getSelection();\n                            if (selection == null || selection.rangeCount <= 0) return null;\n                            var nativeRange = selection.getRangeAt(0);\n                            if (nativeRange == null) return null;\n                            var range = this.normalizeNative(nativeRange);\n                            debug.info(\"getNativeRange\", range);\n                            return range;\n                        }\n                    },\n                    {\n                        key: \"getRange\",\n                        value: function getRange() {\n                            var normalized = this.getNativeRange();\n                            if (normalized == null) return [\n                                null,\n                                null\n                            ];\n                            var range = this.normalizedToRange(normalized);\n                            return [\n                                range,\n                                normalized\n                            ];\n                        }\n                    },\n                    {\n                        key: \"hasFocus\",\n                        value: function hasFocus() {\n                            return document.activeElement === this.root;\n                        }\n                    },\n                    {\n                        key: \"normalizedToRange\",\n                        value: function normalizedToRange(range) {\n                            var _this4 = this;\n                            var positions = [\n                                [\n                                    range.start.node,\n                                    range.start.offset\n                                ]\n                            ];\n                            if (!range.native.collapsed) {\n                                positions.push([\n                                    range.end.node,\n                                    range.end.offset\n                                ]);\n                            }\n                            var indexes = positions.map(function(position) {\n                                var _position = _slicedToArray(position, 2), node = _position[0], offset = _position[1];\n                                var blot = _parchment2.default.find(node, true);\n                                var index = blot.offset(_this4.scroll);\n                                if (offset === 0) {\n                                    return index;\n                                } else if (blot instanceof _parchment2.default.Container) {\n                                    return index + blot.length();\n                                } else {\n                                    return index + blot.index(node, offset);\n                                }\n                            });\n                            var end = Math.min(Math.max.apply(Math, _toConsumableArray(indexes)), this.scroll.length() - 1);\n                            var start = Math.min.apply(Math, [\n                                end\n                            ].concat(_toConsumableArray(indexes)));\n                            return new Range(start, end - start);\n                        }\n                    },\n                    {\n                        key: \"normalizeNative\",\n                        value: function normalizeNative(nativeRange) {\n                            if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {\n                                return null;\n                            }\n                            var range = {\n                                start: {\n                                    node: nativeRange.startContainer,\n                                    offset: nativeRange.startOffset\n                                },\n                                end: {\n                                    node: nativeRange.endContainer,\n                                    offset: nativeRange.endOffset\n                                },\n                                native: nativeRange\n                            };\n                            [\n                                range.start,\n                                range.end\n                            ].forEach(function(position) {\n                                var node = position.node, offset = position.offset;\n                                while(!(node instanceof Text) && node.childNodes.length > 0){\n                                    if (node.childNodes.length > offset) {\n                                        node = node.childNodes[offset];\n                                        offset = 0;\n                                    } else if (node.childNodes.length === offset) {\n                                        node = node.lastChild;\n                                        offset = node instanceof Text ? node.data.length : node.childNodes.length + 1;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                                position.node = node, position.offset = offset;\n                            });\n                            return range;\n                        }\n                    },\n                    {\n                        key: \"rangeToNative\",\n                        value: function rangeToNative(range) {\n                            var _this5 = this;\n                            var indexes = range.collapsed ? [\n                                range.index\n                            ] : [\n                                range.index,\n                                range.index + range.length\n                            ];\n                            var args = [];\n                            var scrollLength = this.scroll.length();\n                            indexes.forEach(function(index, i) {\n                                index = Math.min(scrollLength - 1, index);\n                                var node = void 0, _scroll$leaf5 = _this5.scroll.leaf(index), _scroll$leaf6 = _slicedToArray(_scroll$leaf5, 2), leaf = _scroll$leaf6[0], offset = _scroll$leaf6[1];\n                                var _leaf$position5 = leaf.position(offset, i !== 0);\n                                var _leaf$position6 = _slicedToArray(_leaf$position5, 2);\n                                node = _leaf$position6[0];\n                                offset = _leaf$position6[1];\n                                args.push(node, offset);\n                            });\n                            if (args.length < 2) {\n                                args = args.concat(args);\n                            }\n                            return args;\n                        }\n                    },\n                    {\n                        key: \"scrollIntoView\",\n                        value: function scrollIntoView(scrollingContainer) {\n                            var range = this.lastRange;\n                            if (range == null) return;\n                            var bounds = this.getBounds(range.index, range.length);\n                            if (bounds == null) return;\n                            var limit = this.scroll.length() - 1;\n                            var _scroll$line = this.scroll.line(Math.min(range.index, limit)), _scroll$line2 = _slicedToArray(_scroll$line, 1), first = _scroll$line2[0];\n                            var last = first;\n                            if (range.length > 0) {\n                                var _scroll$line3 = this.scroll.line(Math.min(range.index + range.length, limit));\n                                var _scroll$line4 = _slicedToArray(_scroll$line3, 1);\n                                last = _scroll$line4[0];\n                            }\n                            if (first == null || last == null) return;\n                            var scrollBounds = scrollingContainer.getBoundingClientRect();\n                            if (bounds.top < scrollBounds.top) {\n                                scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;\n                            } else if (bounds.bottom > scrollBounds.bottom) {\n                                scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;\n                            }\n                        }\n                    },\n                    {\n                        key: \"setNativeRange\",\n                        value: function setNativeRange(startNode, startOffset) {\n                            var endNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startNode;\n                            var endOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : startOffset;\n                            var force = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n                            debug.info(\"setNativeRange\", startNode, startOffset, endNode, endOffset);\n                            if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {\n                                return;\n                            }\n                            var selection = document.getSelection();\n                            if (selection == null) return;\n                            if (startNode != null) {\n                                if (!this.hasFocus()) this.root.focus();\n                                var native = (this.getNativeRange() || {}).native;\n                                if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {\n                                    if (startNode.tagName == \"BR\") {\n                                        startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);\n                                        startNode = startNode.parentNode;\n                                    }\n                                    if (endNode.tagName == \"BR\") {\n                                        endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);\n                                        endNode = endNode.parentNode;\n                                    }\n                                    var range = document.createRange();\n                                    range.setStart(startNode, startOffset);\n                                    range.setEnd(endNode, endOffset);\n                                    selection.removeAllRanges();\n                                    selection.addRange(range);\n                                }\n                            } else {\n                                selection.removeAllRanges();\n                                this.root.blur();\n                                document.body.focus(); // root.blur() not enough on IE11+Travis+SauceLabs (but not local VMs)\n                            }\n                        }\n                    },\n                    {\n                        key: \"setRange\",\n                        value: function setRange(range) {\n                            var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                            var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;\n                            if (typeof force === \"string\") {\n                                source = force;\n                                force = false;\n                            }\n                            debug.info(\"setRange\", range);\n                            if (range != null) {\n                                var args = this.rangeToNative(range);\n                                this.setNativeRange.apply(this, _toConsumableArray(args).concat([\n                                    force\n                                ]));\n                            } else {\n                                this.setNativeRange(null);\n                            }\n                            this.update(source);\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update() {\n                            var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;\n                            var oldRange = this.lastRange;\n                            var _getRange = this.getRange(), _getRange2 = _slicedToArray(_getRange, 2), lastRange = _getRange2[0], nativeRange = _getRange2[1];\n                            this.lastRange = lastRange;\n                            if (this.lastRange != null) {\n                                this.savedRange = this.lastRange;\n                            }\n                            if (!(0, _deepEqual2.default)(oldRange, this.lastRange)) {\n                                var _emitter;\n                                if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {\n                                    this.cursor.restore();\n                                }\n                                var args = [\n                                    _emitter4.default.events.SELECTION_CHANGE,\n                                    (0, _clone2.default)(this.lastRange),\n                                    (0, _clone2.default)(oldRange),\n                                    source\n                                ];\n                                (_emitter = this.emitter).emit.apply(_emitter, [\n                                    _emitter4.default.events.EDITOR_CHANGE\n                                ].concat(args));\n                                if (source !== _emitter4.default.sources.SILENT) {\n                                    var _emitter2;\n                                    (_emitter2 = this.emitter).emit.apply(_emitter2, args);\n                                }\n                            }\n                        }\n                    }\n                ]);\n                return Selection;\n            }();\n            function contains(parent, descendant) {\n                try {\n                    // Firefox inserts inaccessible nodes around video elements\n                    descendant.parentNode;\n                } catch (e) {\n                    return false;\n                }\n                // IE11 has bug with Text nodes\n                // https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect\n                if (descendant instanceof Text) {\n                    descendant = descendant.parentNode;\n                }\n                return parent.contains(descendant);\n            }\n            exports1.Range = Range;\n            exports1.default = Selection;\n        /***/ },\n        /* 16 */ /***/ function(module1, exports1, __nested_webpack_require_179363__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_179363__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Break = function(_Parchment$Embed) {\n                _inherits(Break, _Parchment$Embed);\n                function Break() {\n                    _classCallCheck(this, Break);\n                    return _possibleConstructorReturn(this, (Break.__proto__ || Object.getPrototypeOf(Break)).apply(this, arguments));\n                }\n                _createClass(Break, [\n                    {\n                        key: \"insertInto\",\n                        value: function insertInto(parent, ref) {\n                            if (parent.children.length === 0) {\n                                _get(Break.prototype.__proto__ || Object.getPrototypeOf(Break.prototype), \"insertInto\", this).call(this, parent, ref);\n                            } else {\n                                this.remove();\n                            }\n                        }\n                    },\n                    {\n                        key: \"length\",\n                        value: function length() {\n                            return 0;\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return \"\";\n                        }\n                    }\n                ], [\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return undefined;\n                        }\n                    }\n                ]);\n                return Break;\n            }(_parchment2.default.Embed);\n            Break.blotName = \"break\";\n            Break.tagName = \"BR\";\n            exports1.default = Break;\n        /***/ },\n        /* 17 */ /***/ function(module1, exports1, __nested_webpack_require_184642__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var linked_list_1 = __nested_webpack_require_184642__(44);\n            var shadow_1 = __nested_webpack_require_184642__(30);\n            var Registry = __nested_webpack_require_184642__(1);\n            var ContainerBlot = /** @class */ function(_super) {\n                __extends(ContainerBlot, _super);\n                function ContainerBlot(domNode) {\n                    var _this = _super.call(this, domNode) || this;\n                    _this.build();\n                    return _this;\n                }\n                ContainerBlot.prototype.appendChild = function(other) {\n                    this.insertBefore(other);\n                };\n                ContainerBlot.prototype.attach = function() {\n                    _super.prototype.attach.call(this);\n                    this.children.forEach(function(child) {\n                        child.attach();\n                    });\n                };\n                ContainerBlot.prototype.build = function() {\n                    var _this = this;\n                    this.children = new linked_list_1.default();\n                    // Need to be reversed for if DOM nodes already in order\n                    [].slice.call(this.domNode.childNodes).reverse().forEach(function(node) {\n                        try {\n                            var child = makeBlot(node);\n                            _this.insertBefore(child, _this.children.head || undefined);\n                        } catch (err) {\n                            if (err instanceof Registry.ParchmentError) return;\n                            else throw err;\n                        }\n                    });\n                };\n                ContainerBlot.prototype.deleteAt = function(index, length) {\n                    if (index === 0 && length === this.length()) {\n                        return this.remove();\n                    }\n                    this.children.forEachAt(index, length, function(child, offset, length) {\n                        child.deleteAt(offset, length);\n                    });\n                };\n                ContainerBlot.prototype.descendant = function(criteria, index) {\n                    var _a = this.children.find(index), child = _a[0], offset = _a[1];\n                    if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {\n                        return [\n                            child,\n                            offset\n                        ];\n                    } else if (child instanceof ContainerBlot) {\n                        return child.descendant(criteria, offset);\n                    } else {\n                        return [\n                            null,\n                            -1\n                        ];\n                    }\n                };\n                ContainerBlot.prototype.descendants = function(criteria, index, length) {\n                    if (index === void 0) {\n                        index = 0;\n                    }\n                    if (length === void 0) {\n                        length = Number.MAX_VALUE;\n                    }\n                    var descendants = [];\n                    var lengthLeft = length;\n                    this.children.forEachAt(index, length, function(child, index, length) {\n                        if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {\n                            descendants.push(child);\n                        }\n                        if (child instanceof ContainerBlot) {\n                            descendants = descendants.concat(child.descendants(criteria, index, lengthLeft));\n                        }\n                        lengthLeft -= length;\n                    });\n                    return descendants;\n                };\n                ContainerBlot.prototype.detach = function() {\n                    this.children.forEach(function(child) {\n                        child.detach();\n                    });\n                    _super.prototype.detach.call(this);\n                };\n                ContainerBlot.prototype.formatAt = function(index, length, name, value) {\n                    this.children.forEachAt(index, length, function(child, offset, length) {\n                        child.formatAt(offset, length, name, value);\n                    });\n                };\n                ContainerBlot.prototype.insertAt = function(index, value, def) {\n                    var _a = this.children.find(index), child = _a[0], offset = _a[1];\n                    if (child) {\n                        child.insertAt(offset, value, def);\n                    } else {\n                        var blot = def == null ? Registry.create(\"text\", value) : Registry.create(value, def);\n                        this.appendChild(blot);\n                    }\n                };\n                ContainerBlot.prototype.insertBefore = function(childBlot, refBlot) {\n                    if (this.statics.allowedChildren != null && !this.statics.allowedChildren.some(function(child) {\n                        return childBlot instanceof child;\n                    })) {\n                        throw new Registry.ParchmentError(\"Cannot insert \" + childBlot.statics.blotName + \" into \" + this.statics.blotName);\n                    }\n                    childBlot.insertInto(this, refBlot);\n                };\n                ContainerBlot.prototype.length = function() {\n                    return this.children.reduce(function(memo, child) {\n                        return memo + child.length();\n                    }, 0);\n                };\n                ContainerBlot.prototype.moveChildren = function(targetParent, refNode) {\n                    this.children.forEach(function(child) {\n                        targetParent.insertBefore(child, refNode);\n                    });\n                };\n                ContainerBlot.prototype.optimize = function(context) {\n                    _super.prototype.optimize.call(this, context);\n                    if (this.children.length === 0) {\n                        if (this.statics.defaultChild != null) {\n                            var child = Registry.create(this.statics.defaultChild);\n                            this.appendChild(child);\n                            child.optimize(context);\n                        } else {\n                            this.remove();\n                        }\n                    }\n                };\n                ContainerBlot.prototype.path = function(index, inclusive) {\n                    if (inclusive === void 0) {\n                        inclusive = false;\n                    }\n                    var _a = this.children.find(index, inclusive), child = _a[0], offset = _a[1];\n                    var position = [\n                        [\n                            this,\n                            index\n                        ]\n                    ];\n                    if (child instanceof ContainerBlot) {\n                        return position.concat(child.path(offset, inclusive));\n                    } else if (child != null) {\n                        position.push([\n                            child,\n                            offset\n                        ]);\n                    }\n                    return position;\n                };\n                ContainerBlot.prototype.removeChild = function(child) {\n                    this.children.remove(child);\n                };\n                ContainerBlot.prototype.replace = function(target) {\n                    if (target instanceof ContainerBlot) {\n                        target.moveChildren(this);\n                    }\n                    _super.prototype.replace.call(this, target);\n                };\n                ContainerBlot.prototype.split = function(index, force) {\n                    if (force === void 0) {\n                        force = false;\n                    }\n                    if (!force) {\n                        if (index === 0) return this;\n                        if (index === this.length()) return this.next;\n                    }\n                    var after = this.clone();\n                    this.parent.insertBefore(after, this.next);\n                    this.children.forEachAt(index, this.length(), function(child, offset, length) {\n                        child = child.split(offset, force);\n                        after.appendChild(child);\n                    });\n                    return after;\n                };\n                ContainerBlot.prototype.unwrap = function() {\n                    this.moveChildren(this.parent, this.next);\n                    this.remove();\n                };\n                ContainerBlot.prototype.update = function(mutations, context) {\n                    var _this = this;\n                    var addedNodes = [];\n                    var removedNodes = [];\n                    mutations.forEach(function(mutation) {\n                        if (mutation.target === _this.domNode && mutation.type === \"childList\") {\n                            addedNodes.push.apply(addedNodes, mutation.addedNodes);\n                            removedNodes.push.apply(removedNodes, mutation.removedNodes);\n                        }\n                    });\n                    removedNodes.forEach(function(node) {\n                        // Check node has actually been removed\n                        // One exception is Chrome does not immediately remove IFRAMEs\n                        // from DOM but MutationRecord is correct in its reported removal\n                        if (node.parentNode != null && // @ts-ignore\n                        node.tagName !== \"IFRAME\" && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n                            return;\n                        }\n                        var blot = Registry.find(node);\n                        if (blot == null) return;\n                        if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {\n                            blot.detach();\n                        }\n                    });\n                    addedNodes.filter(function(node) {\n                        return node.parentNode == _this.domNode;\n                    }).sort(function(a, b) {\n                        if (a === b) return 0;\n                        if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {\n                            return 1;\n                        }\n                        return -1;\n                    }).forEach(function(node) {\n                        var refBlot = null;\n                        if (node.nextSibling != null) {\n                            refBlot = Registry.find(node.nextSibling);\n                        }\n                        var blot = makeBlot(node);\n                        if (blot.next != refBlot || blot.next == null) {\n                            if (blot.parent != null) {\n                                blot.parent.removeChild(_this);\n                            }\n                            _this.insertBefore(blot, refBlot || undefined);\n                        }\n                    });\n                };\n                return ContainerBlot;\n            }(shadow_1.default);\n            function makeBlot(node) {\n                var blot = Registry.find(node);\n                if (blot == null) {\n                    try {\n                        blot = Registry.create(node);\n                    } catch (e) {\n                        blot = Registry.create(Registry.Scope.INLINE);\n                        [].slice.call(node.childNodes).forEach(function(child) {\n                            // @ts-ignore\n                            blot.domNode.appendChild(child);\n                        });\n                        if (node.parentNode) {\n                            node.parentNode.replaceChild(blot.domNode, node);\n                        }\n                        blot.attach();\n                    }\n                }\n                return blot;\n            }\n            exports1.default = ContainerBlot;\n        /***/ },\n        /* 18 */ /***/ function(module1, exports1, __nested_webpack_require_197706__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var attributor_1 = __nested_webpack_require_197706__(12);\n            var store_1 = __nested_webpack_require_197706__(31);\n            var container_1 = __nested_webpack_require_197706__(17);\n            var Registry = __nested_webpack_require_197706__(1);\n            var FormatBlot = /** @class */ function(_super) {\n                __extends(FormatBlot, _super);\n                function FormatBlot(domNode) {\n                    var _this = _super.call(this, domNode) || this;\n                    _this.attributes = new store_1.default(_this.domNode);\n                    return _this;\n                }\n                FormatBlot.formats = function(domNode) {\n                    if (typeof this.tagName === \"string\") {\n                        return true;\n                    } else if (Array.isArray(this.tagName)) {\n                        return domNode.tagName.toLowerCase();\n                    }\n                    return undefined;\n                };\n                FormatBlot.prototype.format = function(name, value) {\n                    var format = Registry.query(name);\n                    if (format instanceof attributor_1.default) {\n                        this.attributes.attribute(format, value);\n                    } else if (value) {\n                        if (format != null && (name !== this.statics.blotName || this.formats()[name] !== value)) {\n                            this.replaceWith(name, value);\n                        }\n                    }\n                };\n                FormatBlot.prototype.formats = function() {\n                    var formats = this.attributes.values();\n                    var format = this.statics.formats(this.domNode);\n                    if (format != null) {\n                        formats[this.statics.blotName] = format;\n                    }\n                    return formats;\n                };\n                FormatBlot.prototype.replaceWith = function(name, value) {\n                    var replacement = _super.prototype.replaceWith.call(this, name, value);\n                    this.attributes.copy(replacement);\n                    return replacement;\n                };\n                FormatBlot.prototype.update = function(mutations, context) {\n                    var _this = this;\n                    _super.prototype.update.call(this, mutations, context);\n                    if (mutations.some(function(mutation) {\n                        return mutation.target === _this.domNode && mutation.type === \"attributes\";\n                    })) {\n                        this.attributes.build();\n                    }\n                };\n                FormatBlot.prototype.wrap = function(name, value) {\n                    var wrapper = _super.prototype.wrap.call(this, name, value);\n                    if (wrapper instanceof FormatBlot && wrapper.statics.scope === this.statics.scope) {\n                        this.attributes.move(wrapper);\n                    }\n                    return wrapper;\n                };\n                return FormatBlot;\n            }(container_1.default);\n            exports1.default = FormatBlot;\n        /***/ },\n        /* 19 */ /***/ function(module1, exports1, __nested_webpack_require_201723__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var shadow_1 = __nested_webpack_require_201723__(30);\n            var Registry = __nested_webpack_require_201723__(1);\n            var LeafBlot = /** @class */ function(_super) {\n                __extends(LeafBlot, _super);\n                function LeafBlot() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                LeafBlot.value = function(domNode) {\n                    return true;\n                };\n                LeafBlot.prototype.index = function(node, offset) {\n                    if (this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n                        return Math.min(offset, 1);\n                    }\n                    return -1;\n                };\n                LeafBlot.prototype.position = function(index, inclusive) {\n                    var offset = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);\n                    if (index > 0) offset += 1;\n                    return [\n                        this.parent.domNode,\n                        offset\n                    ];\n                };\n                LeafBlot.prototype.value = function() {\n                    var _a;\n                    return _a = {}, _a[this.statics.blotName] = this.statics.value(this.domNode) || true, _a;\n                };\n                LeafBlot.scope = Registry.Scope.INLINE_BLOT;\n                return LeafBlot;\n            }(shadow_1.default);\n            exports1.default = LeafBlot;\n        /***/ },\n        /* 20 */ /***/ function(module1, exports1, __nested_webpack_require_204185__) {\n            var equal = __nested_webpack_require_204185__(11);\n            var extend = __nested_webpack_require_204185__(3);\n            var lib = {\n                attributes: {\n                    compose: function(a, b, keepNull) {\n                        if (typeof a !== \"object\") a = {};\n                        if (typeof b !== \"object\") b = {};\n                        var attributes = extend(true, {}, b);\n                        if (!keepNull) {\n                            attributes = Object.keys(attributes).reduce(function(copy, key) {\n                                if (attributes[key] != null) {\n                                    copy[key] = attributes[key];\n                                }\n                                return copy;\n                            }, {});\n                        }\n                        for(var key in a){\n                            if (a[key] !== undefined && b[key] === undefined) {\n                                attributes[key] = a[key];\n                            }\n                        }\n                        return Object.keys(attributes).length > 0 ? attributes : undefined;\n                    },\n                    diff: function(a, b) {\n                        if (typeof a !== \"object\") a = {};\n                        if (typeof b !== \"object\") b = {};\n                        var attributes = Object.keys(a).concat(Object.keys(b)).reduce(function(attributes, key) {\n                            if (!equal(a[key], b[key])) {\n                                attributes[key] = b[key] === undefined ? null : b[key];\n                            }\n                            return attributes;\n                        }, {});\n                        return Object.keys(attributes).length > 0 ? attributes : undefined;\n                    },\n                    transform: function(a, b, priority) {\n                        if (typeof a !== \"object\") return b;\n                        if (typeof b !== \"object\") return undefined;\n                        if (!priority) return b; // b simply overwrites us without priority\n                        var attributes = Object.keys(b).reduce(function(attributes, key) {\n                            if (a[key] === undefined) attributes[key] = b[key]; // null is a valid value\n                            return attributes;\n                        }, {});\n                        return Object.keys(attributes).length > 0 ? attributes : undefined;\n                    }\n                },\n                iterator: function(ops) {\n                    return new Iterator(ops);\n                },\n                length: function(op) {\n                    if (typeof op[\"delete\"] === \"number\") {\n                        return op[\"delete\"];\n                    } else if (typeof op.retain === \"number\") {\n                        return op.retain;\n                    } else {\n                        return typeof op.insert === \"string\" ? op.insert.length : 1;\n                    }\n                }\n            };\n            function Iterator(ops) {\n                this.ops = ops;\n                this.index = 0;\n                this.offset = 0;\n            }\n            ;\n            Iterator.prototype.hasNext = function() {\n                return this.peekLength() < Infinity;\n            };\n            Iterator.prototype.next = function(length) {\n                if (!length) length = Infinity;\n                var nextOp = this.ops[this.index];\n                if (nextOp) {\n                    var offset = this.offset;\n                    var opLength = lib.length(nextOp);\n                    if (length >= opLength - offset) {\n                        length = opLength - offset;\n                        this.index += 1;\n                        this.offset = 0;\n                    } else {\n                        this.offset += length;\n                    }\n                    if (typeof nextOp[\"delete\"] === \"number\") {\n                        return {\n                            \"delete\": length\n                        };\n                    } else {\n                        var retOp = {};\n                        if (nextOp.attributes) {\n                            retOp.attributes = nextOp.attributes;\n                        }\n                        if (typeof nextOp.retain === \"number\") {\n                            retOp.retain = length;\n                        } else if (typeof nextOp.insert === \"string\") {\n                            retOp.insert = nextOp.insert.substr(offset, length);\n                        } else {\n                            // offset should === 0, length should === 1\n                            retOp.insert = nextOp.insert;\n                        }\n                        return retOp;\n                    }\n                } else {\n                    return {\n                        retain: Infinity\n                    };\n                }\n            };\n            Iterator.prototype.peek = function() {\n                return this.ops[this.index];\n            };\n            Iterator.prototype.peekLength = function() {\n                if (this.ops[this.index]) {\n                    // Should never return 0 if our index is being managed correctly\n                    return lib.length(this.ops[this.index]) - this.offset;\n                } else {\n                    return Infinity;\n                }\n            };\n            Iterator.prototype.peekType = function() {\n                if (this.ops[this.index]) {\n                    if (typeof this.ops[this.index][\"delete\"] === \"number\") {\n                        return \"delete\";\n                    } else if (typeof this.ops[this.index].retain === \"number\") {\n                        return \"retain\";\n                    } else {\n                        return \"insert\";\n                    }\n                }\n                return \"retain\";\n            };\n            Iterator.prototype.rest = function() {\n                if (!this.hasNext()) {\n                    return [];\n                } else if (this.offset === 0) {\n                    return this.ops.slice(this.index);\n                } else {\n                    var offset = this.offset;\n                    var index = this.index;\n                    var next = this.next();\n                    var rest = this.ops.slice(this.index);\n                    this.offset = offset;\n                    this.index = index;\n                    return [\n                        next\n                    ].concat(rest);\n                }\n            };\n            module1.exports = lib;\n        /***/ },\n        /* 21 */ /***/ function(module1, exports1) {\n            var clone = function() {\n                \"use strict\";\n                function _instanceof(obj, type) {\n                    return type != null && obj instanceof type;\n                }\n                var nativeMap;\n                try {\n                    nativeMap = Map;\n                } catch (_) {\n                    // maybe a reference error because no `Map`. Give it a dummy value that no\n                    // value will ever be an instanceof.\n                    nativeMap = function() {};\n                }\n                var nativeSet;\n                try {\n                    nativeSet = Set;\n                } catch (_) {\n                    nativeSet = function() {};\n                }\n                var nativePromise;\n                try {\n                    nativePromise = Promise;\n                } catch (_) {\n                    nativePromise = function() {};\n                }\n                /**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/ function clone(parent, circular, depth, prototype, includeNonEnumerable) {\n                    if (typeof circular === \"object\") {\n                        depth = circular.depth;\n                        prototype = circular.prototype;\n                        includeNonEnumerable = circular.includeNonEnumerable;\n                        circular = circular.circular;\n                    }\n                    // maintain two arrays for circular references, where corresponding parents\n                    // and children have the same index\n                    var allParents = [];\n                    var allChildren = [];\n                    var useBuffer = typeof Buffer != \"undefined\";\n                    if (typeof circular == \"undefined\") circular = true;\n                    if (typeof depth == \"undefined\") depth = Infinity;\n                    // recurse this function so we don't reset allParents and allChildren\n                    function _clone(parent, depth) {\n                        // cloning null always returns null\n                        if (parent === null) return null;\n                        if (depth === 0) return parent;\n                        var child;\n                        var proto;\n                        if (typeof parent != \"object\") {\n                            return parent;\n                        }\n                        if (_instanceof(parent, nativeMap)) {\n                            child = new nativeMap();\n                        } else if (_instanceof(parent, nativeSet)) {\n                            child = new nativeSet();\n                        } else if (_instanceof(parent, nativePromise)) {\n                            child = new nativePromise(function(resolve, reject) {\n                                parent.then(function(value) {\n                                    resolve(_clone(value, depth - 1));\n                                }, function(err) {\n                                    reject(_clone(err, depth - 1));\n                                });\n                            });\n                        } else if (clone.__isArray(parent)) {\n                            child = [];\n                        } else if (clone.__isRegExp(parent)) {\n                            child = new RegExp(parent.source, __getRegExpFlags(parent));\n                            if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n                        } else if (clone.__isDate(parent)) {\n                            child = new Date(parent.getTime());\n                        } else if (useBuffer && Buffer.isBuffer(parent)) {\n                            if (Buffer.allocUnsafe) {\n                                // Node.js >= 4.5.0\n                                child = Buffer.allocUnsafe(parent.length);\n                            } else {\n                                // Older Node.js versions\n                                child = new Buffer(parent.length);\n                            }\n                            parent.copy(child);\n                            return child;\n                        } else if (_instanceof(parent, Error)) {\n                            child = Object.create(parent);\n                        } else {\n                            if (typeof prototype == \"undefined\") {\n                                proto = Object.getPrototypeOf(parent);\n                                child = Object.create(proto);\n                            } else {\n                                child = Object.create(prototype);\n                                proto = prototype;\n                            }\n                        }\n                        if (circular) {\n                            var index = allParents.indexOf(parent);\n                            if (index != -1) {\n                                return allChildren[index];\n                            }\n                            allParents.push(parent);\n                            allChildren.push(child);\n                        }\n                        if (_instanceof(parent, nativeMap)) {\n                            parent.forEach(function(value, key) {\n                                var keyChild = _clone(key, depth - 1);\n                                var valueChild = _clone(value, depth - 1);\n                                child.set(keyChild, valueChild);\n                            });\n                        }\n                        if (_instanceof(parent, nativeSet)) {\n                            parent.forEach(function(value) {\n                                var entryChild = _clone(value, depth - 1);\n                                child.add(entryChild);\n                            });\n                        }\n                        for(var i in parent){\n                            var attrs;\n                            if (proto) {\n                                attrs = Object.getOwnPropertyDescriptor(proto, i);\n                            }\n                            if (attrs && attrs.set == null) {\n                                continue;\n                            }\n                            child[i] = _clone(parent[i], depth - 1);\n                        }\n                        if (Object.getOwnPropertySymbols) {\n                            var symbols = Object.getOwnPropertySymbols(parent);\n                            for(var i = 0; i < symbols.length; i++){\n                                // Don't need to worry about cloning a symbol because it is a primitive,\n                                // like a number or string.\n                                var symbol = symbols[i];\n                                var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n                                if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n                                    continue;\n                                }\n                                child[symbol] = _clone(parent[symbol], depth - 1);\n                                if (!descriptor.enumerable) {\n                                    Object.defineProperty(child, symbol, {\n                                        enumerable: false\n                                    });\n                                }\n                            }\n                        }\n                        if (includeNonEnumerable) {\n                            var allPropertyNames = Object.getOwnPropertyNames(parent);\n                            for(var i = 0; i < allPropertyNames.length; i++){\n                                var propertyName = allPropertyNames[i];\n                                var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n                                if (descriptor && descriptor.enumerable) {\n                                    continue;\n                                }\n                                child[propertyName] = _clone(parent[propertyName], depth - 1);\n                                Object.defineProperty(child, propertyName, {\n                                    enumerable: false\n                                });\n                            }\n                        }\n                        return child;\n                    }\n                    return _clone(parent, depth);\n                }\n                /**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */ clone.clonePrototype = function clonePrototype(parent) {\n                    if (parent === null) return null;\n                    var c = function() {};\n                    c.prototype = parent;\n                    return new c();\n                };\n                // private utility functions\n                function __objToStr(o) {\n                    return Object.prototype.toString.call(o);\n                }\n                clone.__objToStr = __objToStr;\n                function __isDate(o) {\n                    return typeof o === \"object\" && __objToStr(o) === \"[object Date]\";\n                }\n                clone.__isDate = __isDate;\n                function __isArray(o) {\n                    return typeof o === \"object\" && __objToStr(o) === \"[object Array]\";\n                }\n                clone.__isArray = __isArray;\n                function __isRegExp(o) {\n                    return typeof o === \"object\" && __objToStr(o) === \"[object RegExp]\";\n                }\n                clone.__isRegExp = __isRegExp;\n                function __getRegExpFlags(re) {\n                    var flags = \"\";\n                    if (re.global) flags += \"g\";\n                    if (re.ignoreCase) flags += \"i\";\n                    if (re.multiline) flags += \"m\";\n                    return flags;\n                }\n                clone.__getRegExpFlags = __getRegExpFlags;\n                return clone;\n            }();\n            if (typeof module1 === \"object\" && module1.exports) {\n                module1.exports = clone;\n            }\n        /***/ },\n        /* 22 */ /***/ function(module1, exports1, __nested_webpack_require_221991__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_221991__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _emitter = __nested_webpack_require_221991__(8);\n            var _emitter2 = _interopRequireDefault(_emitter);\n            var _block = __nested_webpack_require_221991__(4);\n            var _block2 = _interopRequireDefault(_block);\n            var _break = __nested_webpack_require_221991__(16);\n            var _break2 = _interopRequireDefault(_break);\n            var _code = __nested_webpack_require_221991__(13);\n            var _code2 = _interopRequireDefault(_code);\n            var _container = __nested_webpack_require_221991__(25);\n            var _container2 = _interopRequireDefault(_container);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            function isLine(blot) {\n                return blot instanceof _block2.default || blot instanceof _block.BlockEmbed;\n            }\n            var Scroll = function(_Parchment$Scroll) {\n                _inherits(Scroll, _Parchment$Scroll);\n                function Scroll(domNode, config) {\n                    _classCallCheck(this, Scroll);\n                    var _this = _possibleConstructorReturn(this, (Scroll.__proto__ || Object.getPrototypeOf(Scroll)).call(this, domNode));\n                    _this.emitter = config.emitter;\n                    if (Array.isArray(config.whitelist)) {\n                        _this.whitelist = config.whitelist.reduce(function(whitelist, format) {\n                            whitelist[format] = true;\n                            return whitelist;\n                        }, {});\n                    }\n                    // Some reason fixes composition issues with character languages in Windows/Chrome, Safari\n                    _this.domNode.addEventListener(\"DOMNodeInserted\", function() {});\n                    _this.optimize();\n                    _this.enable();\n                    return _this;\n                }\n                _createClass(Scroll, [\n                    {\n                        key: \"batchStart\",\n                        value: function batchStart() {\n                            this.batch = true;\n                        }\n                    },\n                    {\n                        key: \"batchEnd\",\n                        value: function batchEnd() {\n                            this.batch = false;\n                            this.optimize();\n                        }\n                    },\n                    {\n                        key: \"deleteAt\",\n                        value: function deleteAt(index, length) {\n                            var _line = this.line(index), _line2 = _slicedToArray(_line, 2), first = _line2[0], offset = _line2[1];\n                            var _line3 = this.line(index + length), _line4 = _slicedToArray(_line3, 1), last = _line4[0];\n                            _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"deleteAt\", this).call(this, index, length);\n                            if (last != null && first !== last && offset > 0) {\n                                if (first instanceof _block.BlockEmbed || last instanceof _block.BlockEmbed) {\n                                    this.optimize();\n                                    return;\n                                }\n                                if (first instanceof _code2.default) {\n                                    var newlineIndex = first.newlineIndex(first.length(), true);\n                                    if (newlineIndex > -1) {\n                                        first = first.split(newlineIndex + 1);\n                                        if (first === last) {\n                                            this.optimize();\n                                            return;\n                                        }\n                                    }\n                                } else if (last instanceof _code2.default) {\n                                    var _newlineIndex = last.newlineIndex(0);\n                                    if (_newlineIndex > -1) {\n                                        last.split(_newlineIndex + 1);\n                                    }\n                                }\n                                var ref = last.children.head instanceof _break2.default ? null : last.children.head;\n                                first.moveChildren(last, ref);\n                                first.remove();\n                            }\n                            this.optimize();\n                        }\n                    },\n                    {\n                        key: \"enable\",\n                        value: function enable() {\n                            var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n                            this.domNode.setAttribute(\"contenteditable\", enabled);\n                        }\n                    },\n                    {\n                        key: \"formatAt\",\n                        value: function formatAt(index, length, format, value) {\n                            if (this.whitelist != null && !this.whitelist[format]) return;\n                            _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"formatAt\", this).call(this, index, length, format, value);\n                            this.optimize();\n                        }\n                    },\n                    {\n                        key: \"insertAt\",\n                        value: function insertAt(index, value, def) {\n                            if (def != null && this.whitelist != null && !this.whitelist[value]) return;\n                            if (index >= this.length()) {\n                                if (def == null || _parchment2.default.query(value, _parchment2.default.Scope.BLOCK) == null) {\n                                    var blot = _parchment2.default.create(this.statics.defaultChild);\n                                    this.appendChild(blot);\n                                    if (def == null && value.endsWith(\"\\n\")) {\n                                        value = value.slice(0, -1);\n                                    }\n                                    blot.insertAt(0, value, def);\n                                } else {\n                                    var embed = _parchment2.default.create(value, def);\n                                    this.appendChild(embed);\n                                }\n                            } else {\n                                _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"insertAt\", this).call(this, index, value, def);\n                            }\n                            this.optimize();\n                        }\n                    },\n                    {\n                        key: \"insertBefore\",\n                        value: function insertBefore(blot, ref) {\n                            if (blot.statics.scope === _parchment2.default.Scope.INLINE_BLOT) {\n                                var wrapper = _parchment2.default.create(this.statics.defaultChild);\n                                wrapper.appendChild(blot);\n                                blot = wrapper;\n                            }\n                            _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"insertBefore\", this).call(this, blot, ref);\n                        }\n                    },\n                    {\n                        key: \"leaf\",\n                        value: function leaf(index) {\n                            return this.path(index).pop() || [\n                                null,\n                                -1\n                            ];\n                        }\n                    },\n                    {\n                        key: \"line\",\n                        value: function line(index) {\n                            if (index === this.length()) {\n                                return this.line(index - 1);\n                            }\n                            return this.descendant(isLine, index);\n                        }\n                    },\n                    {\n                        key: \"lines\",\n                        value: function lines() {\n                            var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n                            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;\n                            var getLines = function getLines(blot, index, length) {\n                                var lines = [], lengthLeft = length;\n                                blot.children.forEachAt(index, length, function(child, index, length) {\n                                    if (isLine(child)) {\n                                        lines.push(child);\n                                    } else if (child instanceof _parchment2.default.Container) {\n                                        lines = lines.concat(getLines(child, index, lengthLeft));\n                                    }\n                                    lengthLeft -= length;\n                                });\n                                return lines;\n                            };\n                            return getLines(this, index, length);\n                        }\n                    },\n                    {\n                        key: \"optimize\",\n                        value: function optimize() {\n                            var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n                            var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            if (this.batch === true) return;\n                            _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"optimize\", this).call(this, mutations, context);\n                            if (mutations.length > 0) {\n                                this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE, mutations, context);\n                            }\n                        }\n                    },\n                    {\n                        key: \"path\",\n                        value: function path(index) {\n                            return _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"path\", this).call(this, index).slice(1); // Exclude self\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update(mutations) {\n                            if (this.batch === true) return;\n                            var source = _emitter2.default.sources.USER;\n                            if (typeof mutations === \"string\") {\n                                source = mutations;\n                            }\n                            if (!Array.isArray(mutations)) {\n                                mutations = this.observer.takeRecords();\n                            }\n                            if (mutations.length > 0) {\n                                this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE, source, mutations);\n                            }\n                            _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), \"update\", this).call(this, mutations.concat([])); // pass copy\n                            if (mutations.length > 0) {\n                                this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE, source, mutations);\n                            }\n                        }\n                    }\n                ]);\n                return Scroll;\n            }(_parchment2.default.Scroll);\n            Scroll.blotName = \"scroll\";\n            Scroll.className = \"ql-editor\";\n            Scroll.tagName = \"DIV\";\n            Scroll.defaultChild = \"block\";\n            Scroll.allowedChildren = [\n                _block2.default,\n                _block.BlockEmbed,\n                _container2.default\n            ];\n            exports1.default = Scroll;\n        /***/ },\n        /* 23 */ /***/ function(module1, exports1, __nested_webpack_require_238907__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.SHORTKEY = exports1.default = undefined;\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _clone = __nested_webpack_require_238907__(21);\n            var _clone2 = _interopRequireDefault(_clone);\n            var _deepEqual = __nested_webpack_require_238907__(11);\n            var _deepEqual2 = _interopRequireDefault(_deepEqual);\n            var _extend = __nested_webpack_require_238907__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _quillDelta = __nested_webpack_require_238907__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _op = __nested_webpack_require_238907__(20);\n            var _op2 = _interopRequireDefault(_op);\n            var _parchment = __nested_webpack_require_238907__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_238907__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _logger = __nested_webpack_require_238907__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            var _module = __nested_webpack_require_238907__(9);\n            var _module2 = _interopRequireDefault(_module);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var debug = (0, _logger2.default)(\"quill:keyboard\");\n            var SHORTKEY = /Mac/i.test(navigator.platform) ? \"metaKey\" : \"ctrlKey\";\n            var Keyboard = function(_Module) {\n                _inherits(Keyboard, _Module);\n                _createClass(Keyboard, null, [\n                    {\n                        key: \"match\",\n                        value: function match(evt, binding) {\n                            binding = normalize(binding);\n                            if ([\n                                \"altKey\",\n                                \"ctrlKey\",\n                                \"metaKey\",\n                                \"shiftKey\"\n                            ].some(function(key) {\n                                return !!binding[key] !== evt[key] && binding[key] !== null;\n                            })) {\n                                return false;\n                            }\n                            return binding.key === (evt.which || evt.keyCode);\n                        }\n                    }\n                ]);\n                function Keyboard(quill, options) {\n                    _classCallCheck(this, Keyboard);\n                    var _this = _possibleConstructorReturn(this, (Keyboard.__proto__ || Object.getPrototypeOf(Keyboard)).call(this, quill, options));\n                    _this.bindings = {};\n                    Object.keys(_this.options.bindings).forEach(function(name) {\n                        if (name === \"list autofill\" && quill.scroll.whitelist != null && !quill.scroll.whitelist[\"list\"]) {\n                            return;\n                        }\n                        if (_this.options.bindings[name]) {\n                            _this.addBinding(_this.options.bindings[name]);\n                        }\n                    });\n                    _this.addBinding({\n                        key: Keyboard.keys.ENTER,\n                        shiftKey: null\n                    }, handleEnter);\n                    _this.addBinding({\n                        key: Keyboard.keys.ENTER,\n                        metaKey: null,\n                        ctrlKey: null,\n                        altKey: null\n                    }, function() {});\n                    if (/Firefox/i.test(navigator.userAgent)) {\n                        // Need to handle delete and backspace for Firefox in the general case #1171\n                        _this.addBinding({\n                            key: Keyboard.keys.BACKSPACE\n                        }, {\n                            collapsed: true\n                        }, handleBackspace);\n                        _this.addBinding({\n                            key: Keyboard.keys.DELETE\n                        }, {\n                            collapsed: true\n                        }, handleDelete);\n                    } else {\n                        _this.addBinding({\n                            key: Keyboard.keys.BACKSPACE\n                        }, {\n                            collapsed: true,\n                            prefix: /^.?$/\n                        }, handleBackspace);\n                        _this.addBinding({\n                            key: Keyboard.keys.DELETE\n                        }, {\n                            collapsed: true,\n                            suffix: /^.?$/\n                        }, handleDelete);\n                    }\n                    _this.addBinding({\n                        key: Keyboard.keys.BACKSPACE\n                    }, {\n                        collapsed: false\n                    }, handleDeleteRange);\n                    _this.addBinding({\n                        key: Keyboard.keys.DELETE\n                    }, {\n                        collapsed: false\n                    }, handleDeleteRange);\n                    _this.addBinding({\n                        key: Keyboard.keys.BACKSPACE,\n                        altKey: null,\n                        ctrlKey: null,\n                        metaKey: null,\n                        shiftKey: null\n                    }, {\n                        collapsed: true,\n                        offset: 0\n                    }, handleBackspace);\n                    _this.listen();\n                    return _this;\n                }\n                _createClass(Keyboard, [\n                    {\n                        key: \"addBinding\",\n                        value: function addBinding(key) {\n                            var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            var handler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            var binding = normalize(key);\n                            if (binding == null || binding.key == null) {\n                                return debug.warn(\"Attempted to add invalid keyboard binding\", binding);\n                            }\n                            if (typeof context === \"function\") {\n                                context = {\n                                    handler: context\n                                };\n                            }\n                            if (typeof handler === \"function\") {\n                                handler = {\n                                    handler: handler\n                                };\n                            }\n                            binding = (0, _extend2.default)(binding, context, handler);\n                            this.bindings[binding.key] = this.bindings[binding.key] || [];\n                            this.bindings[binding.key].push(binding);\n                        }\n                    },\n                    {\n                        key: \"listen\",\n                        value: function listen() {\n                            var _this2 = this;\n                            this.quill.root.addEventListener(\"keydown\", function(evt) {\n                                if (evt.defaultPrevented) return;\n                                var which = evt.which || evt.keyCode;\n                                var bindings = (_this2.bindings[which] || []).filter(function(binding) {\n                                    return Keyboard.match(evt, binding);\n                                });\n                                if (bindings.length === 0) return;\n                                var range = _this2.quill.getSelection();\n                                if (range == null || !_this2.quill.hasFocus()) return;\n                                var _quill$getLine = _this2.quill.getLine(range.index), _quill$getLine2 = _slicedToArray(_quill$getLine, 2), line = _quill$getLine2[0], offset = _quill$getLine2[1];\n                                var _quill$getLeaf = _this2.quill.getLeaf(range.index), _quill$getLeaf2 = _slicedToArray(_quill$getLeaf, 2), leafStart = _quill$getLeaf2[0], offsetStart = _quill$getLeaf2[1];\n                                var _ref = range.length === 0 ? [\n                                    leafStart,\n                                    offsetStart\n                                ] : _this2.quill.getLeaf(range.index + range.length), _ref2 = _slicedToArray(_ref, 2), leafEnd = _ref2[0], offsetEnd = _ref2[1];\n                                var prefixText = leafStart instanceof _parchment2.default.Text ? leafStart.value().slice(0, offsetStart) : \"\";\n                                var suffixText = leafEnd instanceof _parchment2.default.Text ? leafEnd.value().slice(offsetEnd) : \"\";\n                                var curContext = {\n                                    collapsed: range.length === 0,\n                                    empty: range.length === 0 && line.length() <= 1,\n                                    format: _this2.quill.getFormat(range),\n                                    offset: offset,\n                                    prefix: prefixText,\n                                    suffix: suffixText\n                                };\n                                var prevented = bindings.some(function(binding) {\n                                    if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) return false;\n                                    if (binding.empty != null && binding.empty !== curContext.empty) return false;\n                                    if (binding.offset != null && binding.offset !== curContext.offset) return false;\n                                    if (Array.isArray(binding.format)) {\n                                        // any format is present\n                                        if (binding.format.every(function(name) {\n                                            return curContext.format[name] == null;\n                                        })) {\n                                            return false;\n                                        }\n                                    } else if (_typeof(binding.format) === \"object\") {\n                                        // all formats must match\n                                        if (!Object.keys(binding.format).every(function(name) {\n                                            if (binding.format[name] === true) return curContext.format[name] != null;\n                                            if (binding.format[name] === false) return curContext.format[name] == null;\n                                            return (0, _deepEqual2.default)(binding.format[name], curContext.format[name]);\n                                        })) {\n                                            return false;\n                                        }\n                                    }\n                                    if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) return false;\n                                    if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) return false;\n                                    return binding.handler.call(_this2, range, curContext) !== true;\n                                });\n                                if (prevented) {\n                                    evt.preventDefault();\n                                }\n                            });\n                        }\n                    }\n                ]);\n                return Keyboard;\n            }(_module2.default);\n            Keyboard.keys = {\n                BACKSPACE: 8,\n                TAB: 9,\n                ENTER: 13,\n                ESCAPE: 27,\n                LEFT: 37,\n                UP: 38,\n                RIGHT: 39,\n                DOWN: 40,\n                DELETE: 46\n            };\n            Keyboard.DEFAULTS = {\n                bindings: {\n                    \"bold\": makeFormatHandler(\"bold\"),\n                    \"italic\": makeFormatHandler(\"italic\"),\n                    \"underline\": makeFormatHandler(\"underline\"),\n                    \"indent\": {\n                        // highlight tab or tab at beginning of list, indent or blockquote\n                        key: Keyboard.keys.TAB,\n                        format: [\n                            \"blockquote\",\n                            \"indent\",\n                            \"list\"\n                        ],\n                        handler: function handler(range, context) {\n                            if (context.collapsed && context.offset !== 0) return true;\n                            this.quill.format(\"indent\", \"+1\", _quill2.default.sources.USER);\n                        }\n                    },\n                    \"outdent\": {\n                        key: Keyboard.keys.TAB,\n                        shiftKey: true,\n                        format: [\n                            \"blockquote\",\n                            \"indent\",\n                            \"list\"\n                        ],\n                        // highlight tab or tab at beginning of list, indent or blockquote\n                        handler: function handler(range, context) {\n                            if (context.collapsed && context.offset !== 0) return true;\n                            this.quill.format(\"indent\", \"-1\", _quill2.default.sources.USER);\n                        }\n                    },\n                    \"outdent backspace\": {\n                        key: Keyboard.keys.BACKSPACE,\n                        collapsed: true,\n                        shiftKey: null,\n                        metaKey: null,\n                        ctrlKey: null,\n                        altKey: null,\n                        format: [\n                            \"indent\",\n                            \"list\"\n                        ],\n                        offset: 0,\n                        handler: function handler(range, context) {\n                            if (context.format.indent != null) {\n                                this.quill.format(\"indent\", \"-1\", _quill2.default.sources.USER);\n                            } else if (context.format.list != null) {\n                                this.quill.format(\"list\", false, _quill2.default.sources.USER);\n                            }\n                        }\n                    },\n                    \"indent code-block\": makeCodeBlockHandler(true),\n                    \"outdent code-block\": makeCodeBlockHandler(false),\n                    \"remove tab\": {\n                        key: Keyboard.keys.TAB,\n                        shiftKey: true,\n                        collapsed: true,\n                        prefix: /\\t$/,\n                        handler: function handler(range) {\n                            this.quill.deleteText(range.index - 1, 1, _quill2.default.sources.USER);\n                        }\n                    },\n                    \"tab\": {\n                        key: Keyboard.keys.TAB,\n                        handler: function handler(range) {\n                            this.quill.history.cutoff();\n                            var delta = new _quillDelta2.default().retain(range.index).delete(range.length).insert(\"\t\");\n                            this.quill.updateContents(delta, _quill2.default.sources.USER);\n                            this.quill.history.cutoff();\n                            this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n                        }\n                    },\n                    \"list empty enter\": {\n                        key: Keyboard.keys.ENTER,\n                        collapsed: true,\n                        format: [\n                            \"list\"\n                        ],\n                        empty: true,\n                        handler: function handler(range, context) {\n                            this.quill.format(\"list\", false, _quill2.default.sources.USER);\n                            if (context.format.indent) {\n                                this.quill.format(\"indent\", false, _quill2.default.sources.USER);\n                            }\n                        }\n                    },\n                    \"checklist enter\": {\n                        key: Keyboard.keys.ENTER,\n                        collapsed: true,\n                        format: {\n                            list: \"checked\"\n                        },\n                        handler: function handler(range) {\n                            var _quill$getLine3 = this.quill.getLine(range.index), _quill$getLine4 = _slicedToArray(_quill$getLine3, 2), line = _quill$getLine4[0], offset = _quill$getLine4[1];\n                            var formats = (0, _extend2.default)({}, line.formats(), {\n                                list: \"checked\"\n                            });\n                            var delta = new _quillDelta2.default().retain(range.index).insert(\"\\n\", formats).retain(line.length() - offset - 1).retain(1, {\n                                list: \"unchecked\"\n                            });\n                            this.quill.updateContents(delta, _quill2.default.sources.USER);\n                            this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n                            this.quill.scrollIntoView();\n                        }\n                    },\n                    \"header enter\": {\n                        key: Keyboard.keys.ENTER,\n                        collapsed: true,\n                        format: [\n                            \"header\"\n                        ],\n                        suffix: /^$/,\n                        handler: function handler(range, context) {\n                            var _quill$getLine5 = this.quill.getLine(range.index), _quill$getLine6 = _slicedToArray(_quill$getLine5, 2), line = _quill$getLine6[0], offset = _quill$getLine6[1];\n                            var delta = new _quillDelta2.default().retain(range.index).insert(\"\\n\", context.format).retain(line.length() - offset - 1).retain(1, {\n                                header: null\n                            });\n                            this.quill.updateContents(delta, _quill2.default.sources.USER);\n                            this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n                            this.quill.scrollIntoView();\n                        }\n                    },\n                    \"list autofill\": {\n                        key: \" \",\n                        collapsed: true,\n                        format: {\n                            list: false\n                        },\n                        prefix: /^\\s*?(\\d+\\.|-|\\*|\\[ ?\\]|\\[x\\])$/,\n                        handler: function handler(range, context) {\n                            var length = context.prefix.length;\n                            var _quill$getLine7 = this.quill.getLine(range.index), _quill$getLine8 = _slicedToArray(_quill$getLine7, 2), line = _quill$getLine8[0], offset = _quill$getLine8[1];\n                            if (offset > length) return true;\n                            var value = void 0;\n                            switch(context.prefix.trim()){\n                                case \"[]\":\n                                case \"[ ]\":\n                                    value = \"unchecked\";\n                                    break;\n                                case \"[x]\":\n                                    value = \"checked\";\n                                    break;\n                                case \"-\":\n                                case \"*\":\n                                    value = \"bullet\";\n                                    break;\n                                default:\n                                    value = \"ordered\";\n                            }\n                            this.quill.insertText(range.index, \" \", _quill2.default.sources.USER);\n                            this.quill.history.cutoff();\n                            var delta = new _quillDelta2.default().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, {\n                                list: value\n                            });\n                            this.quill.updateContents(delta, _quill2.default.sources.USER);\n                            this.quill.history.cutoff();\n                            this.quill.setSelection(range.index - length, _quill2.default.sources.SILENT);\n                        }\n                    },\n                    \"code exit\": {\n                        key: Keyboard.keys.ENTER,\n                        collapsed: true,\n                        format: [\n                            \"code-block\"\n                        ],\n                        prefix: /\\n\\n$/,\n                        suffix: /^\\s+$/,\n                        handler: function handler(range) {\n                            var _quill$getLine9 = this.quill.getLine(range.index), _quill$getLine10 = _slicedToArray(_quill$getLine9, 2), line = _quill$getLine10[0], offset = _quill$getLine10[1];\n                            var delta = new _quillDelta2.default().retain(range.index + line.length() - offset - 2).retain(1, {\n                                \"code-block\": null\n                            }).delete(1);\n                            this.quill.updateContents(delta, _quill2.default.sources.USER);\n                        }\n                    },\n                    \"embed left\": makeEmbedArrowHandler(Keyboard.keys.LEFT, false),\n                    \"embed left shift\": makeEmbedArrowHandler(Keyboard.keys.LEFT, true),\n                    \"embed right\": makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),\n                    \"embed right shift\": makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)\n                }\n            };\n            function makeEmbedArrowHandler(key, shiftKey) {\n                var _ref3;\n                var where = key === Keyboard.keys.LEFT ? \"prefix\" : \"suffix\";\n                return _ref3 = {\n                    key: key,\n                    shiftKey: shiftKey,\n                    altKey: null\n                }, _defineProperty(_ref3, where, /^$/), _defineProperty(_ref3, \"handler\", function handler(range) {\n                    var index = range.index;\n                    if (key === Keyboard.keys.RIGHT) {\n                        index += range.length + 1;\n                    }\n                    var _quill$getLeaf3 = this.quill.getLeaf(index), _quill$getLeaf4 = _slicedToArray(_quill$getLeaf3, 1), leaf = _quill$getLeaf4[0];\n                    if (!(leaf instanceof _parchment2.default.Embed)) return true;\n                    if (key === Keyboard.keys.LEFT) {\n                        if (shiftKey) {\n                            this.quill.setSelection(range.index - 1, range.length + 1, _quill2.default.sources.USER);\n                        } else {\n                            this.quill.setSelection(range.index - 1, _quill2.default.sources.USER);\n                        }\n                    } else {\n                        if (shiftKey) {\n                            this.quill.setSelection(range.index, range.length + 1, _quill2.default.sources.USER);\n                        } else {\n                            this.quill.setSelection(range.index + range.length + 1, _quill2.default.sources.USER);\n                        }\n                    }\n                    return false;\n                }), _ref3;\n            }\n            function handleBackspace(range, context) {\n                if (range.index === 0 || this.quill.getLength() <= 1) return;\n                var _quill$getLine11 = this.quill.getLine(range.index), _quill$getLine12 = _slicedToArray(_quill$getLine11, 1), line = _quill$getLine12[0];\n                var formats = {};\n                if (context.offset === 0) {\n                    var _quill$getLine13 = this.quill.getLine(range.index - 1), _quill$getLine14 = _slicedToArray(_quill$getLine13, 1), prev = _quill$getLine14[0];\n                    if (prev != null && prev.length() > 1) {\n                        var curFormats = line.formats();\n                        var prevFormats = this.quill.getFormat(range.index - 1, 1);\n                        formats = _op2.default.attributes.diff(curFormats, prevFormats) || {};\n                    }\n                }\n                // Check for astral symbols\n                var length = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]$/.test(context.prefix) ? 2 : 1;\n                this.quill.deleteText(range.index - length, length, _quill2.default.sources.USER);\n                if (Object.keys(formats).length > 0) {\n                    this.quill.formatLine(range.index - length, length, formats, _quill2.default.sources.USER);\n                }\n                this.quill.focus();\n            }\n            function handleDelete(range, context) {\n                // Check for astral symbols\n                var length = /^[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/.test(context.suffix) ? 2 : 1;\n                if (range.index >= this.quill.getLength() - length) return;\n                var formats = {}, nextLength = 0;\n                var _quill$getLine15 = this.quill.getLine(range.index), _quill$getLine16 = _slicedToArray(_quill$getLine15, 1), line = _quill$getLine16[0];\n                if (context.offset >= line.length() - 1) {\n                    var _quill$getLine17 = this.quill.getLine(range.index + 1), _quill$getLine18 = _slicedToArray(_quill$getLine17, 1), next = _quill$getLine18[0];\n                    if (next) {\n                        var curFormats = line.formats();\n                        var nextFormats = this.quill.getFormat(range.index, 1);\n                        formats = _op2.default.attributes.diff(curFormats, nextFormats) || {};\n                        nextLength = next.length();\n                    }\n                }\n                this.quill.deleteText(range.index, length, _quill2.default.sources.USER);\n                if (Object.keys(formats).length > 0) {\n                    this.quill.formatLine(range.index + nextLength - 1, length, formats, _quill2.default.sources.USER);\n                }\n            }\n            function handleDeleteRange(range) {\n                var lines = this.quill.getLines(range);\n                var formats = {};\n                if (lines.length > 1) {\n                    var firstFormats = lines[0].formats();\n                    var lastFormats = lines[lines.length - 1].formats();\n                    formats = _op2.default.attributes.diff(lastFormats, firstFormats) || {};\n                }\n                this.quill.deleteText(range, _quill2.default.sources.USER);\n                if (Object.keys(formats).length > 0) {\n                    this.quill.formatLine(range.index, 1, formats, _quill2.default.sources.USER);\n                }\n                this.quill.setSelection(range.index, _quill2.default.sources.SILENT);\n                this.quill.focus();\n            }\n            function handleEnter(range, context) {\n                var _this3 = this;\n                if (range.length > 0) {\n                    this.quill.scroll.deleteAt(range.index, range.length); // So we do not trigger text-change\n                }\n                var lineFormats = Object.keys(context.format).reduce(function(lineFormats, format) {\n                    if (_parchment2.default.query(format, _parchment2.default.Scope.BLOCK) && !Array.isArray(context.format[format])) {\n                        lineFormats[format] = context.format[format];\n                    }\n                    return lineFormats;\n                }, {});\n                this.quill.insertText(range.index, \"\\n\", lineFormats, _quill2.default.sources.USER);\n                // Earlier scroll.deleteAt might have messed up our selection,\n                // so insertText's built in selection preservation is not reliable\n                this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n                this.quill.focus();\n                Object.keys(context.format).forEach(function(name) {\n                    if (lineFormats[name] != null) return;\n                    if (Array.isArray(context.format[name])) return;\n                    if (name === \"link\") return;\n                    _this3.quill.format(name, context.format[name], _quill2.default.sources.USER);\n                });\n            }\n            function makeCodeBlockHandler(indent) {\n                return {\n                    key: Keyboard.keys.TAB,\n                    shiftKey: !indent,\n                    format: {\n                        \"code-block\": true\n                    },\n                    handler: function handler(range) {\n                        var CodeBlock = _parchment2.default.query(\"code-block\");\n                        var index = range.index, length = range.length;\n                        var _quill$scroll$descend = this.quill.scroll.descendant(CodeBlock, index), _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2), block = _quill$scroll$descend2[0], offset = _quill$scroll$descend2[1];\n                        if (block == null) return;\n                        var scrollIndex = this.quill.getIndex(block);\n                        var start = block.newlineIndex(offset, true) + 1;\n                        var end = block.newlineIndex(scrollIndex + offset + length);\n                        var lines = block.domNode.textContent.slice(start, end).split(\"\\n\");\n                        offset = 0;\n                        lines.forEach(function(line, i) {\n                            if (indent) {\n                                block.insertAt(start + offset, CodeBlock.TAB);\n                                offset += CodeBlock.TAB.length;\n                                if (i === 0) {\n                                    index += CodeBlock.TAB.length;\n                                } else {\n                                    length += CodeBlock.TAB.length;\n                                }\n                            } else if (line.startsWith(CodeBlock.TAB)) {\n                                block.deleteAt(start + offset, CodeBlock.TAB.length);\n                                offset -= CodeBlock.TAB.length;\n                                if (i === 0) {\n                                    index -= CodeBlock.TAB.length;\n                                } else {\n                                    length -= CodeBlock.TAB.length;\n                                }\n                            }\n                            offset += line.length + 1;\n                        });\n                        this.quill.update(_quill2.default.sources.USER);\n                        this.quill.setSelection(index, length, _quill2.default.sources.SILENT);\n                    }\n                };\n            }\n            function makeFormatHandler(format) {\n                return {\n                    key: format[0].toUpperCase(),\n                    shortKey: true,\n                    handler: function handler(range, context) {\n                        this.quill.format(format, !context.format[format], _quill2.default.sources.USER);\n                    }\n                };\n            }\n            function normalize(binding) {\n                if (typeof binding === \"string\" || typeof binding === \"number\") {\n                    return normalize({\n                        key: binding\n                    });\n                }\n                if ((typeof binding === \"undefined\" ? \"undefined\" : _typeof(binding)) === \"object\") {\n                    binding = (0, _clone2.default)(binding, false);\n                }\n                if (typeof binding.key === \"string\") {\n                    if (Keyboard.keys[binding.key.toUpperCase()] != null) {\n                        binding.key = Keyboard.keys[binding.key.toUpperCase()];\n                    } else if (binding.key.length === 1) {\n                        binding.key = binding.key.toUpperCase().charCodeAt(0);\n                    } else {\n                        return null;\n                    }\n                }\n                if (binding.shortKey) {\n                    binding[SHORTKEY] = binding.shortKey;\n                    delete binding.shortKey;\n                }\n                return binding;\n            }\n            exports1.default = Keyboard;\n            exports1.SHORTKEY = SHORTKEY;\n        /***/ },\n        /* 24 */ /***/ function(module1, exports1, __nested_webpack_require_275910__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _parchment = __nested_webpack_require_275910__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _text = __nested_webpack_require_275910__(7);\n            var _text2 = _interopRequireDefault(_text);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Cursor = function(_Parchment$Embed) {\n                _inherits(Cursor, _Parchment$Embed);\n                _createClass(Cursor, null, [\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return undefined;\n                        }\n                    }\n                ]);\n                function Cursor(domNode, selection) {\n                    _classCallCheck(this, Cursor);\n                    var _this = _possibleConstructorReturn(this, (Cursor.__proto__ || Object.getPrototypeOf(Cursor)).call(this, domNode));\n                    _this.selection = selection;\n                    _this.textNode = document.createTextNode(Cursor.CONTENTS);\n                    _this.domNode.appendChild(_this.textNode);\n                    _this._length = 0;\n                    return _this;\n                }\n                _createClass(Cursor, [\n                    {\n                        key: \"detach\",\n                        value: function detach() {\n                            // super.detach() will also clear domNode.__blot\n                            if (this.parent != null) this.parent.removeChild(this);\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (this._length !== 0) {\n                                return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), \"format\", this).call(this, name, value);\n                            }\n                            var target = this, index = 0;\n                            while(target != null && target.statics.scope !== _parchment2.default.Scope.BLOCK_BLOT){\n                                index += target.offset(target.parent);\n                                target = target.parent;\n                            }\n                            if (target != null) {\n                                this._length = Cursor.CONTENTS.length;\n                                target.optimize();\n                                target.formatAt(index, Cursor.CONTENTS.length, name, value);\n                                this._length = 0;\n                            }\n                        }\n                    },\n                    {\n                        key: \"index\",\n                        value: function index(node, offset) {\n                            if (node === this.textNode) return 0;\n                            return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), \"index\", this).call(this, node, offset);\n                        }\n                    },\n                    {\n                        key: \"length\",\n                        value: function length() {\n                            return this._length;\n                        }\n                    },\n                    {\n                        key: \"position\",\n                        value: function position() {\n                            return [\n                                this.textNode,\n                                this.textNode.data.length\n                            ];\n                        }\n                    },\n                    {\n                        key: \"remove\",\n                        value: function remove() {\n                            _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), \"remove\", this).call(this);\n                            this.parent = null;\n                        }\n                    },\n                    {\n                        key: \"restore\",\n                        value: function restore() {\n                            if (this.selection.composing || this.parent == null) return;\n                            var textNode = this.textNode;\n                            var range = this.selection.getNativeRange();\n                            var restoreText = void 0, start = void 0, end = void 0;\n                            if (range != null && range.start.node === textNode && range.end.node === textNode) {\n                                var _ref = [\n                                    textNode,\n                                    range.start.offset,\n                                    range.end.offset\n                                ];\n                                restoreText = _ref[0];\n                                start = _ref[1];\n                                end = _ref[2];\n                            }\n                            // Link format will insert text outside of anchor tag\n                            while(this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode){\n                                this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);\n                            }\n                            if (this.textNode.data !== Cursor.CONTENTS) {\n                                var text = this.textNode.data.split(Cursor.CONTENTS).join(\"\");\n                                if (this.next instanceof _text2.default) {\n                                    restoreText = this.next.domNode;\n                                    this.next.insertAt(0, text);\n                                    this.textNode.data = Cursor.CONTENTS;\n                                } else {\n                                    this.textNode.data = text;\n                                    this.parent.insertBefore(_parchment2.default.create(this.textNode), this);\n                                    this.textNode = document.createTextNode(Cursor.CONTENTS);\n                                    this.domNode.appendChild(this.textNode);\n                                }\n                            }\n                            this.remove();\n                            if (start != null) {\n                                var _map = [\n                                    start,\n                                    end\n                                ].map(function(offset) {\n                                    return Math.max(0, Math.min(restoreText.data.length, offset - 1));\n                                });\n                                var _map2 = _slicedToArray(_map, 2);\n                                start = _map2[0];\n                                end = _map2[1];\n                                return {\n                                    startNode: restoreText,\n                                    startOffset: start,\n                                    endNode: restoreText,\n                                    endOffset: end\n                                };\n                            }\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update(mutations, context) {\n                            var _this2 = this;\n                            if (mutations.some(function(mutation) {\n                                return mutation.type === \"characterData\" && mutation.target === _this2.textNode;\n                            })) {\n                                var range = this.restore();\n                                if (range) context.range = range;\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return \"\";\n                        }\n                    }\n                ]);\n                return Cursor;\n            }(_parchment2.default.Embed);\n            Cursor.blotName = \"cursor\";\n            Cursor.className = \"ql-cursor\";\n            Cursor.tagName = \"span\";\n            Cursor.CONTENTS = \"\\uFEFF\"; // Zero width no break space\n            exports1.default = Cursor;\n        /***/ },\n        /* 25 */ /***/ function(module1, exports1, __nested_webpack_require_288827__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _parchment = __nested_webpack_require_288827__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _block = __nested_webpack_require_288827__(4);\n            var _block2 = _interopRequireDefault(_block);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Container = function(_Parchment$Container) {\n                _inherits(Container, _Parchment$Container);\n                function Container() {\n                    _classCallCheck(this, Container);\n                    return _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));\n                }\n                return Container;\n            }(_parchment2.default.Container);\n            Container.allowedChildren = [\n                _block2.default,\n                _block.BlockEmbed,\n                Container\n            ];\n            exports1.default = Container;\n        /***/ },\n        /* 26 */ /***/ function(module1, exports1, __nested_webpack_require_291415__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.ColorStyle = exports1.ColorClass = exports1.ColorAttributor = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_291415__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ColorAttributor = function(_Parchment$Attributor) {\n                _inherits(ColorAttributor, _Parchment$Attributor);\n                function ColorAttributor() {\n                    _classCallCheck(this, ColorAttributor);\n                    return _possibleConstructorReturn(this, (ColorAttributor.__proto__ || Object.getPrototypeOf(ColorAttributor)).apply(this, arguments));\n                }\n                _createClass(ColorAttributor, [\n                    {\n                        key: \"value\",\n                        value: function value(domNode) {\n                            var value = _get(ColorAttributor.prototype.__proto__ || Object.getPrototypeOf(ColorAttributor.prototype), \"value\", this).call(this, domNode);\n                            if (!value.startsWith(\"rgb(\")) return value;\n                            value = value.replace(/^[^\\d]+/, \"\").replace(/[^\\d]+$/, \"\");\n                            return \"#\" + value.split(\",\").map(function(component) {\n                                return (\"00\" + parseInt(component).toString(16)).slice(-2);\n                            }).join(\"\");\n                        }\n                    }\n                ]);\n                return ColorAttributor;\n            }(_parchment2.default.Attributor.Style);\n            var ColorClass = new _parchment2.default.Attributor.Class(\"color\", \"ql-color\", {\n                scope: _parchment2.default.Scope.INLINE\n            });\n            var ColorStyle = new ColorAttributor(\"color\", \"color\", {\n                scope: _parchment2.default.Scope.INLINE\n            });\n            exports1.ColorAttributor = ColorAttributor;\n            exports1.ColorClass = ColorClass;\n            exports1.ColorStyle = ColorStyle;\n        /***/ },\n        /* 27 */ /***/ function(module1, exports1, __nested_webpack_require_296817__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.sanitize = exports1.default = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _inline = __nested_webpack_require_296817__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Link = function(_Inline) {\n                _inherits(Link, _Inline);\n                function Link() {\n                    _classCallCheck(this, Link);\n                    return _possibleConstructorReturn(this, (Link.__proto__ || Object.getPrototypeOf(Link)).apply(this, arguments));\n                }\n                _createClass(Link, [\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (name !== this.statics.blotName || !value) return _get(Link.prototype.__proto__ || Object.getPrototypeOf(Link.prototype), \"format\", this).call(this, name, value);\n                            value = this.constructor.sanitize(value);\n                            this.domNode.setAttribute(\"href\", value);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var node = _get(Link.__proto__ || Object.getPrototypeOf(Link), \"create\", this).call(this, value);\n                            value = this.sanitize(value);\n                            node.setAttribute(\"href\", value);\n                            node.setAttribute(\"rel\", \"noopener noreferrer\");\n                            node.setAttribute(\"target\", \"_blank\");\n                            return node;\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            return domNode.getAttribute(\"href\");\n                        }\n                    },\n                    {\n                        key: \"sanitize\",\n                        value: function sanitize(url) {\n                            return _sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;\n                        }\n                    }\n                ]);\n                return Link;\n            }(_inline2.default);\n            Link.blotName = \"link\";\n            Link.tagName = \"A\";\n            Link.SANITIZED_URL = \"about:blank\";\n            Link.PROTOCOL_WHITELIST = [\n                \"http\",\n                \"https\",\n                \"mailto\",\n                \"tel\"\n            ];\n            function _sanitize(url, protocols) {\n                var anchor = document.createElement(\"a\");\n                anchor.href = url;\n                var protocol = anchor.href.slice(0, anchor.href.indexOf(\":\"));\n                return protocols.indexOf(protocol) > -1;\n            }\n            exports1.default = Link;\n            exports1.sanitize = _sanitize;\n        /***/ },\n        /* 28 */ /***/ function(module1, exports1, __nested_webpack_require_303142__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _keyboard = __nested_webpack_require_303142__(23);\n            var _keyboard2 = _interopRequireDefault(_keyboard);\n            var _dropdown = __nested_webpack_require_303142__(107);\n            var _dropdown2 = _interopRequireDefault(_dropdown);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var optionsCounter = 0;\n            function toggleAriaAttribute(element, attribute) {\n                element.setAttribute(attribute, !(element.getAttribute(attribute) === \"true\"));\n            }\n            var Picker = function() {\n                function Picker(select) {\n                    var _this = this;\n                    _classCallCheck(this, Picker);\n                    this.select = select;\n                    this.container = document.createElement(\"span\");\n                    this.buildPicker();\n                    this.select.style.display = \"none\";\n                    this.select.parentNode.insertBefore(this.container, this.select);\n                    this.label.addEventListener(\"mousedown\", function() {\n                        _this.togglePicker();\n                    });\n                    this.label.addEventListener(\"keydown\", function(event) {\n                        switch(event.keyCode){\n                            // Allows the \"Enter\" key to open the picker\n                            case _keyboard2.default.keys.ENTER:\n                                _this.togglePicker();\n                                break;\n                            // Allows the \"Escape\" key to close the picker\n                            case _keyboard2.default.keys.ESCAPE:\n                                _this.escape();\n                                event.preventDefault();\n                                break;\n                            default:\n                        }\n                    });\n                    this.select.addEventListener(\"change\", this.update.bind(this));\n                }\n                _createClass(Picker, [\n                    {\n                        key: \"togglePicker\",\n                        value: function togglePicker() {\n                            this.container.classList.toggle(\"ql-expanded\");\n                            // Toggle aria-expanded and aria-hidden to make the picker accessible\n                            toggleAriaAttribute(this.label, \"aria-expanded\");\n                            toggleAriaAttribute(this.options, \"aria-hidden\");\n                        }\n                    },\n                    {\n                        key: \"buildItem\",\n                        value: function buildItem(option) {\n                            var _this2 = this;\n                            var item = document.createElement(\"span\");\n                            item.tabIndex = \"0\";\n                            item.setAttribute(\"role\", \"button\");\n                            item.classList.add(\"ql-picker-item\");\n                            if (option.hasAttribute(\"value\")) {\n                                item.setAttribute(\"data-value\", option.getAttribute(\"value\"));\n                            }\n                            if (option.textContent) {\n                                item.setAttribute(\"data-label\", option.textContent);\n                            }\n                            item.addEventListener(\"click\", function() {\n                                _this2.selectItem(item, true);\n                            });\n                            item.addEventListener(\"keydown\", function(event) {\n                                switch(event.keyCode){\n                                    // Allows the \"Enter\" key to select an item\n                                    case _keyboard2.default.keys.ENTER:\n                                        _this2.selectItem(item, true);\n                                        event.preventDefault();\n                                        break;\n                                    // Allows the \"Escape\" key to close the picker\n                                    case _keyboard2.default.keys.ESCAPE:\n                                        _this2.escape();\n                                        event.preventDefault();\n                                        break;\n                                    default:\n                                }\n                            });\n                            return item;\n                        }\n                    },\n                    {\n                        key: \"buildLabel\",\n                        value: function buildLabel() {\n                            var label = document.createElement(\"span\");\n                            label.classList.add(\"ql-picker-label\");\n                            label.innerHTML = _dropdown2.default;\n                            label.tabIndex = \"0\";\n                            label.setAttribute(\"role\", \"button\");\n                            label.setAttribute(\"aria-expanded\", \"false\");\n                            this.container.appendChild(label);\n                            return label;\n                        }\n                    },\n                    {\n                        key: \"buildOptions\",\n                        value: function buildOptions() {\n                            var _this3 = this;\n                            var options = document.createElement(\"span\");\n                            options.classList.add(\"ql-picker-options\");\n                            // Don't want screen readers to read this until options are visible\n                            options.setAttribute(\"aria-hidden\", \"true\");\n                            options.tabIndex = \"-1\";\n                            // Need a unique id for aria-controls\n                            options.id = \"ql-picker-options-\" + optionsCounter;\n                            optionsCounter += 1;\n                            this.label.setAttribute(\"aria-controls\", options.id);\n                            this.options = options;\n                            [].slice.call(this.select.options).forEach(function(option) {\n                                var item = _this3.buildItem(option);\n                                options.appendChild(item);\n                                if (option.selected === true) {\n                                    _this3.selectItem(item);\n                                }\n                            });\n                            this.container.appendChild(options);\n                        }\n                    },\n                    {\n                        key: \"buildPicker\",\n                        value: function buildPicker() {\n                            var _this4 = this;\n                            [].slice.call(this.select.attributes).forEach(function(item) {\n                                _this4.container.setAttribute(item.name, item.value);\n                            });\n                            this.container.classList.add(\"ql-picker\");\n                            this.label = this.buildLabel();\n                            this.buildOptions();\n                        }\n                    },\n                    {\n                        key: \"escape\",\n                        value: function escape() {\n                            var _this5 = this;\n                            // Close menu and return focus to trigger label\n                            this.close();\n                            // Need setTimeout for accessibility to ensure that the browser executes\n                            // focus on the next process thread and after any DOM content changes\n                            setTimeout(function() {\n                                return _this5.label.focus();\n                            }, 1);\n                        }\n                    },\n                    {\n                        key: \"close\",\n                        value: function close() {\n                            this.container.classList.remove(\"ql-expanded\");\n                            this.label.setAttribute(\"aria-expanded\", \"false\");\n                            this.options.setAttribute(\"aria-hidden\", \"true\");\n                        }\n                    },\n                    {\n                        key: \"selectItem\",\n                        value: function selectItem(item) {\n                            var trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                            var selected = this.container.querySelector(\".ql-selected\");\n                            if (item === selected) return;\n                            if (selected != null) {\n                                selected.classList.remove(\"ql-selected\");\n                            }\n                            if (item == null) return;\n                            item.classList.add(\"ql-selected\");\n                            this.select.selectedIndex = [].indexOf.call(item.parentNode.children, item);\n                            if (item.hasAttribute(\"data-value\")) {\n                                this.label.setAttribute(\"data-value\", item.getAttribute(\"data-value\"));\n                            } else {\n                                this.label.removeAttribute(\"data-value\");\n                            }\n                            if (item.hasAttribute(\"data-label\")) {\n                                this.label.setAttribute(\"data-label\", item.getAttribute(\"data-label\"));\n                            } else {\n                                this.label.removeAttribute(\"data-label\");\n                            }\n                            if (trigger) {\n                                if (typeof Event === \"function\") {\n                                    this.select.dispatchEvent(new Event(\"change\"));\n                                } else if ((typeof Event === \"undefined\" ? \"undefined\" : _typeof(Event)) === \"object\") {\n                                    // IE11\n                                    var event = document.createEvent(\"Event\");\n                                    event.initEvent(\"change\", true, true);\n                                    this.select.dispatchEvent(event);\n                                }\n                                this.close();\n                            }\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update() {\n                            var option = void 0;\n                            if (this.select.selectedIndex > -1) {\n                                var item = this.container.querySelector(\".ql-picker-options\").children[this.select.selectedIndex];\n                                option = this.select.options[this.select.selectedIndex];\n                                this.selectItem(item);\n                            } else {\n                                this.selectItem(null);\n                            }\n                            var isActive = option != null && option !== this.select.querySelector(\"option[selected]\");\n                            this.label.classList.toggle(\"ql-active\", isActive);\n                        }\n                    }\n                ]);\n                return Picker;\n            }();\n            exports1.default = Picker;\n        /***/ },\n        /* 29 */ /***/ function(module1, exports1, __nested_webpack_require_316172__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _parchment = __nested_webpack_require_316172__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_316172__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _block = __nested_webpack_require_316172__(4);\n            var _block2 = _interopRequireDefault(_block);\n            var _break = __nested_webpack_require_316172__(16);\n            var _break2 = _interopRequireDefault(_break);\n            var _container = __nested_webpack_require_316172__(25);\n            var _container2 = _interopRequireDefault(_container);\n            var _cursor = __nested_webpack_require_316172__(24);\n            var _cursor2 = _interopRequireDefault(_cursor);\n            var _embed = __nested_webpack_require_316172__(35);\n            var _embed2 = _interopRequireDefault(_embed);\n            var _inline = __nested_webpack_require_316172__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            var _scroll = __nested_webpack_require_316172__(22);\n            var _scroll2 = _interopRequireDefault(_scroll);\n            var _text = __nested_webpack_require_316172__(7);\n            var _text2 = _interopRequireDefault(_text);\n            var _clipboard = __nested_webpack_require_316172__(55);\n            var _clipboard2 = _interopRequireDefault(_clipboard);\n            var _history = __nested_webpack_require_316172__(42);\n            var _history2 = _interopRequireDefault(_history);\n            var _keyboard = __nested_webpack_require_316172__(23);\n            var _keyboard2 = _interopRequireDefault(_keyboard);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            _quill2.default.register({\n                \"blots/block\": _block2.default,\n                \"blots/block/embed\": _block.BlockEmbed,\n                \"blots/break\": _break2.default,\n                \"blots/container\": _container2.default,\n                \"blots/cursor\": _cursor2.default,\n                \"blots/embed\": _embed2.default,\n                \"blots/inline\": _inline2.default,\n                \"blots/scroll\": _scroll2.default,\n                \"blots/text\": _text2.default,\n                \"modules/clipboard\": _clipboard2.default,\n                \"modules/history\": _history2.default,\n                \"modules/keyboard\": _keyboard2.default\n            });\n            _parchment2.default.register(_block2.default, _break2.default, _cursor2.default, _inline2.default, _scroll2.default, _text2.default);\n            exports1.default = _quill2.default;\n        /***/ },\n        /* 30 */ /***/ function(module1, exports1, __nested_webpack_require_318889__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var Registry = __nested_webpack_require_318889__(1);\n            var ShadowBlot = /** @class */ function() {\n                function ShadowBlot(domNode) {\n                    this.domNode = domNode;\n                    // @ts-ignore\n                    this.domNode[Registry.DATA_KEY] = {\n                        blot: this\n                    };\n                }\n                Object.defineProperty(ShadowBlot.prototype, \"statics\", {\n                    // Hack for accessing inherited static methods\n                    get: function() {\n                        return this.constructor;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                ShadowBlot.create = function(value) {\n                    if (this.tagName == null) {\n                        throw new Registry.ParchmentError(\"Blot definition missing tagName\");\n                    }\n                    var node;\n                    if (Array.isArray(this.tagName)) {\n                        if (typeof value === \"string\") {\n                            value = value.toUpperCase();\n                            if (parseInt(value).toString() === value) {\n                                value = parseInt(value);\n                            }\n                        }\n                        if (typeof value === \"number\") {\n                            node = document.createElement(this.tagName[value - 1]);\n                        } else if (this.tagName.indexOf(value) > -1) {\n                            node = document.createElement(value);\n                        } else {\n                            node = document.createElement(this.tagName[0]);\n                        }\n                    } else {\n                        node = document.createElement(this.tagName);\n                    }\n                    if (this.className) {\n                        node.classList.add(this.className);\n                    }\n                    return node;\n                };\n                ShadowBlot.prototype.attach = function() {\n                    if (this.parent != null) {\n                        this.scroll = this.parent.scroll;\n                    }\n                };\n                ShadowBlot.prototype.clone = function() {\n                    var domNode = this.domNode.cloneNode(false);\n                    return Registry.create(domNode);\n                };\n                ShadowBlot.prototype.detach = function() {\n                    if (this.parent != null) this.parent.removeChild(this);\n                    // @ts-ignore\n                    delete this.domNode[Registry.DATA_KEY];\n                };\n                ShadowBlot.prototype.deleteAt = function(index, length) {\n                    var blot = this.isolate(index, length);\n                    blot.remove();\n                };\n                ShadowBlot.prototype.formatAt = function(index, length, name, value) {\n                    var blot = this.isolate(index, length);\n                    if (Registry.query(name, Registry.Scope.BLOT) != null && value) {\n                        blot.wrap(name, value);\n                    } else if (Registry.query(name, Registry.Scope.ATTRIBUTE) != null) {\n                        var parent = Registry.create(this.statics.scope);\n                        blot.wrap(parent);\n                        parent.format(name, value);\n                    }\n                };\n                ShadowBlot.prototype.insertAt = function(index, value, def) {\n                    var blot = def == null ? Registry.create(\"text\", value) : Registry.create(value, def);\n                    var ref = this.split(index);\n                    this.parent.insertBefore(blot, ref);\n                };\n                ShadowBlot.prototype.insertInto = function(parentBlot, refBlot) {\n                    if (refBlot === void 0) {\n                        refBlot = null;\n                    }\n                    if (this.parent != null) {\n                        this.parent.children.remove(this);\n                    }\n                    var refDomNode = null;\n                    parentBlot.children.insertBefore(this, refBlot);\n                    if (refBlot != null) {\n                        refDomNode = refBlot.domNode;\n                    }\n                    if (this.domNode.parentNode != parentBlot.domNode || this.domNode.nextSibling != refDomNode) {\n                        parentBlot.domNode.insertBefore(this.domNode, refDomNode);\n                    }\n                    this.parent = parentBlot;\n                    this.attach();\n                };\n                ShadowBlot.prototype.isolate = function(index, length) {\n                    var target = this.split(index);\n                    target.split(length);\n                    return target;\n                };\n                ShadowBlot.prototype.length = function() {\n                    return 1;\n                };\n                ShadowBlot.prototype.offset = function(root) {\n                    if (root === void 0) {\n                        root = this.parent;\n                    }\n                    if (this.parent == null || this == root) return 0;\n                    return this.parent.children.offset(this) + this.parent.offset(root);\n                };\n                ShadowBlot.prototype.optimize = function(context) {\n                    // TODO clean up once we use WeakMap\n                    // @ts-ignore\n                    if (this.domNode[Registry.DATA_KEY] != null) {\n                        // @ts-ignore\n                        delete this.domNode[Registry.DATA_KEY].mutations;\n                    }\n                };\n                ShadowBlot.prototype.remove = function() {\n                    if (this.domNode.parentNode != null) {\n                        this.domNode.parentNode.removeChild(this.domNode);\n                    }\n                    this.detach();\n                };\n                ShadowBlot.prototype.replace = function(target) {\n                    if (target.parent == null) return;\n                    target.parent.insertBefore(this, target.next);\n                    target.remove();\n                };\n                ShadowBlot.prototype.replaceWith = function(name, value) {\n                    var replacement = typeof name === \"string\" ? Registry.create(name, value) : name;\n                    replacement.replace(this);\n                    return replacement;\n                };\n                ShadowBlot.prototype.split = function(index, force) {\n                    return index === 0 ? this : this.next;\n                };\n                ShadowBlot.prototype.update = function(mutations, context) {\n                // Nothing to do by default\n                };\n                ShadowBlot.prototype.wrap = function(name, value) {\n                    var wrapper = typeof name === \"string\" ? Registry.create(name, value) : name;\n                    if (this.parent != null) {\n                        this.parent.insertBefore(wrapper, this.next);\n                    }\n                    wrapper.appendChild(this);\n                    return wrapper;\n                };\n                ShadowBlot.blotName = \"abstract\";\n                return ShadowBlot;\n            }();\n            exports1.default = ShadowBlot;\n        /***/ },\n        /* 31 */ /***/ function(module1, exports1, __nested_webpack_require_326422__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var attributor_1 = __nested_webpack_require_326422__(12);\n            var class_1 = __nested_webpack_require_326422__(32);\n            var style_1 = __nested_webpack_require_326422__(33);\n            var Registry = __nested_webpack_require_326422__(1);\n            var AttributorStore = /** @class */ function() {\n                function AttributorStore(domNode) {\n                    this.attributes = {};\n                    this.domNode = domNode;\n                    this.build();\n                }\n                AttributorStore.prototype.attribute = function(attribute, value) {\n                    // verb\n                    if (value) {\n                        if (attribute.add(this.domNode, value)) {\n                            if (attribute.value(this.domNode) != null) {\n                                this.attributes[attribute.attrName] = attribute;\n                            } else {\n                                delete this.attributes[attribute.attrName];\n                            }\n                        }\n                    } else {\n                        attribute.remove(this.domNode);\n                        delete this.attributes[attribute.attrName];\n                    }\n                };\n                AttributorStore.prototype.build = function() {\n                    var _this = this;\n                    this.attributes = {};\n                    var attributes = attributor_1.default.keys(this.domNode);\n                    var classes = class_1.default.keys(this.domNode);\n                    var styles = style_1.default.keys(this.domNode);\n                    attributes.concat(classes).concat(styles).forEach(function(name) {\n                        var attr = Registry.query(name, Registry.Scope.ATTRIBUTE);\n                        if (attr instanceof attributor_1.default) {\n                            _this.attributes[attr.attrName] = attr;\n                        }\n                    });\n                };\n                AttributorStore.prototype.copy = function(target) {\n                    var _this = this;\n                    Object.keys(this.attributes).forEach(function(key) {\n                        var value = _this.attributes[key].value(_this.domNode);\n                        target.format(key, value);\n                    });\n                };\n                AttributorStore.prototype.move = function(target) {\n                    var _this = this;\n                    this.copy(target);\n                    Object.keys(this.attributes).forEach(function(key) {\n                        _this.attributes[key].remove(_this.domNode);\n                    });\n                    this.attributes = {};\n                };\n                AttributorStore.prototype.values = function() {\n                    var _this = this;\n                    return Object.keys(this.attributes).reduce(function(attributes, name) {\n                        attributes[name] = _this.attributes[name].value(_this.domNode);\n                        return attributes;\n                    }, {});\n                };\n                return AttributorStore;\n            }();\n            exports1.default = AttributorStore;\n        /***/ },\n        /* 32 */ /***/ function(module1, exports1, __nested_webpack_require_329767__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var attributor_1 = __nested_webpack_require_329767__(12);\n            function match(node, prefix) {\n                var className = node.getAttribute(\"class\") || \"\";\n                return className.split(/\\s+/).filter(function(name) {\n                    return name.indexOf(prefix + \"-\") === 0;\n                });\n            }\n            var ClassAttributor = /** @class */ function(_super) {\n                __extends(ClassAttributor, _super);\n                function ClassAttributor() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                ClassAttributor.keys = function(node) {\n                    return (node.getAttribute(\"class\") || \"\").split(/\\s+/).map(function(name) {\n                        return name.split(\"-\").slice(0, -1).join(\"-\");\n                    });\n                };\n                ClassAttributor.prototype.add = function(node, value) {\n                    if (!this.canAdd(node, value)) return false;\n                    this.remove(node);\n                    node.classList.add(this.keyName + \"-\" + value);\n                    return true;\n                };\n                ClassAttributor.prototype.remove = function(node) {\n                    var matches = match(node, this.keyName);\n                    matches.forEach(function(name) {\n                        node.classList.remove(name);\n                    });\n                    if (node.classList.length === 0) {\n                        node.removeAttribute(\"class\");\n                    }\n                };\n                ClassAttributor.prototype.value = function(node) {\n                    var result = match(node, this.keyName)[0] || \"\";\n                    var value = result.slice(this.keyName.length + 1); // +1 for hyphen\n                    return this.canAdd(node, value) ? value : \"\";\n                };\n                return ClassAttributor;\n            }(attributor_1.default);\n            exports1.default = ClassAttributor;\n        /***/ },\n        /* 33 */ /***/ function(module1, exports1, __nested_webpack_require_332706__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var attributor_1 = __nested_webpack_require_332706__(12);\n            function camelize(name) {\n                var parts = name.split(\"-\");\n                var rest = parts.slice(1).map(function(part) {\n                    return part[0].toUpperCase() + part.slice(1);\n                }).join(\"\");\n                return parts[0] + rest;\n            }\n            var StyleAttributor = /** @class */ function(_super) {\n                __extends(StyleAttributor, _super);\n                function StyleAttributor() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                StyleAttributor.keys = function(node) {\n                    return (node.getAttribute(\"style\") || \"\").split(\";\").map(function(value) {\n                        var arr = value.split(\":\");\n                        return arr[0].trim();\n                    });\n                };\n                StyleAttributor.prototype.add = function(node, value) {\n                    if (!this.canAdd(node, value)) return false;\n                    // @ts-ignore\n                    node.style[camelize(this.keyName)] = value;\n                    return true;\n                };\n                StyleAttributor.prototype.remove = function(node) {\n                    // @ts-ignore\n                    node.style[camelize(this.keyName)] = \"\";\n                    if (!node.getAttribute(\"style\")) {\n                        node.removeAttribute(\"style\");\n                    }\n                };\n                StyleAttributor.prototype.value = function(node) {\n                    // @ts-ignore\n                    var value = node.style[camelize(this.keyName)];\n                    return this.canAdd(node, value) ? value : \"\";\n                };\n                return StyleAttributor;\n            }(attributor_1.default);\n            exports1.default = StyleAttributor;\n        /***/ },\n        /* 34 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var Theme = function() {\n                function Theme(quill, options) {\n                    _classCallCheck(this, Theme);\n                    this.quill = quill;\n                    this.options = options;\n                    this.modules = {};\n                }\n                _createClass(Theme, [\n                    {\n                        key: \"init\",\n                        value: function init() {\n                            var _this = this;\n                            Object.keys(this.options.modules).forEach(function(name) {\n                                if (_this.modules[name] == null) {\n                                    _this.addModule(name);\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"addModule\",\n                        value: function addModule(name) {\n                            var moduleClass = this.quill.constructor.import(\"modules/\" + name);\n                            this.modules[name] = new moduleClass(this.quill, this.options.modules[name] || {});\n                            return this.modules[name];\n                        }\n                    }\n                ]);\n                return Theme;\n            }();\n            Theme.DEFAULTS = {\n                modules: {}\n            };\n            Theme.themes = {\n                \"default\": Theme\n            };\n            exports1.default = Theme;\n        /***/ },\n        /* 35 */ /***/ function(module1, exports1, __nested_webpack_require_338338__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_338338__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _text = __nested_webpack_require_338338__(7);\n            var _text2 = _interopRequireDefault(_text);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var GUARD_TEXT = \"\\uFEFF\";\n            var Embed = function(_Parchment$Embed) {\n                _inherits(Embed, _Parchment$Embed);\n                function Embed(node) {\n                    _classCallCheck(this, Embed);\n                    var _this = _possibleConstructorReturn(this, (Embed.__proto__ || Object.getPrototypeOf(Embed)).call(this, node));\n                    _this.contentNode = document.createElement(\"span\");\n                    _this.contentNode.setAttribute(\"contenteditable\", false);\n                    [].slice.call(_this.domNode.childNodes).forEach(function(childNode) {\n                        _this.contentNode.appendChild(childNode);\n                    });\n                    _this.leftGuard = document.createTextNode(GUARD_TEXT);\n                    _this.rightGuard = document.createTextNode(GUARD_TEXT);\n                    _this.domNode.appendChild(_this.leftGuard);\n                    _this.domNode.appendChild(_this.contentNode);\n                    _this.domNode.appendChild(_this.rightGuard);\n                    return _this;\n                }\n                _createClass(Embed, [\n                    {\n                        key: \"index\",\n                        value: function index(node, offset) {\n                            if (node === this.leftGuard) return 0;\n                            if (node === this.rightGuard) return 1;\n                            return _get(Embed.prototype.__proto__ || Object.getPrototypeOf(Embed.prototype), \"index\", this).call(this, node, offset);\n                        }\n                    },\n                    {\n                        key: \"restore\",\n                        value: function restore(node) {\n                            var range = void 0, textNode = void 0;\n                            var text = node.data.split(GUARD_TEXT).join(\"\");\n                            if (node === this.leftGuard) {\n                                if (this.prev instanceof _text2.default) {\n                                    var prevLength = this.prev.length();\n                                    this.prev.insertAt(prevLength, text);\n                                    range = {\n                                        startNode: this.prev.domNode,\n                                        startOffset: prevLength + text.length\n                                    };\n                                } else {\n                                    textNode = document.createTextNode(text);\n                                    this.parent.insertBefore(_parchment2.default.create(textNode), this);\n                                    range = {\n                                        startNode: textNode,\n                                        startOffset: text.length\n                                    };\n                                }\n                            } else if (node === this.rightGuard) {\n                                if (this.next instanceof _text2.default) {\n                                    this.next.insertAt(0, text);\n                                    range = {\n                                        startNode: this.next.domNode,\n                                        startOffset: text.length\n                                    };\n                                } else {\n                                    textNode = document.createTextNode(text);\n                                    this.parent.insertBefore(_parchment2.default.create(textNode), this.next);\n                                    range = {\n                                        startNode: textNode,\n                                        startOffset: text.length\n                                    };\n                                }\n                            }\n                            node.data = GUARD_TEXT;\n                            return range;\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update(mutations, context) {\n                            var _this2 = this;\n                            mutations.forEach(function(mutation) {\n                                if (mutation.type === \"characterData\" && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {\n                                    var range = _this2.restore(mutation.target);\n                                    if (range) context.range = range;\n                                }\n                            });\n                        }\n                    }\n                ]);\n                return Embed;\n            }(_parchment2.default.Embed);\n            exports1.default = Embed;\n        /***/ },\n        /* 36 */ /***/ function(module1, exports1, __nested_webpack_require_346713__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.AlignStyle = exports1.AlignClass = exports1.AlignAttribute = undefined;\n            var _parchment = __nested_webpack_require_346713__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            var config = {\n                scope: _parchment2.default.Scope.BLOCK,\n                whitelist: [\n                    \"right\",\n                    \"center\",\n                    \"justify\"\n                ]\n            };\n            var AlignAttribute = new _parchment2.default.Attributor.Attribute(\"align\", \"align\", config);\n            var AlignClass = new _parchment2.default.Attributor.Class(\"align\", \"ql-align\", config);\n            var AlignStyle = new _parchment2.default.Attributor.Style(\"align\", \"text-align\", config);\n            exports1.AlignAttribute = AlignAttribute;\n            exports1.AlignClass = AlignClass;\n            exports1.AlignStyle = AlignStyle;\n        /***/ },\n        /* 37 */ /***/ function(module1, exports1, __nested_webpack_require_348005__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.BackgroundStyle = exports1.BackgroundClass = undefined;\n            var _parchment = __nested_webpack_require_348005__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _color = __nested_webpack_require_348005__(26);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            var BackgroundClass = new _parchment2.default.Attributor.Class(\"background\", \"ql-bg\", {\n                scope: _parchment2.default.Scope.INLINE\n            });\n            var BackgroundStyle = new _color.ColorAttributor(\"background\", \"background-color\", {\n                scope: _parchment2.default.Scope.INLINE\n            });\n            exports1.BackgroundClass = BackgroundClass;\n            exports1.BackgroundStyle = BackgroundStyle;\n        /***/ },\n        /* 38 */ /***/ function(module1, exports1, __nested_webpack_require_349097__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.DirectionStyle = exports1.DirectionClass = exports1.DirectionAttribute = undefined;\n            var _parchment = __nested_webpack_require_349097__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            var config = {\n                scope: _parchment2.default.Scope.BLOCK,\n                whitelist: [\n                    \"rtl\"\n                ]\n            };\n            var DirectionAttribute = new _parchment2.default.Attributor.Attribute(\"direction\", \"dir\", config);\n            var DirectionClass = new _parchment2.default.Attributor.Class(\"direction\", \"ql-direction\", config);\n            var DirectionStyle = new _parchment2.default.Attributor.Style(\"direction\", \"direction\", config);\n            exports1.DirectionAttribute = DirectionAttribute;\n            exports1.DirectionClass = DirectionClass;\n            exports1.DirectionStyle = DirectionStyle;\n        /***/ },\n        /* 39 */ /***/ function(module1, exports1, __nested_webpack_require_350387__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.FontClass = exports1.FontStyle = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_350387__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var config = {\n                scope: _parchment2.default.Scope.INLINE,\n                whitelist: [\n                    \"serif\",\n                    \"monospace\"\n                ]\n            };\n            var FontClass = new _parchment2.default.Attributor.Class(\"font\", \"ql-font\", config);\n            var FontStyleAttributor = function(_Parchment$Attributor) {\n                _inherits(FontStyleAttributor, _Parchment$Attributor);\n                function FontStyleAttributor() {\n                    _classCallCheck(this, FontStyleAttributor);\n                    return _possibleConstructorReturn(this, (FontStyleAttributor.__proto__ || Object.getPrototypeOf(FontStyleAttributor)).apply(this, arguments));\n                }\n                _createClass(FontStyleAttributor, [\n                    {\n                        key: \"value\",\n                        value: function value(node) {\n                            return _get(FontStyleAttributor.prototype.__proto__ || Object.getPrototypeOf(FontStyleAttributor.prototype), \"value\", this).call(this, node).replace(/[\"']/g, \"\");\n                        }\n                    }\n                ]);\n                return FontStyleAttributor;\n            }(_parchment2.default.Attributor.Style);\n            var FontStyle = new FontStyleAttributor(\"font\", \"font-family\", config);\n            exports1.FontStyle = FontStyle;\n            exports1.FontClass = FontClass;\n        /***/ },\n        /* 40 */ /***/ function(module1, exports1, __nested_webpack_require_355453__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.SizeStyle = exports1.SizeClass = undefined;\n            var _parchment = __nested_webpack_require_355453__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            var SizeClass = new _parchment2.default.Attributor.Class(\"size\", \"ql-size\", {\n                scope: _parchment2.default.Scope.INLINE,\n                whitelist: [\n                    \"small\",\n                    \"large\",\n                    \"huge\"\n                ]\n            });\n            var SizeStyle = new _parchment2.default.Attributor.Style(\"size\", \"font-size\", {\n                scope: _parchment2.default.Scope.INLINE,\n                whitelist: [\n                    \"10px\",\n                    \"18px\",\n                    \"32px\"\n                ]\n            });\n            exports1.SizeClass = SizeClass;\n            exports1.SizeStyle = SizeStyle;\n        /***/ },\n        /* 41 */ /***/ function(module1, exports1, __nested_webpack_require_356708__) {\n            \"use strict\";\n            module1.exports = {\n                \"align\": {\n                    \"\": __nested_webpack_require_356708__(76),\n                    \"center\": __nested_webpack_require_356708__(77),\n                    \"right\": __nested_webpack_require_356708__(78),\n                    \"justify\": __nested_webpack_require_356708__(79)\n                },\n                \"background\": __nested_webpack_require_356708__(80),\n                \"blockquote\": __nested_webpack_require_356708__(81),\n                \"bold\": __nested_webpack_require_356708__(82),\n                \"clean\": __nested_webpack_require_356708__(83),\n                \"code\": __nested_webpack_require_356708__(58),\n                \"code-block\": __nested_webpack_require_356708__(58),\n                \"color\": __nested_webpack_require_356708__(84),\n                \"direction\": {\n                    \"\": __nested_webpack_require_356708__(85),\n                    \"rtl\": __nested_webpack_require_356708__(86)\n                },\n                \"float\": {\n                    \"center\": __nested_webpack_require_356708__(87),\n                    \"full\": __nested_webpack_require_356708__(88),\n                    \"left\": __nested_webpack_require_356708__(89),\n                    \"right\": __nested_webpack_require_356708__(90)\n                },\n                \"formula\": __nested_webpack_require_356708__(91),\n                \"header\": {\n                    \"1\": __nested_webpack_require_356708__(92),\n                    \"2\": __nested_webpack_require_356708__(93)\n                },\n                \"italic\": __nested_webpack_require_356708__(94),\n                \"image\": __nested_webpack_require_356708__(95),\n                \"indent\": {\n                    \"+1\": __nested_webpack_require_356708__(96),\n                    \"-1\": __nested_webpack_require_356708__(97)\n                },\n                \"link\": __nested_webpack_require_356708__(98),\n                \"list\": {\n                    \"ordered\": __nested_webpack_require_356708__(99),\n                    \"bullet\": __nested_webpack_require_356708__(100),\n                    \"check\": __nested_webpack_require_356708__(101)\n                },\n                \"script\": {\n                    \"sub\": __nested_webpack_require_356708__(102),\n                    \"super\": __nested_webpack_require_356708__(103)\n                },\n                \"strike\": __nested_webpack_require_356708__(104),\n                \"underline\": __nested_webpack_require_356708__(105),\n                \"video\": __nested_webpack_require_356708__(106)\n            };\n        /***/ },\n        /* 42 */ /***/ function(module1, exports1, __nested_webpack_require_358922__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.getLastChangeIndex = exports1.default = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _parchment = __nested_webpack_require_358922__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_358922__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _module = __nested_webpack_require_358922__(9);\n            var _module2 = _interopRequireDefault(_module);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var History = function(_Module) {\n                _inherits(History, _Module);\n                function History(quill, options) {\n                    _classCallCheck(this, History);\n                    var _this = _possibleConstructorReturn(this, (History.__proto__ || Object.getPrototypeOf(History)).call(this, quill, options));\n                    _this.lastRecorded = 0;\n                    _this.ignoreChange = false;\n                    _this.clear();\n                    _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function(eventName, delta, oldDelta, source) {\n                        if (eventName !== _quill2.default.events.TEXT_CHANGE || _this.ignoreChange) return;\n                        if (!_this.options.userOnly || source === _quill2.default.sources.USER) {\n                            _this.record(delta, oldDelta);\n                        } else {\n                            _this.transform(delta);\n                        }\n                    });\n                    _this.quill.keyboard.addBinding({\n                        key: \"Z\",\n                        shortKey: true\n                    }, _this.undo.bind(_this));\n                    _this.quill.keyboard.addBinding({\n                        key: \"Z\",\n                        shortKey: true,\n                        shiftKey: true\n                    }, _this.redo.bind(_this));\n                    if (/Win/i.test(navigator.platform)) {\n                        _this.quill.keyboard.addBinding({\n                            key: \"Y\",\n                            shortKey: true\n                        }, _this.redo.bind(_this));\n                    }\n                    return _this;\n                }\n                _createClass(History, [\n                    {\n                        key: \"change\",\n                        value: function change(source, dest) {\n                            if (this.stack[source].length === 0) return;\n                            var delta = this.stack[source].pop();\n                            this.stack[dest].push(delta);\n                            this.lastRecorded = 0;\n                            this.ignoreChange = true;\n                            this.quill.updateContents(delta[source], _quill2.default.sources.USER);\n                            this.ignoreChange = false;\n                            var index = getLastChangeIndex(delta[source]);\n                            this.quill.setSelection(index);\n                        }\n                    },\n                    {\n                        key: \"clear\",\n                        value: function clear() {\n                            this.stack = {\n                                undo: [],\n                                redo: []\n                            };\n                        }\n                    },\n                    {\n                        key: \"cutoff\",\n                        value: function cutoff() {\n                            this.lastRecorded = 0;\n                        }\n                    },\n                    {\n                        key: \"record\",\n                        value: function record(changeDelta, oldDelta) {\n                            if (changeDelta.ops.length === 0) return;\n                            this.stack.redo = [];\n                            var undoDelta = this.quill.getContents().diff(oldDelta);\n                            var timestamp = Date.now();\n                            if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {\n                                var delta = this.stack.undo.pop();\n                                undoDelta = undoDelta.compose(delta.undo);\n                                changeDelta = delta.redo.compose(changeDelta);\n                            } else {\n                                this.lastRecorded = timestamp;\n                            }\n                            this.stack.undo.push({\n                                redo: changeDelta,\n                                undo: undoDelta\n                            });\n                            if (this.stack.undo.length > this.options.maxStack) {\n                                this.stack.undo.shift();\n                            }\n                        }\n                    },\n                    {\n                        key: \"redo\",\n                        value: function redo() {\n                            this.change(\"redo\", \"undo\");\n                        }\n                    },\n                    {\n                        key: \"transform\",\n                        value: function transform(delta) {\n                            this.stack.undo.forEach(function(change) {\n                                change.undo = delta.transform(change.undo, true);\n                                change.redo = delta.transform(change.redo, true);\n                            });\n                            this.stack.redo.forEach(function(change) {\n                                change.undo = delta.transform(change.undo, true);\n                                change.redo = delta.transform(change.redo, true);\n                            });\n                        }\n                    },\n                    {\n                        key: \"undo\",\n                        value: function undo() {\n                            this.change(\"undo\", \"redo\");\n                        }\n                    }\n                ]);\n                return History;\n            }(_module2.default);\n            History.DEFAULTS = {\n                delay: 1000,\n                maxStack: 100,\n                userOnly: false\n            };\n            function endsWithNewlineChange(delta) {\n                var lastOp = delta.ops[delta.ops.length - 1];\n                if (lastOp == null) return false;\n                if (lastOp.insert != null) {\n                    return typeof lastOp.insert === \"string\" && lastOp.insert.endsWith(\"\\n\");\n                }\n                if (lastOp.attributes != null) {\n                    return Object.keys(lastOp.attributes).some(function(attr) {\n                        return _parchment2.default.query(attr, _parchment2.default.Scope.BLOCK) != null;\n                    });\n                }\n                return false;\n            }\n            function getLastChangeIndex(delta) {\n                var deleteLength = delta.reduce(function(length, op) {\n                    length += op.delete || 0;\n                    return length;\n                }, 0);\n                var changeIndex = delta.length() - deleteLength;\n                if (endsWithNewlineChange(delta)) {\n                    changeIndex -= 1;\n                }\n                return changeIndex;\n            }\n            exports1.default = History;\n            exports1.getLastChangeIndex = getLastChangeIndex;\n        /***/ },\n        /* 43 */ /***/ function(module1, exports1, __nested_webpack_require_368758__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.BaseTooltip = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _extend = __nested_webpack_require_368758__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _quillDelta = __nested_webpack_require_368758__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _emitter = __nested_webpack_require_368758__(8);\n            var _emitter2 = _interopRequireDefault(_emitter);\n            var _keyboard = __nested_webpack_require_368758__(23);\n            var _keyboard2 = _interopRequireDefault(_keyboard);\n            var _theme = __nested_webpack_require_368758__(34);\n            var _theme2 = _interopRequireDefault(_theme);\n            var _colorPicker = __nested_webpack_require_368758__(59);\n            var _colorPicker2 = _interopRequireDefault(_colorPicker);\n            var _iconPicker = __nested_webpack_require_368758__(60);\n            var _iconPicker2 = _interopRequireDefault(_iconPicker);\n            var _picker = __nested_webpack_require_368758__(28);\n            var _picker2 = _interopRequireDefault(_picker);\n            var _tooltip = __nested_webpack_require_368758__(61);\n            var _tooltip2 = _interopRequireDefault(_tooltip);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ALIGNS = [\n                false,\n                \"center\",\n                \"right\",\n                \"justify\"\n            ];\n            var COLORS = [\n                \"#000000\",\n                \"#e60000\",\n                \"#ff9900\",\n                \"#ffff00\",\n                \"#008a00\",\n                \"#0066cc\",\n                \"#9933ff\",\n                \"#ffffff\",\n                \"#facccc\",\n                \"#ffebcc\",\n                \"#ffffcc\",\n                \"#cce8cc\",\n                \"#cce0f5\",\n                \"#ebd6ff\",\n                \"#bbbbbb\",\n                \"#f06666\",\n                \"#ffc266\",\n                \"#ffff66\",\n                \"#66b966\",\n                \"#66a3e0\",\n                \"#c285ff\",\n                \"#888888\",\n                \"#a10000\",\n                \"#b26b00\",\n                \"#b2b200\",\n                \"#006100\",\n                \"#0047b2\",\n                \"#6b24b2\",\n                \"#444444\",\n                \"#5c0000\",\n                \"#663d00\",\n                \"#666600\",\n                \"#003700\",\n                \"#002966\",\n                \"#3d1466\"\n            ];\n            var FONTS = [\n                false,\n                \"serif\",\n                \"monospace\"\n            ];\n            var HEADERS = [\n                \"1\",\n                \"2\",\n                \"3\",\n                false\n            ];\n            var SIZES = [\n                \"small\",\n                false,\n                \"large\",\n                \"huge\"\n            ];\n            var BaseTheme = function(_Theme) {\n                _inherits(BaseTheme, _Theme);\n                function BaseTheme(quill, options) {\n                    _classCallCheck(this, BaseTheme);\n                    var _this = _possibleConstructorReturn(this, (BaseTheme.__proto__ || Object.getPrototypeOf(BaseTheme)).call(this, quill, options));\n                    var listener = function listener(e) {\n                        if (!document.body.contains(quill.root)) {\n                            return document.body.removeEventListener(\"click\", listener);\n                        }\n                        if (_this.tooltip != null && !_this.tooltip.root.contains(e.target) && document.activeElement !== _this.tooltip.textbox && !_this.quill.hasFocus()) {\n                            _this.tooltip.hide();\n                        }\n                        if (_this.pickers != null) {\n                            _this.pickers.forEach(function(picker) {\n                                if (!picker.container.contains(e.target)) {\n                                    picker.close();\n                                }\n                            });\n                        }\n                    };\n                    quill.emitter.listenDOM(\"click\", document.body, listener);\n                    return _this;\n                }\n                _createClass(BaseTheme, [\n                    {\n                        key: \"addModule\",\n                        value: function addModule(name) {\n                            var module1 = _get(BaseTheme.prototype.__proto__ || Object.getPrototypeOf(BaseTheme.prototype), \"addModule\", this).call(this, name);\n                            if (name === \"toolbar\") {\n                                this.extendToolbar(module1);\n                            }\n                            return module1;\n                        }\n                    },\n                    {\n                        key: \"buildButtons\",\n                        value: function buildButtons(buttons, icons) {\n                            buttons.forEach(function(button) {\n                                var className = button.getAttribute(\"class\") || \"\";\n                                className.split(/\\s+/).forEach(function(name) {\n                                    if (!name.startsWith(\"ql-\")) return;\n                                    name = name.slice(\"ql-\".length);\n                                    if (icons[name] == null) return;\n                                    if (name === \"direction\") {\n                                        button.innerHTML = icons[name][\"\"] + icons[name][\"rtl\"];\n                                    } else if (typeof icons[name] === \"string\") {\n                                        button.innerHTML = icons[name];\n                                    } else {\n                                        var value = button.value || \"\";\n                                        if (value != null && icons[name][value]) {\n                                            button.innerHTML = icons[name][value];\n                                        }\n                                    }\n                                });\n                            });\n                        }\n                    },\n                    {\n                        key: \"buildPickers\",\n                        value: function buildPickers(selects, icons) {\n                            var _this2 = this;\n                            this.pickers = selects.map(function(select) {\n                                if (select.classList.contains(\"ql-align\")) {\n                                    if (select.querySelector(\"option\") == null) {\n                                        fillSelect(select, ALIGNS);\n                                    }\n                                    return new _iconPicker2.default(select, icons.align);\n                                } else if (select.classList.contains(\"ql-background\") || select.classList.contains(\"ql-color\")) {\n                                    var format = select.classList.contains(\"ql-background\") ? \"background\" : \"color\";\n                                    if (select.querySelector(\"option\") == null) {\n                                        fillSelect(select, COLORS, format === \"background\" ? \"#ffffff\" : \"#000000\");\n                                    }\n                                    return new _colorPicker2.default(select, icons[format]);\n                                } else {\n                                    if (select.querySelector(\"option\") == null) {\n                                        if (select.classList.contains(\"ql-font\")) {\n                                            fillSelect(select, FONTS);\n                                        } else if (select.classList.contains(\"ql-header\")) {\n                                            fillSelect(select, HEADERS);\n                                        } else if (select.classList.contains(\"ql-size\")) {\n                                            fillSelect(select, SIZES);\n                                        }\n                                    }\n                                    return new _picker2.default(select);\n                                }\n                            });\n                            var update = function update() {\n                                _this2.pickers.forEach(function(picker) {\n                                    picker.update();\n                                });\n                            };\n                            this.quill.on(_emitter2.default.events.EDITOR_CHANGE, update);\n                        }\n                    }\n                ]);\n                return BaseTheme;\n            }(_theme2.default);\n            BaseTheme.DEFAULTS = (0, _extend2.default)(true, {}, _theme2.default.DEFAULTS, {\n                modules: {\n                    toolbar: {\n                        handlers: {\n                            formula: function formula() {\n                                this.quill.theme.tooltip.edit(\"formula\");\n                            },\n                            image: function image() {\n                                var _this3 = this;\n                                var fileInput = this.container.querySelector(\"input.ql-image[type=file]\");\n                                if (fileInput == null) {\n                                    fileInput = document.createElement(\"input\");\n                                    fileInput.setAttribute(\"type\", \"file\");\n                                    fileInput.setAttribute(\"accept\", \"image/png, image/gif, image/jpeg, image/bmp, image/x-icon\");\n                                    fileInput.classList.add(\"ql-image\");\n                                    fileInput.addEventListener(\"change\", function() {\n                                        if (fileInput.files != null && fileInput.files[0] != null) {\n                                            var reader = new FileReader();\n                                            reader.onload = function(e) {\n                                                var range = _this3.quill.getSelection(true);\n                                                _this3.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert({\n                                                    image: e.target.result\n                                                }), _emitter2.default.sources.USER);\n                                                _this3.quill.setSelection(range.index + 1, _emitter2.default.sources.SILENT);\n                                                fileInput.value = \"\";\n                                            };\n                                            reader.readAsDataURL(fileInput.files[0]);\n                                        }\n                                    });\n                                    this.container.appendChild(fileInput);\n                                }\n                                fileInput.click();\n                            },\n                            video: function video() {\n                                this.quill.theme.tooltip.edit(\"video\");\n                            }\n                        }\n                    }\n                }\n            });\n            var BaseTooltip = function(_Tooltip) {\n                _inherits(BaseTooltip, _Tooltip);\n                function BaseTooltip(quill, boundsContainer) {\n                    _classCallCheck(this, BaseTooltip);\n                    var _this4 = _possibleConstructorReturn(this, (BaseTooltip.__proto__ || Object.getPrototypeOf(BaseTooltip)).call(this, quill, boundsContainer));\n                    _this4.textbox = _this4.root.querySelector('input[type=\"text\"]');\n                    _this4.listen();\n                    return _this4;\n                }\n                _createClass(BaseTooltip, [\n                    {\n                        key: \"listen\",\n                        value: function listen() {\n                            var _this5 = this;\n                            this.textbox.addEventListener(\"keydown\", function(event) {\n                                if (_keyboard2.default.match(event, \"enter\")) {\n                                    _this5.save();\n                                    event.preventDefault();\n                                } else if (_keyboard2.default.match(event, \"escape\")) {\n                                    _this5.cancel();\n                                    event.preventDefault();\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"cancel\",\n                        value: function cancel() {\n                            this.hide();\n                        }\n                    },\n                    {\n                        key: \"edit\",\n                        value: function edit() {\n                            var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"link\";\n                            var preview = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n                            this.root.classList.remove(\"ql-hidden\");\n                            this.root.classList.add(\"ql-editing\");\n                            if (preview != null) {\n                                this.textbox.value = preview;\n                            } else if (mode !== this.root.getAttribute(\"data-mode\")) {\n                                this.textbox.value = \"\";\n                            }\n                            this.position(this.quill.getBounds(this.quill.selection.savedRange));\n                            this.textbox.select();\n                            this.textbox.setAttribute(\"placeholder\", this.textbox.getAttribute(\"data-\" + mode) || \"\");\n                            this.root.setAttribute(\"data-mode\", mode);\n                        }\n                    },\n                    {\n                        key: \"restoreFocus\",\n                        value: function restoreFocus() {\n                            var scrollTop = this.quill.scrollingContainer.scrollTop;\n                            this.quill.focus();\n                            this.quill.scrollingContainer.scrollTop = scrollTop;\n                        }\n                    },\n                    {\n                        key: \"save\",\n                        value: function save() {\n                            var value = this.textbox.value;\n                            switch(this.root.getAttribute(\"data-mode\")){\n                                case \"link\":\n                                    {\n                                        var scrollTop = this.quill.root.scrollTop;\n                                        if (this.linkRange) {\n                                            this.quill.formatText(this.linkRange, \"link\", value, _emitter2.default.sources.USER);\n                                            delete this.linkRange;\n                                        } else {\n                                            this.restoreFocus();\n                                            this.quill.format(\"link\", value, _emitter2.default.sources.USER);\n                                        }\n                                        this.quill.root.scrollTop = scrollTop;\n                                        break;\n                                    }\n                                case \"video\":\n                                    {\n                                        value = extractVideoUrl(value);\n                                    }\n                                case \"formula\":\n                                    {\n                                        if (!value) break;\n                                        var range = this.quill.getSelection(true);\n                                        if (range != null) {\n                                            var index = range.index + range.length;\n                                            this.quill.insertEmbed(index, this.root.getAttribute(\"data-mode\"), value, _emitter2.default.sources.USER);\n                                            if (this.root.getAttribute(\"data-mode\") === \"formula\") {\n                                                this.quill.insertText(index + 1, \" \", _emitter2.default.sources.USER);\n                                            }\n                                            this.quill.setSelection(index + 2, _emitter2.default.sources.USER);\n                                        }\n                                        break;\n                                    }\n                                default:\n                            }\n                            this.textbox.value = \"\";\n                            this.hide();\n                        }\n                    }\n                ]);\n                return BaseTooltip;\n            }(_tooltip2.default);\n            function extractVideoUrl(url) {\n                var match = url.match(/^(?:(https?):\\/\\/)?(?:(?:www|m)\\.)?youtube\\.com\\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\\/\\/)?(?:(?:www|m)\\.)?youtu\\.be\\/([a-zA-Z0-9_-]+)/);\n                if (match) {\n                    return (match[1] || \"https\") + \"://www.youtube.com/embed/\" + match[2] + \"?showinfo=0\";\n                }\n                if (match = url.match(/^(?:(https?):\\/\\/)?(?:www\\.)?vimeo\\.com\\/(\\d+)/)) {\n                    // eslint-disable-line no-cond-assign\n                    return (match[1] || \"https\") + \"://player.vimeo.com/video/\" + match[2] + \"/\";\n                }\n                return url;\n            }\n            function fillSelect(select, values) {\n                var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                values.forEach(function(value) {\n                    var option = document.createElement(\"option\");\n                    if (value === defaultValue) {\n                        option.setAttribute(\"selected\", \"selected\");\n                    } else {\n                        option.setAttribute(\"value\", value);\n                    }\n                    select.appendChild(option);\n                });\n            }\n            exports1.BaseTooltip = BaseTooltip;\n            exports1.default = BaseTheme;\n        /***/ },\n        /* 44 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var LinkedList = /** @class */ function() {\n                function LinkedList() {\n                    this.head = this.tail = null;\n                    this.length = 0;\n                }\n                LinkedList.prototype.append = function() {\n                    var nodes = [];\n                    for(var _i = 0; _i < arguments.length; _i++){\n                        nodes[_i] = arguments[_i];\n                    }\n                    this.insertBefore(nodes[0], null);\n                    if (nodes.length > 1) {\n                        this.append.apply(this, nodes.slice(1));\n                    }\n                };\n                LinkedList.prototype.contains = function(node) {\n                    var cur, next = this.iterator();\n                    while(cur = next()){\n                        if (cur === node) return true;\n                    }\n                    return false;\n                };\n                LinkedList.prototype.insertBefore = function(node, refNode) {\n                    if (!node) return;\n                    node.next = refNode;\n                    if (refNode != null) {\n                        node.prev = refNode.prev;\n                        if (refNode.prev != null) {\n                            refNode.prev.next = node;\n                        }\n                        refNode.prev = node;\n                        if (refNode === this.head) {\n                            this.head = node;\n                        }\n                    } else if (this.tail != null) {\n                        this.tail.next = node;\n                        node.prev = this.tail;\n                        this.tail = node;\n                    } else {\n                        node.prev = null;\n                        this.head = this.tail = node;\n                    }\n                    this.length += 1;\n                };\n                LinkedList.prototype.offset = function(target) {\n                    var index = 0, cur = this.head;\n                    while(cur != null){\n                        if (cur === target) return index;\n                        index += cur.length();\n                        cur = cur.next;\n                    }\n                    return -1;\n                };\n                LinkedList.prototype.remove = function(node) {\n                    if (!this.contains(node)) return;\n                    if (node.prev != null) node.prev.next = node.next;\n                    if (node.next != null) node.next.prev = node.prev;\n                    if (node === this.head) this.head = node.next;\n                    if (node === this.tail) this.tail = node.prev;\n                    this.length -= 1;\n                };\n                LinkedList.prototype.iterator = function(curNode) {\n                    if (curNode === void 0) {\n                        curNode = this.head;\n                    }\n                    // TODO use yield when we can\n                    return function() {\n                        var ret = curNode;\n                        if (curNode != null) curNode = curNode.next;\n                        return ret;\n                    };\n                };\n                LinkedList.prototype.find = function(index, inclusive) {\n                    if (inclusive === void 0) {\n                        inclusive = false;\n                    }\n                    var cur, next = this.iterator();\n                    while(cur = next()){\n                        var length = cur.length();\n                        if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0)) {\n                            return [\n                                cur,\n                                index\n                            ];\n                        }\n                        index -= length;\n                    }\n                    return [\n                        null,\n                        0\n                    ];\n                };\n                LinkedList.prototype.forEach = function(callback) {\n                    var cur, next = this.iterator();\n                    while(cur = next()){\n                        callback(cur);\n                    }\n                };\n                LinkedList.prototype.forEachAt = function(index, length, callback) {\n                    if (length <= 0) return;\n                    var _a = this.find(index), startNode = _a[0], offset = _a[1];\n                    var cur, curIndex = index - offset, next = this.iterator(startNode);\n                    while((cur = next()) && curIndex < index + length){\n                        var curLength = cur.length();\n                        if (index > curIndex) {\n                            callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));\n                        } else {\n                            callback(cur, 0, Math.min(curLength, index + length - curIndex));\n                        }\n                        curIndex += curLength;\n                    }\n                };\n                LinkedList.prototype.map = function(callback) {\n                    return this.reduce(function(memo, cur) {\n                        memo.push(callback(cur));\n                        return memo;\n                    }, []);\n                };\n                LinkedList.prototype.reduce = function(callback, memo) {\n                    var cur, next = this.iterator();\n                    while(cur = next()){\n                        memo = callback(memo, cur);\n                    }\n                    return memo;\n                };\n                return LinkedList;\n            }();\n            exports1.default = LinkedList;\n        /***/ },\n        /* 45 */ /***/ function(module1, exports1, __nested_webpack_require_396166__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var container_1 = __nested_webpack_require_396166__(17);\n            var Registry = __nested_webpack_require_396166__(1);\n            var OBSERVER_CONFIG = {\n                attributes: true,\n                characterData: true,\n                characterDataOldValue: true,\n                childList: true,\n                subtree: true\n            };\n            var MAX_OPTIMIZE_ITERATIONS = 100;\n            var ScrollBlot = /** @class */ function(_super) {\n                __extends(ScrollBlot, _super);\n                function ScrollBlot(node) {\n                    var _this = _super.call(this, node) || this;\n                    _this.scroll = _this;\n                    _this.observer = new MutationObserver(function(mutations) {\n                        _this.update(mutations);\n                    });\n                    _this.observer.observe(_this.domNode, OBSERVER_CONFIG);\n                    _this.attach();\n                    return _this;\n                }\n                ScrollBlot.prototype.detach = function() {\n                    _super.prototype.detach.call(this);\n                    this.observer.disconnect();\n                };\n                ScrollBlot.prototype.deleteAt = function(index, length) {\n                    this.update();\n                    if (index === 0 && length === this.length()) {\n                        this.children.forEach(function(child) {\n                            child.remove();\n                        });\n                    } else {\n                        _super.prototype.deleteAt.call(this, index, length);\n                    }\n                };\n                ScrollBlot.prototype.formatAt = function(index, length, name, value) {\n                    this.update();\n                    _super.prototype.formatAt.call(this, index, length, name, value);\n                };\n                ScrollBlot.prototype.insertAt = function(index, value, def) {\n                    this.update();\n                    _super.prototype.insertAt.call(this, index, value, def);\n                };\n                ScrollBlot.prototype.optimize = function(mutations, context) {\n                    var _this = this;\n                    if (mutations === void 0) {\n                        mutations = [];\n                    }\n                    if (context === void 0) {\n                        context = {};\n                    }\n                    _super.prototype.optimize.call(this, context);\n                    // We must modify mutations directly, cannot make copy and then modify\n                    var records = [].slice.call(this.observer.takeRecords());\n                    // Array.push currently seems to be implemented by a non-tail recursive function\n                    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n                    while(records.length > 0)mutations.push(records.pop());\n                    // TODO use WeakMap\n                    var mark = function(blot, markParent) {\n                        if (markParent === void 0) {\n                            markParent = true;\n                        }\n                        if (blot == null || blot === _this) return;\n                        if (blot.domNode.parentNode == null) return;\n                        // @ts-ignore\n                        if (blot.domNode[Registry.DATA_KEY].mutations == null) {\n                            // @ts-ignore\n                            blot.domNode[Registry.DATA_KEY].mutations = [];\n                        }\n                        if (markParent) mark(blot.parent);\n                    };\n                    var optimize = function(blot) {\n                        // Post-order traversal\n                        if (// @ts-ignore\n                        blot.domNode[Registry.DATA_KEY] == null || // @ts-ignore\n                        blot.domNode[Registry.DATA_KEY].mutations == null) {\n                            return;\n                        }\n                        if (blot instanceof container_1.default) {\n                            blot.children.forEach(optimize);\n                        }\n                        blot.optimize(context);\n                    };\n                    var remaining = mutations;\n                    for(var i = 0; remaining.length > 0; i += 1){\n                        if (i >= MAX_OPTIMIZE_ITERATIONS) {\n                            throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n                        }\n                        remaining.forEach(function(mutation) {\n                            var blot = Registry.find(mutation.target, true);\n                            if (blot == null) return;\n                            if (blot.domNode === mutation.target) {\n                                if (mutation.type === \"childList\") {\n                                    mark(Registry.find(mutation.previousSibling, false));\n                                    [].forEach.call(mutation.addedNodes, function(node) {\n                                        var child = Registry.find(node, false);\n                                        mark(child, false);\n                                        if (child instanceof container_1.default) {\n                                            child.children.forEach(function(grandChild) {\n                                                mark(grandChild, false);\n                                            });\n                                        }\n                                    });\n                                } else if (mutation.type === \"attributes\") {\n                                    mark(blot.prev);\n                                }\n                            }\n                            mark(blot);\n                        });\n                        this.children.forEach(optimize);\n                        remaining = [].slice.call(this.observer.takeRecords());\n                        records = remaining.slice();\n                        while(records.length > 0)mutations.push(records.pop());\n                    }\n                };\n                ScrollBlot.prototype.update = function(mutations, context) {\n                    var _this = this;\n                    if (context === void 0) {\n                        context = {};\n                    }\n                    mutations = mutations || this.observer.takeRecords();\n                    // TODO use WeakMap\n                    mutations.map(function(mutation) {\n                        var blot = Registry.find(mutation.target, true);\n                        if (blot == null) return null;\n                        // @ts-ignore\n                        if (blot.domNode[Registry.DATA_KEY].mutations == null) {\n                            // @ts-ignore\n                            blot.domNode[Registry.DATA_KEY].mutations = [\n                                mutation\n                            ];\n                            return blot;\n                        } else {\n                            // @ts-ignore\n                            blot.domNode[Registry.DATA_KEY].mutations.push(mutation);\n                            return null;\n                        }\n                    }).forEach(function(blot) {\n                        if (blot == null || blot === _this || //@ts-ignore\n                        blot.domNode[Registry.DATA_KEY] == null) return;\n                        // @ts-ignore\n                        blot.update(blot.domNode[Registry.DATA_KEY].mutations || [], context);\n                    });\n                    // @ts-ignore\n                    if (this.domNode[Registry.DATA_KEY].mutations != null) {\n                        // @ts-ignore\n                        _super.prototype.update.call(this, this.domNode[Registry.DATA_KEY].mutations, context);\n                    }\n                    this.optimize(mutations, context);\n                };\n                ScrollBlot.blotName = \"scroll\";\n                ScrollBlot.defaultChild = \"block\";\n                ScrollBlot.scope = Registry.Scope.BLOCK_BLOT;\n                ScrollBlot.tagName = \"DIV\";\n                return ScrollBlot;\n            }(container_1.default);\n            exports1.default = ScrollBlot;\n        /***/ },\n        /* 46 */ /***/ function(module1, exports1, __nested_webpack_require_405302__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var format_1 = __nested_webpack_require_405302__(18);\n            var Registry = __nested_webpack_require_405302__(1);\n            // Shallow object comparison\n            function isEqual(obj1, obj2) {\n                if (Object.keys(obj1).length !== Object.keys(obj2).length) return false;\n                // @ts-ignore\n                for(var prop in obj1){\n                    // @ts-ignore\n                    if (obj1[prop] !== obj2[prop]) return false;\n                }\n                return true;\n            }\n            var InlineBlot = /** @class */ function(_super) {\n                __extends(InlineBlot, _super);\n                function InlineBlot() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                InlineBlot.formats = function(domNode) {\n                    if (domNode.tagName === InlineBlot.tagName) return undefined;\n                    return _super.formats.call(this, domNode);\n                };\n                InlineBlot.prototype.format = function(name, value) {\n                    var _this = this;\n                    if (name === this.statics.blotName && !value) {\n                        this.children.forEach(function(child) {\n                            if (!(child instanceof format_1.default)) {\n                                child = child.wrap(InlineBlot.blotName, true);\n                            }\n                            _this.attributes.copy(child);\n                        });\n                        this.unwrap();\n                    } else {\n                        _super.prototype.format.call(this, name, value);\n                    }\n                };\n                InlineBlot.prototype.formatAt = function(index, length, name, value) {\n                    if (this.formats()[name] != null || Registry.query(name, Registry.Scope.ATTRIBUTE)) {\n                        var blot = this.isolate(index, length);\n                        blot.format(name, value);\n                    } else {\n                        _super.prototype.formatAt.call(this, index, length, name, value);\n                    }\n                };\n                InlineBlot.prototype.optimize = function(context) {\n                    _super.prototype.optimize.call(this, context);\n                    var formats = this.formats();\n                    if (Object.keys(formats).length === 0) {\n                        return this.unwrap(); // unformatted span\n                    }\n                    var next = this.next;\n                    if (next instanceof InlineBlot && next.prev === this && isEqual(formats, next.formats())) {\n                        next.moveChildren(this);\n                        next.remove();\n                    }\n                };\n                InlineBlot.blotName = \"inline\";\n                InlineBlot.scope = Registry.Scope.INLINE_BLOT;\n                InlineBlot.tagName = \"SPAN\";\n                return InlineBlot;\n            }(format_1.default);\n            exports1.default = InlineBlot;\n        /***/ },\n        /* 47 */ /***/ function(module1, exports1, __nested_webpack_require_409256__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var format_1 = __nested_webpack_require_409256__(18);\n            var Registry = __nested_webpack_require_409256__(1);\n            var BlockBlot = /** @class */ function(_super) {\n                __extends(BlockBlot, _super);\n                function BlockBlot() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                BlockBlot.formats = function(domNode) {\n                    var tagName = Registry.query(BlockBlot.blotName).tagName;\n                    if (domNode.tagName === tagName) return undefined;\n                    return _super.formats.call(this, domNode);\n                };\n                BlockBlot.prototype.format = function(name, value) {\n                    if (Registry.query(name, Registry.Scope.BLOCK) == null) {\n                        return;\n                    } else if (name === this.statics.blotName && !value) {\n                        this.replaceWith(BlockBlot.blotName);\n                    } else {\n                        _super.prototype.format.call(this, name, value);\n                    }\n                };\n                BlockBlot.prototype.formatAt = function(index, length, name, value) {\n                    if (Registry.query(name, Registry.Scope.BLOCK) != null) {\n                        this.format(name, value);\n                    } else {\n                        _super.prototype.formatAt.call(this, index, length, name, value);\n                    }\n                };\n                BlockBlot.prototype.insertAt = function(index, value, def) {\n                    if (def == null || Registry.query(value, Registry.Scope.INLINE) != null) {\n                        // Insert text or inline\n                        _super.prototype.insertAt.call(this, index, value, def);\n                    } else {\n                        var after = this.split(index);\n                        var blot = Registry.create(value, def);\n                        after.parent.insertBefore(blot, after);\n                    }\n                };\n                BlockBlot.prototype.update = function(mutations, context) {\n                    if (navigator.userAgent.match(/Trident/)) {\n                        this.build();\n                    } else {\n                        _super.prototype.update.call(this, mutations, context);\n                    }\n                };\n                BlockBlot.blotName = \"block\";\n                BlockBlot.scope = Registry.Scope.BLOCK_BLOT;\n                BlockBlot.tagName = \"P\";\n                return BlockBlot;\n            }(format_1.default);\n            exports1.default = BlockBlot;\n        /***/ },\n        /* 48 */ /***/ function(module1, exports1, __nested_webpack_require_412804__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var leaf_1 = __nested_webpack_require_412804__(19);\n            var EmbedBlot = /** @class */ function(_super) {\n                __extends(EmbedBlot, _super);\n                function EmbedBlot() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                EmbedBlot.formats = function(domNode) {\n                    return undefined;\n                };\n                EmbedBlot.prototype.format = function(name, value) {\n                    // super.formatAt wraps, which is what we want in general,\n                    // but this allows subclasses to overwrite for formats\n                    // that just apply to particular embeds\n                    _super.prototype.formatAt.call(this, 0, this.length(), name, value);\n                };\n                EmbedBlot.prototype.formatAt = function(index, length, name, value) {\n                    if (index === 0 && length === this.length()) {\n                        this.format(name, value);\n                    } else {\n                        _super.prototype.formatAt.call(this, index, length, name, value);\n                    }\n                };\n                EmbedBlot.prototype.formats = function() {\n                    return this.statics.formats(this.domNode);\n                };\n                return EmbedBlot;\n            }(leaf_1.default);\n            exports1.default = EmbedBlot;\n        /***/ },\n        /* 49 */ /***/ function(module1, exports1, __nested_webpack_require_415154__) {\n            \"use strict\";\n            var __extends = this && this.__extends || function() {\n                var extendStatics = Object.setPrototypeOf || ({\n                    __proto__: []\n                }) instanceof Array && function(d, b) {\n                    d.__proto__ = b;\n                } || function(d, b) {\n                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n                };\n                return function(d, b) {\n                    extendStatics(d, b);\n                    function __() {\n                        this.constructor = d;\n                    }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            }();\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var leaf_1 = __nested_webpack_require_415154__(19);\n            var Registry = __nested_webpack_require_415154__(1);\n            var TextBlot = /** @class */ function(_super) {\n                __extends(TextBlot, _super);\n                function TextBlot(node) {\n                    var _this = _super.call(this, node) || this;\n                    _this.text = _this.statics.value(_this.domNode);\n                    return _this;\n                }\n                TextBlot.create = function(value) {\n                    return document.createTextNode(value);\n                };\n                TextBlot.value = function(domNode) {\n                    var text = domNode.data;\n                    // @ts-ignore\n                    if (text[\"normalize\"]) text = text[\"normalize\"]();\n                    return text;\n                };\n                TextBlot.prototype.deleteAt = function(index, length) {\n                    this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);\n                };\n                TextBlot.prototype.index = function(node, offset) {\n                    if (this.domNode === node) {\n                        return offset;\n                    }\n                    return -1;\n                };\n                TextBlot.prototype.insertAt = function(index, value, def) {\n                    if (def == null) {\n                        this.text = this.text.slice(0, index) + value + this.text.slice(index);\n                        this.domNode.data = this.text;\n                    } else {\n                        _super.prototype.insertAt.call(this, index, value, def);\n                    }\n                };\n                TextBlot.prototype.length = function() {\n                    return this.text.length;\n                };\n                TextBlot.prototype.optimize = function(context) {\n                    _super.prototype.optimize.call(this, context);\n                    this.text = this.statics.value(this.domNode);\n                    if (this.text.length === 0) {\n                        this.remove();\n                    } else if (this.next instanceof TextBlot && this.next.prev === this) {\n                        this.insertAt(this.length(), this.next.value());\n                        this.next.remove();\n                    }\n                };\n                TextBlot.prototype.position = function(index, inclusive) {\n                    if (inclusive === void 0) {\n                        inclusive = false;\n                    }\n                    return [\n                        this.domNode,\n                        index\n                    ];\n                };\n                TextBlot.prototype.split = function(index, force) {\n                    if (force === void 0) {\n                        force = false;\n                    }\n                    if (!force) {\n                        if (index === 0) return this;\n                        if (index === this.length()) return this.next;\n                    }\n                    var after = Registry.create(this.domNode.splitText(index));\n                    this.parent.insertBefore(after, this.next);\n                    this.text = this.statics.value(this.domNode);\n                    return after;\n                };\n                TextBlot.prototype.update = function(mutations, context) {\n                    var _this = this;\n                    if (mutations.some(function(mutation) {\n                        return mutation.type === \"characterData\" && mutation.target === _this.domNode;\n                    })) {\n                        this.text = this.statics.value(this.domNode);\n                    }\n                };\n                TextBlot.prototype.value = function() {\n                    return this.text;\n                };\n                TextBlot.blotName = \"text\";\n                TextBlot.scope = Registry.Scope.INLINE_BLOT;\n                return TextBlot;\n            }(leaf_1.default);\n            exports1.default = TextBlot;\n        /***/ },\n        /* 50 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var elem = document.createElement(\"div\");\n            elem.classList.toggle(\"test-class\", false);\n            if (elem.classList.contains(\"test-class\")) {\n                var _toggle = DOMTokenList.prototype.toggle;\n                DOMTokenList.prototype.toggle = function(token, force) {\n                    if (arguments.length > 1 && !this.contains(token) === !force) {\n                        return force;\n                    } else {\n                        return _toggle.call(this, token);\n                    }\n                };\n            }\n            if (!String.prototype.startsWith) {\n                String.prototype.startsWith = function(searchString, position) {\n                    position = position || 0;\n                    return this.substr(position, searchString.length) === searchString;\n                };\n            }\n            if (!String.prototype.endsWith) {\n                String.prototype.endsWith = function(searchString, position) {\n                    var subjectString = this.toString();\n                    if (typeof position !== \"number\" || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\n                        position = subjectString.length;\n                    }\n                    position -= searchString.length;\n                    var lastIndex = subjectString.indexOf(searchString, position);\n                    return lastIndex !== -1 && lastIndex === position;\n                };\n            }\n            if (!Array.prototype.find) {\n                Object.defineProperty(Array.prototype, \"find\", {\n                    value: function value(predicate) {\n                        if (this === null) {\n                            throw new TypeError(\"Array.prototype.find called on null or undefined\");\n                        }\n                        if (typeof predicate !== \"function\") {\n                            throw new TypeError(\"predicate must be a function\");\n                        }\n                        var list = Object(this);\n                        var length = list.length >>> 0;\n                        var thisArg = arguments[1];\n                        var value;\n                        for(var i = 0; i < length; i++){\n                            value = list[i];\n                            if (predicate.call(thisArg, value, i, list)) {\n                                return value;\n                            }\n                        }\n                        return undefined;\n                    }\n                });\n            }\n            document.addEventListener(\"DOMContentLoaded\", function() {\n                // Disable resizing in Firefox\n                document.execCommand(\"enableObjectResizing\", false, false);\n                // Disable automatic linkifying in IE11\n                document.execCommand(\"autoUrlDetect\", false, false);\n            });\n        /***/ },\n        /* 51 */ /***/ function(module1, exports1) {\n            /**\n * This library modifies the diff-patch-match library by Neil Fraser\n * by removing the patch and match functionality and certain advanced\n * options in the diff function. The original license is as follows:\n *\n * ===\n *\n * Diff Match and Patch\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */ var DIFF_DELETE = -1;\n            var DIFF_INSERT = 1;\n            var DIFF_EQUAL = 0;\n            /**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {Int} cursor_pos Expected edit position in text1 (optional)\n * @return {Array} Array of diff tuples.\n */ function diff_main(text1, text2, cursor_pos) {\n                // Check for equality (speedup).\n                if (text1 == text2) {\n                    if (text1) {\n                        return [\n                            [\n                                DIFF_EQUAL,\n                                text1\n                            ]\n                        ];\n                    }\n                    return [];\n                }\n                // Check cursor_pos within bounds\n                if (cursor_pos < 0 || text1.length < cursor_pos) {\n                    cursor_pos = null;\n                }\n                // Trim off common prefix (speedup).\n                var commonlength = diff_commonPrefix(text1, text2);\n                var commonprefix = text1.substring(0, commonlength);\n                text1 = text1.substring(commonlength);\n                text2 = text2.substring(commonlength);\n                // Trim off common suffix (speedup).\n                commonlength = diff_commonSuffix(text1, text2);\n                var commonsuffix = text1.substring(text1.length - commonlength);\n                text1 = text1.substring(0, text1.length - commonlength);\n                text2 = text2.substring(0, text2.length - commonlength);\n                // Compute the diff on the middle block.\n                var diffs = diff_compute_(text1, text2);\n                // Restore the prefix and suffix.\n                if (commonprefix) {\n                    diffs.unshift([\n                        DIFF_EQUAL,\n                        commonprefix\n                    ]);\n                }\n                if (commonsuffix) {\n                    diffs.push([\n                        DIFF_EQUAL,\n                        commonsuffix\n                    ]);\n                }\n                diff_cleanupMerge(diffs);\n                if (cursor_pos != null) {\n                    diffs = fix_cursor(diffs, cursor_pos);\n                }\n                diffs = fix_emoji(diffs);\n                return diffs;\n            }\n            ;\n            /**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n */ function diff_compute_(text1, text2) {\n                var diffs;\n                if (!text1) {\n                    // Just add some text (speedup).\n                    return [\n                        [\n                            DIFF_INSERT,\n                            text2\n                        ]\n                    ];\n                }\n                if (!text2) {\n                    // Just delete some text (speedup).\n                    return [\n                        [\n                            DIFF_DELETE,\n                            text1\n                        ]\n                    ];\n                }\n                var longtext = text1.length > text2.length ? text1 : text2;\n                var shorttext = text1.length > text2.length ? text2 : text1;\n                var i = longtext.indexOf(shorttext);\n                if (i != -1) {\n                    // Shorter text is inside the longer text (speedup).\n                    diffs = [\n                        [\n                            DIFF_INSERT,\n                            longtext.substring(0, i)\n                        ],\n                        [\n                            DIFF_EQUAL,\n                            shorttext\n                        ],\n                        [\n                            DIFF_INSERT,\n                            longtext.substring(i + shorttext.length)\n                        ]\n                    ];\n                    // Swap insertions for deletions if diff is reversed.\n                    if (text1.length > text2.length) {\n                        diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n                    }\n                    return diffs;\n                }\n                if (shorttext.length == 1) {\n                    // Single character string.\n                    // After the previous speedup, the character can't be an equality.\n                    return [\n                        [\n                            DIFF_DELETE,\n                            text1\n                        ],\n                        [\n                            DIFF_INSERT,\n                            text2\n                        ]\n                    ];\n                }\n                // Check to see if the problem can be split in two.\n                var hm = diff_halfMatch_(text1, text2);\n                if (hm) {\n                    // A half-match was found, sort out the return data.\n                    var text1_a = hm[0];\n                    var text1_b = hm[1];\n                    var text2_a = hm[2];\n                    var text2_b = hm[3];\n                    var mid_common = hm[4];\n                    // Send both pairs off for separate processing.\n                    var diffs_a = diff_main(text1_a, text2_a);\n                    var diffs_b = diff_main(text1_b, text2_b);\n                    // Merge the results.\n                    return diffs_a.concat([\n                        [\n                            DIFF_EQUAL,\n                            mid_common\n                        ]\n                    ], diffs_b);\n                }\n                return diff_bisect_(text1, text2);\n            }\n            ;\n            /**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n * @private\n */ function diff_bisect_(text1, text2) {\n                // Cache the text lengths to prevent multiple calls.\n                var text1_length = text1.length;\n                var text2_length = text2.length;\n                var max_d = Math.ceil((text1_length + text2_length) / 2);\n                var v_offset = max_d;\n                var v_length = 2 * max_d;\n                var v1 = new Array(v_length);\n                var v2 = new Array(v_length);\n                // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n                // integers and undefined.\n                for(var x = 0; x < v_length; x++){\n                    v1[x] = -1;\n                    v2[x] = -1;\n                }\n                v1[v_offset + 1] = 0;\n                v2[v_offset + 1] = 0;\n                var delta = text1_length - text2_length;\n                // If the total number of characters is odd, then the front path will collide\n                // with the reverse path.\n                var front = delta % 2 != 0;\n                // Offsets for start and end of k loop.\n                // Prevents mapping of space beyond the grid.\n                var k1start = 0;\n                var k1end = 0;\n                var k2start = 0;\n                var k2end = 0;\n                for(var d = 0; d < max_d; d++){\n                    // Walk the front path one step.\n                    for(var k1 = -d + k1start; k1 <= d - k1end; k1 += 2){\n                        var k1_offset = v_offset + k1;\n                        var x1;\n                        if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {\n                            x1 = v1[k1_offset + 1];\n                        } else {\n                            x1 = v1[k1_offset - 1] + 1;\n                        }\n                        var y1 = x1 - k1;\n                        while(x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)){\n                            x1++;\n                            y1++;\n                        }\n                        v1[k1_offset] = x1;\n                        if (x1 > text1_length) {\n                            // Ran off the right of the graph.\n                            k1end += 2;\n                        } else if (y1 > text2_length) {\n                            // Ran off the bottom of the graph.\n                            k1start += 2;\n                        } else if (front) {\n                            var k2_offset = v_offset + delta - k1;\n                            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n                                // Mirror x2 onto top-left coordinate system.\n                                var x2 = text1_length - v2[k2_offset];\n                                if (x1 >= x2) {\n                                    // Overlap detected.\n                                    return diff_bisectSplit_(text1, text2, x1, y1);\n                                }\n                            }\n                        }\n                    }\n                    // Walk the reverse path one step.\n                    for(var k2 = -d + k2start; k2 <= d - k2end; k2 += 2){\n                        var k2_offset = v_offset + k2;\n                        var x2;\n                        if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {\n                            x2 = v2[k2_offset + 1];\n                        } else {\n                            x2 = v2[k2_offset - 1] + 1;\n                        }\n                        var y2 = x2 - k2;\n                        while(x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)){\n                            x2++;\n                            y2++;\n                        }\n                        v2[k2_offset] = x2;\n                        if (x2 > text1_length) {\n                            // Ran off the left of the graph.\n                            k2end += 2;\n                        } else if (y2 > text2_length) {\n                            // Ran off the top of the graph.\n                            k2start += 2;\n                        } else if (!front) {\n                            var k1_offset = v_offset + delta - k2;\n                            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n                                var x1 = v1[k1_offset];\n                                var y1 = v_offset + x1 - k1_offset;\n                                // Mirror x2 onto top-left coordinate system.\n                                x2 = text1_length - x2;\n                                if (x1 >= x2) {\n                                    // Overlap detected.\n                                    return diff_bisectSplit_(text1, text2, x1, y1);\n                                }\n                            }\n                        }\n                    }\n                }\n                // Diff took too long and hit the deadline or\n                // number of diffs equals number of characters, no commonality at all.\n                return [\n                    [\n                        DIFF_DELETE,\n                        text1\n                    ],\n                    [\n                        DIFF_INSERT,\n                        text2\n                    ]\n                ];\n            }\n            ;\n            /**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @return {Array} Array of diff tuples.\n */ function diff_bisectSplit_(text1, text2, x, y) {\n                var text1a = text1.substring(0, x);\n                var text2a = text2.substring(0, y);\n                var text1b = text1.substring(x);\n                var text2b = text2.substring(y);\n                // Compute both diffs serially.\n                var diffs = diff_main(text1a, text2a);\n                var diffsb = diff_main(text1b, text2b);\n                return diffs.concat(diffsb);\n            }\n            ;\n            /**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */ function diff_commonPrefix(text1, text2) {\n                // Quick check for common null cases.\n                if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n                    return 0;\n                }\n                // Binary search.\n                // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n                var pointermin = 0;\n                var pointermax = Math.min(text1.length, text2.length);\n                var pointermid = pointermax;\n                var pointerstart = 0;\n                while(pointermin < pointermid){\n                    if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {\n                        pointermin = pointermid;\n                        pointerstart = pointermin;\n                    } else {\n                        pointermax = pointermid;\n                    }\n                    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n                }\n                return pointermid;\n            }\n            ;\n            /**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */ function diff_commonSuffix(text1, text2) {\n                // Quick check for common null cases.\n                if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n                    return 0;\n                }\n                // Binary search.\n                // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n                var pointermin = 0;\n                var pointermax = Math.min(text1.length, text2.length);\n                var pointermid = pointermax;\n                var pointerend = 0;\n                while(pointermin < pointermid){\n                    if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n                        pointermin = pointermid;\n                        pointerend = pointermin;\n                    } else {\n                        pointermax = pointermid;\n                    }\n                    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n                }\n                return pointermid;\n            }\n            ;\n            /**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n */ function diff_halfMatch_(text1, text2) {\n                var longtext = text1.length > text2.length ? text1 : text2;\n                var shorttext = text1.length > text2.length ? text2 : text1;\n                if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n                    return null; // Pointless.\n                }\n                /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */ function diff_halfMatchI_(longtext, shorttext, i) {\n                    // Start with a 1/4 length substring at position i as a seed.\n                    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n                    var j = -1;\n                    var best_common = \"\";\n                    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n                    while((j = shorttext.indexOf(seed, j + 1)) != -1){\n                        var prefixLength = diff_commonPrefix(longtext.substring(i), shorttext.substring(j));\n                        var suffixLength = diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\n                        if (best_common.length < suffixLength + prefixLength) {\n                            best_common = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n                            best_longtext_a = longtext.substring(0, i - suffixLength);\n                            best_longtext_b = longtext.substring(i + prefixLength);\n                            best_shorttext_a = shorttext.substring(0, j - suffixLength);\n                            best_shorttext_b = shorttext.substring(j + prefixLength);\n                        }\n                    }\n                    if (best_common.length * 2 >= longtext.length) {\n                        return [\n                            best_longtext_a,\n                            best_longtext_b,\n                            best_shorttext_a,\n                            best_shorttext_b,\n                            best_common\n                        ];\n                    } else {\n                        return null;\n                    }\n                }\n                // First check if the second quarter is the seed for a half-match.\n                var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));\n                // Check again based on the third quarter.\n                var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));\n                var hm;\n                if (!hm1 && !hm2) {\n                    return null;\n                } else if (!hm2) {\n                    hm = hm1;\n                } else if (!hm1) {\n                    hm = hm2;\n                } else {\n                    // Both matched.  Select the longest.\n                    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n                }\n                // A half-match was found, sort out the return data.\n                var text1_a, text1_b, text2_a, text2_b;\n                if (text1.length > text2.length) {\n                    text1_a = hm[0];\n                    text1_b = hm[1];\n                    text2_a = hm[2];\n                    text2_b = hm[3];\n                } else {\n                    text2_a = hm[0];\n                    text2_b = hm[1];\n                    text1_a = hm[2];\n                    text1_b = hm[3];\n                }\n                var mid_common = hm[4];\n                return [\n                    text1_a,\n                    text1_b,\n                    text2_a,\n                    text2_b,\n                    mid_common\n                ];\n            }\n            ;\n            /**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {Array} diffs Array of diff tuples.\n */ function diff_cleanupMerge(diffs) {\n                diffs.push([\n                    DIFF_EQUAL,\n                    \"\"\n                ]); // Add a dummy entry at the end.\n                var pointer = 0;\n                var count_delete = 0;\n                var count_insert = 0;\n                var text_delete = \"\";\n                var text_insert = \"\";\n                var commonlength;\n                while(pointer < diffs.length){\n                    switch(diffs[pointer][0]){\n                        case DIFF_INSERT:\n                            count_insert++;\n                            text_insert += diffs[pointer][1];\n                            pointer++;\n                            break;\n                        case DIFF_DELETE:\n                            count_delete++;\n                            text_delete += diffs[pointer][1];\n                            pointer++;\n                            break;\n                        case DIFF_EQUAL:\n                            // Upon reaching an equality, check for prior redundancies.\n                            if (count_delete + count_insert > 1) {\n                                if (count_delete !== 0 && count_insert !== 0) {\n                                    // Factor out any common prefixies.\n                                    commonlength = diff_commonPrefix(text_insert, text_delete);\n                                    if (commonlength !== 0) {\n                                        if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {\n                                            diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);\n                                        } else {\n                                            diffs.splice(0, 0, [\n                                                DIFF_EQUAL,\n                                                text_insert.substring(0, commonlength)\n                                            ]);\n                                            pointer++;\n                                        }\n                                        text_insert = text_insert.substring(commonlength);\n                                        text_delete = text_delete.substring(commonlength);\n                                    }\n                                    // Factor out any common suffixies.\n                                    commonlength = diff_commonSuffix(text_insert, text_delete);\n                                    if (commonlength !== 0) {\n                                        diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n                                        text_insert = text_insert.substring(0, text_insert.length - commonlength);\n                                        text_delete = text_delete.substring(0, text_delete.length - commonlength);\n                                    }\n                                }\n                                // Delete the offending records and add the merged ones.\n                                if (count_delete === 0) {\n                                    diffs.splice(pointer - count_insert, count_delete + count_insert, [\n                                        DIFF_INSERT,\n                                        text_insert\n                                    ]);\n                                } else if (count_insert === 0) {\n                                    diffs.splice(pointer - count_delete, count_delete + count_insert, [\n                                        DIFF_DELETE,\n                                        text_delete\n                                    ]);\n                                } else {\n                                    diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [\n                                        DIFF_DELETE,\n                                        text_delete\n                                    ], [\n                                        DIFF_INSERT,\n                                        text_insert\n                                    ]);\n                                }\n                                pointer = pointer - count_delete - count_insert + (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n                            } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n                                // Merge this equality with the previous one.\n                                diffs[pointer - 1][1] += diffs[pointer][1];\n                                diffs.splice(pointer, 1);\n                            } else {\n                                pointer++;\n                            }\n                            count_insert = 0;\n                            count_delete = 0;\n                            text_delete = \"\";\n                            text_insert = \"\";\n                            break;\n                    }\n                }\n                if (diffs[diffs.length - 1][1] === \"\") {\n                    diffs.pop(); // Remove the dummy entry at the end.\n                }\n                // Second pass: look for single edits surrounded on both sides by equalities\n                // which can be shifted sideways to eliminate an equality.\n                // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n                var changes = false;\n                pointer = 1;\n                // Intentionally ignore the first and last element (don't need checking).\n                while(pointer < diffs.length - 1){\n                    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {\n                        // This is a single edit surrounded by equalities.\n                        if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n                            // Shift the edit over the previous equality.\n                            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n                            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n                            diffs.splice(pointer - 1, 1);\n                            changes = true;\n                        } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {\n                            // Shift the edit over the next equality.\n                            diffs[pointer - 1][1] += diffs[pointer + 1][1];\n                            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n                            diffs.splice(pointer + 1, 1);\n                            changes = true;\n                        }\n                    }\n                    pointer++;\n                }\n                // If shifts were made, the diff needs reordering and another shift sweep.\n                if (changes) {\n                    diff_cleanupMerge(diffs);\n                }\n            }\n            ;\n            var diff = diff_main;\n            diff.INSERT = DIFF_INSERT;\n            diff.DELETE = DIFF_DELETE;\n            diff.EQUAL = DIFF_EQUAL;\n            module1.exports = diff;\n            /*\n * Modify a diff such that the cursor position points to the start of a change:\n * E.g.\n *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)\n *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]\n *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)\n *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]\n *\n * @param {Array} diffs Array of diff tuples\n * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!\n * @return {Array} A tuple [cursor location in the modified diff, modified diff]\n */ function cursor_normalize_diff(diffs, cursor_pos) {\n                if (cursor_pos === 0) {\n                    return [\n                        DIFF_EQUAL,\n                        diffs\n                    ];\n                }\n                for(var current_pos = 0, i = 0; i < diffs.length; i++){\n                    var d = diffs[i];\n                    if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {\n                        var next_pos = current_pos + d[1].length;\n                        if (cursor_pos === next_pos) {\n                            return [\n                                i + 1,\n                                diffs\n                            ];\n                        } else if (cursor_pos < next_pos) {\n                            // copy to prevent side effects\n                            diffs = diffs.slice();\n                            // split d into two diff changes\n                            var split_pos = cursor_pos - current_pos;\n                            var d_left = [\n                                d[0],\n                                d[1].slice(0, split_pos)\n                            ];\n                            var d_right = [\n                                d[0],\n                                d[1].slice(split_pos)\n                            ];\n                            diffs.splice(i, 1, d_left, d_right);\n                            return [\n                                i + 1,\n                                diffs\n                            ];\n                        } else {\n                            current_pos = next_pos;\n                        }\n                    }\n                }\n                throw new Error(\"cursor_pos is out of bounds!\");\n            }\n            /*\n * Modify a diff such that the edit position is \"shifted\" to the proposed edit location (cursor_position).\n *\n * Case 1)\n *   Check if a naive shift is possible:\n *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)\n *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result\n * Case 2)\n *   Check if the following shifts are possible:\n *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']\n *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']\n *         ^            ^\n *         d          d_next\n *\n * @param {Array} diffs Array of diff tuples\n * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!\n * @return {Array} Array of diff tuples\n */ function fix_cursor(diffs, cursor_pos) {\n                var norm = cursor_normalize_diff(diffs, cursor_pos);\n                var ndiffs = norm[1];\n                var cursor_pointer = norm[0];\n                var d = ndiffs[cursor_pointer];\n                var d_next = ndiffs[cursor_pointer + 1];\n                if (d == null) {\n                    // Text was deleted from end of original string,\n                    // cursor is now out of bounds in new string\n                    return diffs;\n                } else if (d[0] !== DIFF_EQUAL) {\n                    // A modification happened at the cursor location.\n                    // This is the expected outcome, so we can return the original diff.\n                    return diffs;\n                } else {\n                    if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {\n                        // Case 1)\n                        // It is possible to perform a naive shift\n                        ndiffs.splice(cursor_pointer, 2, d_next, d);\n                        return merge_tuples(ndiffs, cursor_pointer, 2);\n                    } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {\n                        // Case 2)\n                        // d[1] is a prefix of d_next[1]\n                        // We can assume that d_next[0] !== 0, since d[0] === 0\n                        // Shift edit locations..\n                        ndiffs.splice(cursor_pointer, 2, [\n                            d_next[0],\n                            d[1]\n                        ], [\n                            0,\n                            d[1]\n                        ]);\n                        var suffix = d_next[1].slice(d[1].length);\n                        if (suffix.length > 0) {\n                            ndiffs.splice(cursor_pointer + 2, 0, [\n                                d_next[0],\n                                suffix\n                            ]);\n                        }\n                        return merge_tuples(ndiffs, cursor_pointer, 3);\n                    } else {\n                        // Not possible to perform any modification\n                        return diffs;\n                    }\n                }\n            }\n            /*\n * Check diff did not split surrogate pairs.\n * Ex. [0, '\\uD83D'], [-1, '\\uDC36'], [1, '\\uDC2F'] -> [-1, '\\uD83D\\uDC36'], [1, '\\uD83D\\uDC2F']\n *     '\\uD83D\\uDC36' === '🐶', '\\uD83D\\uDC2F' === '🐯'\n *\n * @param {Array} diffs Array of diff tuples\n * @return {Array} Array of diff tuples\n */ function fix_emoji(diffs) {\n                var compact = false;\n                var starts_with_pair_end = function(str) {\n                    return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;\n                };\n                var ends_with_pair_start = function(str) {\n                    return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;\n                };\n                for(var i = 2; i < diffs.length; i += 1){\n                    if (diffs[i - 2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i - 2][1]) && diffs[i - 1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i - 1][1]) && diffs[i][0] === DIFF_INSERT && starts_with_pair_end(diffs[i][1])) {\n                        compact = true;\n                        diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];\n                        diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];\n                        diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);\n                    }\n                }\n                if (!compact) {\n                    return diffs;\n                }\n                var fixed_diffs = [];\n                for(var i = 0; i < diffs.length; i += 1){\n                    if (diffs[i][1].length > 0) {\n                        fixed_diffs.push(diffs[i]);\n                    }\n                }\n                return fixed_diffs;\n            }\n            /*\n * Try to merge tuples with their neigbors in a given range.\n * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']\n *\n * @param {Array} diffs Array of diff tuples.\n * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).\n * @param {Int} length Number of consecutive elements to check.\n * @return {Array} Array of merged diff tuples.\n */ function merge_tuples(diffs, start, length) {\n                // Check from (start-1) to (start+length).\n                for(var i = start + length - 1; i >= 0 && i >= start - 1; i--){\n                    if (i + 1 < diffs.length) {\n                        var left_d = diffs[i];\n                        var right_d = diffs[i + 1];\n                        if (left_d[0] === right_d[1]) {\n                            diffs.splice(i, 2, [\n                                left_d[0],\n                                left_d[1] + right_d[1]\n                            ]);\n                        }\n                    }\n                }\n                return diffs;\n            }\n        /***/ },\n        /* 52 */ /***/ function(module1, exports1) {\n            exports1 = module1.exports = typeof Object.keys === \"function\" ? Object.keys : shim;\n            exports1.shim = shim;\n            function shim(obj) {\n                var keys = [];\n                for(var key in obj)keys.push(key);\n                return keys;\n            }\n        /***/ },\n        /* 53 */ /***/ function(module1, exports1) {\n            var supportsArgumentsClass = function() {\n                return Object.prototype.toString.call(arguments);\n            }() == \"[object Arguments]\";\n            exports1 = module1.exports = supportsArgumentsClass ? supported : unsupported;\n            exports1.supported = supported;\n            function supported(object) {\n                return Object.prototype.toString.call(object) == \"[object Arguments]\";\n            }\n            ;\n            exports1.unsupported = unsupported;\n            function unsupported(object) {\n                return object && typeof object == \"object\" && typeof object.length == \"number\" && Object.prototype.hasOwnProperty.call(object, \"callee\") && !Object.prototype.propertyIsEnumerable.call(object, \"callee\") || false;\n            }\n            ;\n        /***/ },\n        /* 54 */ /***/ function(module1, exports1) {\n            \"use strict\";\n            var has = Object.prototype.hasOwnProperty, prefix = \"~\";\n            /**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @api private\n */ function Events() {}\n            //\n            // We try to not inherit from `Object.prototype`. In some engines creating an\n            // instance in this way is faster than calling `Object.create(null)` directly.\n            // If `Object.create(null)` is not supported we prefix the event names with a\n            // character to make sure that the built-in object properties are not\n            // overridden or used as an attack vector.\n            //\n            if (Object.create) {\n                Events.prototype = Object.create(null);\n                //\n                // This hack is needed because the `__proto__` property is still inherited in\n                // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n                //\n                if (!new Events().__proto__) prefix = false;\n            }\n            /**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {Mixed} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @api private\n */ function EE(fn, context, once) {\n                this.fn = fn;\n                this.context = context;\n                this.once = once || false;\n            }\n            /**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @api public\n */ function EventEmitter() {\n                this._events = new Events();\n                this._eventsCount = 0;\n            }\n            /**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @api public\n */ EventEmitter.prototype.eventNames = function eventNames() {\n                var names = [], events, name;\n                if (this._eventsCount === 0) return names;\n                for(name in events = this._events){\n                    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n                }\n                if (Object.getOwnPropertySymbols) {\n                    return names.concat(Object.getOwnPropertySymbols(events));\n                }\n                return names;\n            };\n            /**\n * Return the listeners registered for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Boolean} exists Only check if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */ EventEmitter.prototype.listeners = function listeners(event, exists) {\n                var evt = prefix ? prefix + event : event, available = this._events[evt];\n                if (exists) return !!available;\n                if (!available) return [];\n                if (available.fn) return [\n                    available.fn\n                ];\n                for(var i = 0, l = available.length, ee = new Array(l); i < l; i++){\n                    ee[i] = available[i].fn;\n                }\n                return ee;\n            };\n            /**\n * Calls each of the listeners registered for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @api public\n */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n                var evt = prefix ? prefix + event : event;\n                if (!this._events[evt]) return false;\n                var listeners = this._events[evt], len = arguments.length, args, i;\n                if (listeners.fn) {\n                    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n                    switch(len){\n                        case 1:\n                            return listeners.fn.call(listeners.context), true;\n                        case 2:\n                            return listeners.fn.call(listeners.context, a1), true;\n                        case 3:\n                            return listeners.fn.call(listeners.context, a1, a2), true;\n                        case 4:\n                            return listeners.fn.call(listeners.context, a1, a2, a3), true;\n                        case 5:\n                            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n                        case 6:\n                            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n                    }\n                    for(i = 1, args = new Array(len - 1); i < len; i++){\n                        args[i - 1] = arguments[i];\n                    }\n                    listeners.fn.apply(listeners.context, args);\n                } else {\n                    var length = listeners.length, j;\n                    for(i = 0; i < length; i++){\n                        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n                        switch(len){\n                            case 1:\n                                listeners[i].fn.call(listeners[i].context);\n                                break;\n                            case 2:\n                                listeners[i].fn.call(listeners[i].context, a1);\n                                break;\n                            case 3:\n                                listeners[i].fn.call(listeners[i].context, a1, a2);\n                                break;\n                            case 4:\n                                listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                                break;\n                            default:\n                                if (!args) for(j = 1, args = new Array(len - 1); j < len; j++){\n                                    args[j - 1] = arguments[j];\n                                }\n                                listeners[i].fn.apply(listeners[i].context, args);\n                        }\n                    }\n                }\n                return true;\n            };\n            /**\n * Add a listener for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn The listener function.\n * @param {Mixed} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @api public\n */ EventEmitter.prototype.on = function on(event, fn, context) {\n                var listener = new EE(fn, context || this), evt = prefix ? prefix + event : event;\n                if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;\n                else if (!this._events[evt].fn) this._events[evt].push(listener);\n                else this._events[evt] = [\n                    this._events[evt],\n                    listener\n                ];\n                return this;\n            };\n            /**\n * Add a one-time listener for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn The listener function.\n * @param {Mixed} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @api public\n */ EventEmitter.prototype.once = function once(event, fn, context) {\n                var listener = new EE(fn, context || this, true), evt = prefix ? prefix + event : event;\n                if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;\n                else if (!this._events[evt].fn) this._events[evt].push(listener);\n                else this._events[evt] = [\n                    this._events[evt],\n                    listener\n                ];\n                return this;\n            };\n            /**\n * Remove the listeners of a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {Mixed} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @api public\n */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n                var evt = prefix ? prefix + event : event;\n                if (!this._events[evt]) return this;\n                if (!fn) {\n                    if (--this._eventsCount === 0) this._events = new Events();\n                    else delete this._events[evt];\n                    return this;\n                }\n                var listeners = this._events[evt];\n                if (listeners.fn) {\n                    if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n                        if (--this._eventsCount === 0) this._events = new Events();\n                        else delete this._events[evt];\n                    }\n                } else {\n                    for(var i = 0, events = [], length = listeners.length; i < length; i++){\n                        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n                            events.push(listeners[i]);\n                        }\n                    }\n                    //\n                    // Reset the array, or remove it completely if we have no more listeners.\n                    //\n                    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n                    else if (--this._eventsCount === 0) this._events = new Events();\n                    else delete this._events[evt];\n                }\n                return this;\n            };\n            /**\n * Remove all listeners, or those of the specified event.\n *\n * @param {String|Symbol} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @api public\n */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n                var evt;\n                if (event) {\n                    evt = prefix ? prefix + event : event;\n                    if (this._events[evt]) {\n                        if (--this._eventsCount === 0) this._events = new Events();\n                        else delete this._events[evt];\n                    }\n                } else {\n                    this._events = new Events();\n                    this._eventsCount = 0;\n                }\n                return this;\n            };\n            //\n            // Alias methods names because people roll like that.\n            //\n            EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n            EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n            //\n            // This function doesn't apply anymore.\n            //\n            EventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n                return this;\n            };\n            //\n            // Expose the prefix.\n            //\n            EventEmitter.prefixed = prefix;\n            //\n            // Allow `EventEmitter` to be imported as module namespace.\n            //\n            EventEmitter.EventEmitter = EventEmitter;\n            //\n            // Expose the module.\n            //\n            if (\"undefined\" !== typeof module1) {\n                module1.exports = EventEmitter;\n            }\n        /***/ },\n        /* 55 */ /***/ function(module1, exports1, __nested_webpack_require_472641__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.matchText = exports1.matchSpacing = exports1.matchNewline = exports1.matchBlot = exports1.matchAttributor = exports1.default = undefined;\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _extend2 = __nested_webpack_require_472641__(3);\n            var _extend3 = _interopRequireDefault(_extend2);\n            var _quillDelta = __nested_webpack_require_472641__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _parchment = __nested_webpack_require_472641__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_472641__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _logger = __nested_webpack_require_472641__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            var _module = __nested_webpack_require_472641__(9);\n            var _module2 = _interopRequireDefault(_module);\n            var _align = __nested_webpack_require_472641__(36);\n            var _background = __nested_webpack_require_472641__(37);\n            var _code = __nested_webpack_require_472641__(13);\n            var _code2 = _interopRequireDefault(_code);\n            var _color = __nested_webpack_require_472641__(26);\n            var _direction = __nested_webpack_require_472641__(38);\n            var _font = __nested_webpack_require_472641__(39);\n            var _size = __nested_webpack_require_472641__(40);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var debug = (0, _logger2.default)(\"quill:clipboard\");\n            var DOM_KEY = \"__ql-matcher\";\n            var CLIPBOARD_CONFIG = [\n                [\n                    Node.TEXT_NODE,\n                    matchText\n                ],\n                [\n                    Node.TEXT_NODE,\n                    matchNewline\n                ],\n                [\n                    \"br\",\n                    matchBreak\n                ],\n                [\n                    Node.ELEMENT_NODE,\n                    matchNewline\n                ],\n                [\n                    Node.ELEMENT_NODE,\n                    matchBlot\n                ],\n                [\n                    Node.ELEMENT_NODE,\n                    matchSpacing\n                ],\n                [\n                    Node.ELEMENT_NODE,\n                    matchAttributor\n                ],\n                [\n                    Node.ELEMENT_NODE,\n                    matchStyles\n                ],\n                [\n                    \"li\",\n                    matchIndent\n                ],\n                [\n                    \"b\",\n                    matchAlias.bind(matchAlias, \"bold\")\n                ],\n                [\n                    \"i\",\n                    matchAlias.bind(matchAlias, \"italic\")\n                ],\n                [\n                    \"style\",\n                    matchIgnore\n                ]\n            ];\n            var ATTRIBUTE_ATTRIBUTORS = [\n                _align.AlignAttribute,\n                _direction.DirectionAttribute\n            ].reduce(function(memo, attr) {\n                memo[attr.keyName] = attr;\n                return memo;\n            }, {});\n            var STYLE_ATTRIBUTORS = [\n                _align.AlignStyle,\n                _background.BackgroundStyle,\n                _color.ColorStyle,\n                _direction.DirectionStyle,\n                _font.FontStyle,\n                _size.SizeStyle\n            ].reduce(function(memo, attr) {\n                memo[attr.keyName] = attr;\n                return memo;\n            }, {});\n            var Clipboard = function(_Module) {\n                _inherits(Clipboard, _Module);\n                function Clipboard(quill, options) {\n                    _classCallCheck(this, Clipboard);\n                    var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this, quill, options));\n                    _this.quill.root.addEventListener(\"paste\", _this.onPaste.bind(_this));\n                    _this.container = _this.quill.addContainer(\"ql-clipboard\");\n                    _this.container.setAttribute(\"contenteditable\", true);\n                    _this.container.setAttribute(\"tabindex\", -1);\n                    _this.matchers = [];\n                    CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function(_ref) {\n                        var _ref2 = _slicedToArray(_ref, 2), selector = _ref2[0], matcher = _ref2[1];\n                        if (!options.matchVisual && matcher === matchSpacing) return;\n                        _this.addMatcher(selector, matcher);\n                    });\n                    return _this;\n                }\n                _createClass(Clipboard, [\n                    {\n                        key: \"addMatcher\",\n                        value: function addMatcher(selector, matcher) {\n                            this.matchers.push([\n                                selector,\n                                matcher\n                            ]);\n                        }\n                    },\n                    {\n                        key: \"convert\",\n                        value: function convert(html) {\n                            if (typeof html === \"string\") {\n                                this.container.innerHTML = html.replace(/\\>\\r?\\n +\\</g, \"><\"); // Remove spaces between tags\n                                return this.convert();\n                            }\n                            var formats = this.quill.getFormat(this.quill.selection.savedRange.index);\n                            if (formats[_code2.default.blotName]) {\n                                var text = this.container.innerText;\n                                this.container.innerHTML = \"\";\n                                return new _quillDelta2.default().insert(text, _defineProperty({}, _code2.default.blotName, formats[_code2.default.blotName]));\n                            }\n                            var _prepareMatching = this.prepareMatching(), _prepareMatching2 = _slicedToArray(_prepareMatching, 2), elementMatchers = _prepareMatching2[0], textMatchers = _prepareMatching2[1];\n                            var delta = traverse(this.container, elementMatchers, textMatchers);\n                            // Remove trailing newline\n                            if (deltaEndsWith(delta, \"\\n\") && delta.ops[delta.ops.length - 1].attributes == null) {\n                                delta = delta.compose(new _quillDelta2.default().retain(delta.length() - 1).delete(1));\n                            }\n                            debug.log(\"convert\", this.container.innerHTML, delta);\n                            this.container.innerHTML = \"\";\n                            return delta;\n                        }\n                    },\n                    {\n                        key: \"dangerouslyPasteHTML\",\n                        value: function dangerouslyPasteHTML(index, html) {\n                            var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _quill2.default.sources.API;\n                            if (typeof index === \"string\") {\n                                this.quill.setContents(this.convert(index), html);\n                                this.quill.setSelection(0, _quill2.default.sources.SILENT);\n                            } else {\n                                var paste = this.convert(html);\n                                this.quill.updateContents(new _quillDelta2.default().retain(index).concat(paste), source);\n                                this.quill.setSelection(index + paste.length(), _quill2.default.sources.SILENT);\n                            }\n                        }\n                    },\n                    {\n                        key: \"onPaste\",\n                        value: function onPaste(e) {\n                            var _this2 = this;\n                            if (e.defaultPrevented || !this.quill.isEnabled()) return;\n                            var range = this.quill.getSelection();\n                            var delta = new _quillDelta2.default().retain(range.index);\n                            var scrollTop = this.quill.scrollingContainer.scrollTop;\n                            this.container.focus();\n                            this.quill.selection.update(_quill2.default.sources.SILENT);\n                            setTimeout(function() {\n                                delta = delta.concat(_this2.convert()).delete(range.length);\n                                _this2.quill.updateContents(delta, _quill2.default.sources.USER);\n                                // range.length contributes to delta.length()\n                                _this2.quill.setSelection(delta.length() - range.length, _quill2.default.sources.SILENT);\n                                _this2.quill.scrollingContainer.scrollTop = scrollTop;\n                                _this2.quill.focus();\n                            }, 1);\n                        }\n                    },\n                    {\n                        key: \"prepareMatching\",\n                        value: function prepareMatching() {\n                            var _this3 = this;\n                            var elementMatchers = [], textMatchers = [];\n                            this.matchers.forEach(function(pair) {\n                                var _pair = _slicedToArray(pair, 2), selector = _pair[0], matcher = _pair[1];\n                                switch(selector){\n                                    case Node.TEXT_NODE:\n                                        textMatchers.push(matcher);\n                                        break;\n                                    case Node.ELEMENT_NODE:\n                                        elementMatchers.push(matcher);\n                                        break;\n                                    default:\n                                        [].forEach.call(_this3.container.querySelectorAll(selector), function(node) {\n                                            // TODO use weakmap\n                                            node[DOM_KEY] = node[DOM_KEY] || [];\n                                            node[DOM_KEY].push(matcher);\n                                        });\n                                        break;\n                                }\n                            });\n                            return [\n                                elementMatchers,\n                                textMatchers\n                            ];\n                        }\n                    }\n                ]);\n                return Clipboard;\n            }(_module2.default);\n            Clipboard.DEFAULTS = {\n                matchers: [],\n                matchVisual: true\n            };\n            function applyFormat(delta, format, value) {\n                if ((typeof format === \"undefined\" ? \"undefined\" : _typeof(format)) === \"object\") {\n                    return Object.keys(format).reduce(function(delta, key) {\n                        return applyFormat(delta, key, format[key]);\n                    }, delta);\n                } else {\n                    return delta.reduce(function(delta, op) {\n                        if (op.attributes && op.attributes[format]) {\n                            return delta.push(op);\n                        } else {\n                            return delta.insert(op.insert, (0, _extend3.default)({}, _defineProperty({}, format, value), op.attributes));\n                        }\n                    }, new _quillDelta2.default());\n                }\n            }\n            function computeStyle(node) {\n                if (node.nodeType !== Node.ELEMENT_NODE) return {};\n                var DOM_KEY = \"__ql-computed-style\";\n                return node[DOM_KEY] || (node[DOM_KEY] = window.getComputedStyle(node));\n            }\n            function deltaEndsWith(delta, text) {\n                var endText = \"\";\n                for(var i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i){\n                    var op = delta.ops[i];\n                    if (typeof op.insert !== \"string\") break;\n                    endText = op.insert + endText;\n                }\n                return endText.slice(-1 * text.length) === text;\n            }\n            function isLine(node) {\n                if (node.childNodes.length === 0) return false; // Exclude embed blocks\n                var style = computeStyle(node);\n                return [\n                    \"block\",\n                    \"list-item\"\n                ].indexOf(style.display) > -1;\n            }\n            function traverse(node, elementMatchers, textMatchers) {\n                // Post-order\n                if (node.nodeType === node.TEXT_NODE) {\n                    return textMatchers.reduce(function(delta, matcher) {\n                        return matcher(node, delta);\n                    }, new _quillDelta2.default());\n                } else if (node.nodeType === node.ELEMENT_NODE) {\n                    return [].reduce.call(node.childNodes || [], function(delta, childNode) {\n                        var childrenDelta = traverse(childNode, elementMatchers, textMatchers);\n                        if (childNode.nodeType === node.ELEMENT_NODE) {\n                            childrenDelta = elementMatchers.reduce(function(childrenDelta, matcher) {\n                                return matcher(childNode, childrenDelta);\n                            }, childrenDelta);\n                            childrenDelta = (childNode[DOM_KEY] || []).reduce(function(childrenDelta, matcher) {\n                                return matcher(childNode, childrenDelta);\n                            }, childrenDelta);\n                        }\n                        return delta.concat(childrenDelta);\n                    }, new _quillDelta2.default());\n                } else {\n                    return new _quillDelta2.default();\n                }\n            }\n            function matchAlias(format, node, delta) {\n                return applyFormat(delta, format, true);\n            }\n            function matchAttributor(node, delta) {\n                var attributes = _parchment2.default.Attributor.Attribute.keys(node);\n                var classes = _parchment2.default.Attributor.Class.keys(node);\n                var styles = _parchment2.default.Attributor.Style.keys(node);\n                var formats = {};\n                attributes.concat(classes).concat(styles).forEach(function(name) {\n                    var attr = _parchment2.default.query(name, _parchment2.default.Scope.ATTRIBUTE);\n                    if (attr != null) {\n                        formats[attr.attrName] = attr.value(node);\n                        if (formats[attr.attrName]) return;\n                    }\n                    attr = ATTRIBUTE_ATTRIBUTORS[name];\n                    if (attr != null && (attr.attrName === name || attr.keyName === name)) {\n                        formats[attr.attrName] = attr.value(node) || undefined;\n                    }\n                    attr = STYLE_ATTRIBUTORS[name];\n                    if (attr != null && (attr.attrName === name || attr.keyName === name)) {\n                        attr = STYLE_ATTRIBUTORS[name];\n                        formats[attr.attrName] = attr.value(node) || undefined;\n                    }\n                });\n                if (Object.keys(formats).length > 0) {\n                    delta = applyFormat(delta, formats);\n                }\n                return delta;\n            }\n            function matchBlot(node, delta) {\n                var match = _parchment2.default.query(node);\n                if (match == null) return delta;\n                if (match.prototype instanceof _parchment2.default.Embed) {\n                    var embed = {};\n                    var value = match.value(node);\n                    if (value != null) {\n                        embed[match.blotName] = value;\n                        delta = new _quillDelta2.default().insert(embed, match.formats(node));\n                    }\n                } else if (typeof match.formats === \"function\") {\n                    delta = applyFormat(delta, match.blotName, match.formats(node));\n                }\n                return delta;\n            }\n            function matchBreak(node, delta) {\n                if (!deltaEndsWith(delta, \"\\n\")) {\n                    delta.insert(\"\\n\");\n                }\n                return delta;\n            }\n            function matchIgnore() {\n                return new _quillDelta2.default();\n            }\n            function matchIndent(node, delta) {\n                var match = _parchment2.default.query(node);\n                if (match == null || match.blotName !== \"list-item\" || !deltaEndsWith(delta, \"\\n\")) {\n                    return delta;\n                }\n                var indent = -1, parent = node.parentNode;\n                while(!parent.classList.contains(\"ql-clipboard\")){\n                    if ((_parchment2.default.query(parent) || {}).blotName === \"list\") {\n                        indent += 1;\n                    }\n                    parent = parent.parentNode;\n                }\n                if (indent <= 0) return delta;\n                return delta.compose(new _quillDelta2.default().retain(delta.length() - 1).retain(1, {\n                    indent: indent\n                }));\n            }\n            function matchNewline(node, delta) {\n                if (!deltaEndsWith(delta, \"\\n\")) {\n                    if (isLine(node) || delta.length() > 0 && node.nextSibling && isLine(node.nextSibling)) {\n                        delta.insert(\"\\n\");\n                    }\n                }\n                return delta;\n            }\n            function matchSpacing(node, delta) {\n                if (isLine(node) && node.nextElementSibling != null && !deltaEndsWith(delta, \"\\n\\n\")) {\n                    var nodeHeight = node.offsetHeight + parseFloat(computeStyle(node).marginTop) + parseFloat(computeStyle(node).marginBottom);\n                    if (node.nextElementSibling.offsetTop > node.offsetTop + nodeHeight * 1.5) {\n                        delta.insert(\"\\n\");\n                    }\n                }\n                return delta;\n            }\n            function matchStyles(node, delta) {\n                var formats = {};\n                var style = node.style || {};\n                if (style.fontStyle && computeStyle(node).fontStyle === \"italic\") {\n                    formats.italic = true;\n                }\n                if (style.fontWeight && (computeStyle(node).fontWeight.startsWith(\"bold\") || parseInt(computeStyle(node).fontWeight) >= 700)) {\n                    formats.bold = true;\n                }\n                if (Object.keys(formats).length > 0) {\n                    delta = applyFormat(delta, formats);\n                }\n                if (parseFloat(style.textIndent || 0) > 0) {\n                    // Could be 0.5in\n                    delta = new _quillDelta2.default().insert(\"\t\").concat(delta);\n                }\n                return delta;\n            }\n            function matchText(node, delta) {\n                var text = node.data;\n                // Word represents empty line with <o:p>&nbsp;</o:p>\n                if (node.parentNode.tagName === \"O:P\") {\n                    return delta.insert(text.trim());\n                }\n                if (text.trim().length === 0 && node.parentNode.classList.contains(\"ql-clipboard\")) {\n                    return delta;\n                }\n                if (!computeStyle(node.parentNode).whiteSpace.startsWith(\"pre\")) {\n                    // eslint-disable-next-line func-style\n                    var replacer = function replacer(collapse, match) {\n                        match = match.replace(/[^\\u00a0]/g, \"\"); // \\u00a0 is nbsp;\n                        return match.length < 1 && collapse ? \" \" : match;\n                    };\n                    text = text.replace(/\\r\\n/g, \" \").replace(/\\n/g, \" \");\n                    text = text.replace(/\\s\\s+/g, replacer.bind(replacer, true)); // collapse whitespace\n                    if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {\n                        text = text.replace(/^\\s+/, replacer.bind(replacer, false));\n                    }\n                    if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {\n                        text = text.replace(/\\s+$/, replacer.bind(replacer, false));\n                    }\n                }\n                return delta.insert(text);\n            }\n            exports1.default = Clipboard;\n            exports1.matchAttributor = matchAttributor;\n            exports1.matchBlot = matchBlot;\n            exports1.matchNewline = matchNewline;\n            exports1.matchSpacing = matchSpacing;\n            exports1.matchText = matchText;\n        /***/ },\n        /* 56 */ /***/ function(module1, exports1, __nested_webpack_require_498229__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _inline = __nested_webpack_require_498229__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Bold = function(_Inline) {\n                _inherits(Bold, _Inline);\n                function Bold() {\n                    _classCallCheck(this, Bold);\n                    return _possibleConstructorReturn(this, (Bold.__proto__ || Object.getPrototypeOf(Bold)).apply(this, arguments));\n                }\n                _createClass(Bold, [\n                    {\n                        key: \"optimize\",\n                        value: function optimize(context) {\n                            _get(Bold.prototype.__proto__ || Object.getPrototypeOf(Bold.prototype), \"optimize\", this).call(this, context);\n                            if (this.domNode.tagName !== this.statics.tagName[0]) {\n                                this.replaceWith(this.statics.blotName);\n                            }\n                        }\n                    }\n                ], [\n                    {\n                        key: \"create\",\n                        value: function create() {\n                            return _get(Bold.__proto__ || Object.getPrototypeOf(Bold), \"create\", this).call(this);\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats() {\n                            return true;\n                        }\n                    }\n                ]);\n                return Bold;\n            }(_inline2.default);\n            Bold.blotName = \"bold\";\n            Bold.tagName = [\n                \"STRONG\",\n                \"B\"\n            ];\n            exports1.default = Bold;\n        /***/ },\n        /* 57 */ /***/ function(module1, exports1, __nested_webpack_require_503384__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.addControls = exports1.default = undefined;\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _quillDelta = __nested_webpack_require_503384__(2);\n            var _quillDelta2 = _interopRequireDefault(_quillDelta);\n            var _parchment = __nested_webpack_require_503384__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_503384__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _logger = __nested_webpack_require_503384__(10);\n            var _logger2 = _interopRequireDefault(_logger);\n            var _module = __nested_webpack_require_503384__(9);\n            var _module2 = _interopRequireDefault(_module);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var debug = (0, _logger2.default)(\"quill:toolbar\");\n            var Toolbar = function(_Module) {\n                _inherits(Toolbar, _Module);\n                function Toolbar(quill, options) {\n                    _classCallCheck(this, Toolbar);\n                    var _this = _possibleConstructorReturn(this, (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(this, quill, options));\n                    if (Array.isArray(_this.options.container)) {\n                        var container = document.createElement(\"div\");\n                        addControls(container, _this.options.container);\n                        quill.container.parentNode.insertBefore(container, quill.container);\n                        _this.container = container;\n                    } else if (typeof _this.options.container === \"string\") {\n                        _this.container = document.querySelector(_this.options.container);\n                    } else {\n                        _this.container = _this.options.container;\n                    }\n                    if (!(_this.container instanceof HTMLElement)) {\n                        var _ret;\n                        return _ret = debug.error(\"Container required for toolbar\", _this.options), _possibleConstructorReturn(_this, _ret);\n                    }\n                    _this.container.classList.add(\"ql-toolbar\");\n                    _this.controls = [];\n                    _this.handlers = {};\n                    Object.keys(_this.options.handlers).forEach(function(format) {\n                        _this.addHandler(format, _this.options.handlers[format]);\n                    });\n                    [].forEach.call(_this.container.querySelectorAll(\"button, select\"), function(input) {\n                        _this.attach(input);\n                    });\n                    _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function(type, range) {\n                        if (type === _quill2.default.events.SELECTION_CHANGE) {\n                            _this.update(range);\n                        }\n                    });\n                    _this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function() {\n                        var _this$quill$selection = _this.quill.selection.getRange(), _this$quill$selection2 = _slicedToArray(_this$quill$selection, 1), range = _this$quill$selection2[0]; // quill.getSelection triggers update\n                        _this.update(range);\n                    });\n                    return _this;\n                }\n                _createClass(Toolbar, [\n                    {\n                        key: \"addHandler\",\n                        value: function addHandler(format, handler) {\n                            this.handlers[format] = handler;\n                        }\n                    },\n                    {\n                        key: \"attach\",\n                        value: function attach(input) {\n                            var _this2 = this;\n                            var format = [].find.call(input.classList, function(className) {\n                                return className.indexOf(\"ql-\") === 0;\n                            });\n                            if (!format) return;\n                            format = format.slice(\"ql-\".length);\n                            if (input.tagName === \"BUTTON\") {\n                                input.setAttribute(\"type\", \"button\");\n                            }\n                            if (this.handlers[format] == null) {\n                                if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[format] == null) {\n                                    debug.warn(\"ignoring attaching to disabled format\", format, input);\n                                    return;\n                                }\n                                if (_parchment2.default.query(format) == null) {\n                                    debug.warn(\"ignoring attaching to nonexistent format\", format, input);\n                                    return;\n                                }\n                            }\n                            var eventName = input.tagName === \"SELECT\" ? \"change\" : \"click\";\n                            input.addEventListener(eventName, function(e) {\n                                var value = void 0;\n                                if (input.tagName === \"SELECT\") {\n                                    if (input.selectedIndex < 0) return;\n                                    var selected = input.options[input.selectedIndex];\n                                    if (selected.hasAttribute(\"selected\")) {\n                                        value = false;\n                                    } else {\n                                        value = selected.value || false;\n                                    }\n                                } else {\n                                    if (input.classList.contains(\"ql-active\")) {\n                                        value = false;\n                                    } else {\n                                        value = input.value || !input.hasAttribute(\"value\");\n                                    }\n                                    e.preventDefault();\n                                }\n                                _this2.quill.focus();\n                                var _quill$selection$getR = _this2.quill.selection.getRange(), _quill$selection$getR2 = _slicedToArray(_quill$selection$getR, 1), range = _quill$selection$getR2[0];\n                                if (_this2.handlers[format] != null) {\n                                    _this2.handlers[format].call(_this2, value);\n                                } else if (_parchment2.default.query(format).prototype instanceof _parchment2.default.Embed) {\n                                    value = prompt(\"Enter \" + format);\n                                    if (!value) return;\n                                    _this2.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert(_defineProperty({}, format, value)), _quill2.default.sources.USER);\n                                } else {\n                                    _this2.quill.format(format, value, _quill2.default.sources.USER);\n                                }\n                                _this2.update(range);\n                            });\n                            // TODO use weakmap\n                            this.controls.push([\n                                format,\n                                input\n                            ]);\n                        }\n                    },\n                    {\n                        key: \"update\",\n                        value: function update(range) {\n                            var formats = range == null ? {} : this.quill.getFormat(range);\n                            this.controls.forEach(function(pair) {\n                                var _pair = _slicedToArray(pair, 2), format = _pair[0], input = _pair[1];\n                                if (input.tagName === \"SELECT\") {\n                                    var option = void 0;\n                                    if (range == null) {\n                                        option = null;\n                                    } else if (formats[format] == null) {\n                                        option = input.querySelector(\"option[selected]\");\n                                    } else if (!Array.isArray(formats[format])) {\n                                        var value = formats[format];\n                                        if (typeof value === \"string\") {\n                                            value = value.replace(/\\\"/g, '\\\\\"');\n                                        }\n                                        option = input.querySelector('option[value=\"' + value + '\"]');\n                                    }\n                                    if (option == null) {\n                                        input.value = \"\"; // TODO make configurable?\n                                        input.selectedIndex = -1;\n                                    } else {\n                                        option.selected = true;\n                                    }\n                                } else {\n                                    if (range == null) {\n                                        input.classList.remove(\"ql-active\");\n                                    } else if (input.hasAttribute(\"value\")) {\n                                        // both being null should match (default values)\n                                        // '1' should match with 1 (headers)\n                                        var isActive = formats[format] === input.getAttribute(\"value\") || formats[format] != null && formats[format].toString() === input.getAttribute(\"value\") || formats[format] == null && !input.getAttribute(\"value\");\n                                        input.classList.toggle(\"ql-active\", isActive);\n                                    } else {\n                                        input.classList.toggle(\"ql-active\", formats[format] != null);\n                                    }\n                                }\n                            });\n                        }\n                    }\n                ]);\n                return Toolbar;\n            }(_module2.default);\n            Toolbar.DEFAULTS = {};\n            function addButton(container, format, value) {\n                var input = document.createElement(\"button\");\n                input.setAttribute(\"type\", \"button\");\n                input.classList.add(\"ql-\" + format);\n                if (value != null) {\n                    input.value = value;\n                }\n                container.appendChild(input);\n            }\n            function addControls(container, groups) {\n                if (!Array.isArray(groups[0])) {\n                    groups = [\n                        groups\n                    ];\n                }\n                groups.forEach(function(controls) {\n                    var group = document.createElement(\"span\");\n                    group.classList.add(\"ql-formats\");\n                    controls.forEach(function(control) {\n                        if (typeof control === \"string\") {\n                            addButton(group, control);\n                        } else {\n                            var format = Object.keys(control)[0];\n                            var value = control[format];\n                            if (Array.isArray(value)) {\n                                addSelect(group, format, value);\n                            } else {\n                                addButton(group, format, value);\n                            }\n                        }\n                    });\n                    container.appendChild(group);\n                });\n            }\n            function addSelect(container, format, values) {\n                var input = document.createElement(\"select\");\n                input.classList.add(\"ql-\" + format);\n                values.forEach(function(value) {\n                    var option = document.createElement(\"option\");\n                    if (value !== false) {\n                        option.setAttribute(\"value\", value);\n                    } else {\n                        option.setAttribute(\"selected\", \"selected\");\n                    }\n                    input.appendChild(option);\n                });\n                container.appendChild(input);\n            }\n            Toolbar.DEFAULTS = {\n                container: null,\n                handlers: {\n                    clean: function clean() {\n                        var _this3 = this;\n                        var range = this.quill.getSelection();\n                        if (range == null) return;\n                        if (range.length == 0) {\n                            var formats = this.quill.getFormat();\n                            Object.keys(formats).forEach(function(name) {\n                                // Clean functionality in existing apps only clean inline formats\n                                if (_parchment2.default.query(name, _parchment2.default.Scope.INLINE) != null) {\n                                    _this3.quill.format(name, false);\n                                }\n                            });\n                        } else {\n                            this.quill.removeFormat(range, _quill2.default.sources.USER);\n                        }\n                    },\n                    direction: function direction(value) {\n                        var align = this.quill.getFormat()[\"align\"];\n                        if (value === \"rtl\" && align == null) {\n                            this.quill.format(\"align\", \"right\", _quill2.default.sources.USER);\n                        } else if (!value && align === \"right\") {\n                            this.quill.format(\"align\", false, _quill2.default.sources.USER);\n                        }\n                        this.quill.format(\"direction\", value, _quill2.default.sources.USER);\n                    },\n                    indent: function indent(value) {\n                        var range = this.quill.getSelection();\n                        var formats = this.quill.getFormat(range);\n                        var indent = parseInt(formats.indent || 0);\n                        if (value === \"+1\" || value === \"-1\") {\n                            var modifier = value === \"+1\" ? 1 : -1;\n                            if (formats.direction === \"rtl\") modifier *= -1;\n                            this.quill.format(\"indent\", indent + modifier, _quill2.default.sources.USER);\n                        }\n                    },\n                    link: function link(value) {\n                        if (value === true) {\n                            value = prompt(\"Enter link URL:\");\n                        }\n                        this.quill.format(\"link\", value, _quill2.default.sources.USER);\n                    },\n                    list: function list(value) {\n                        var range = this.quill.getSelection();\n                        var formats = this.quill.getFormat(range);\n                        if (value === \"check\") {\n                            if (formats[\"list\"] === \"checked\" || formats[\"list\"] === \"unchecked\") {\n                                this.quill.format(\"list\", false, _quill2.default.sources.USER);\n                            } else {\n                                this.quill.format(\"list\", \"unchecked\", _quill2.default.sources.USER);\n                            }\n                        } else {\n                            this.quill.format(\"list\", value, _quill2.default.sources.USER);\n                        }\n                    }\n                }\n            };\n            exports1.default = Toolbar;\n            exports1.addControls = addControls;\n        /***/ },\n        /* 58 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <polyline class=\"ql-even ql-stroke\" points=\"5 7 3 9 5 11\"></polyline> <polyline class=\"ql-even ql-stroke\" points=\"13 7 15 9 13 11\"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>';\n        /***/ },\n        /* 59 */ /***/ function(module1, exports1, __nested_webpack_require_523738__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _picker = __nested_webpack_require_523738__(28);\n            var _picker2 = _interopRequireDefault(_picker);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ColorPicker = function(_Picker) {\n                _inherits(ColorPicker, _Picker);\n                function ColorPicker(select, label) {\n                    _classCallCheck(this, ColorPicker);\n                    var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this, select));\n                    _this.label.innerHTML = label;\n                    _this.container.classList.add(\"ql-color-picker\");\n                    [].slice.call(_this.container.querySelectorAll(\".ql-picker-item\"), 0, 7).forEach(function(item) {\n                        item.classList.add(\"ql-primary\");\n                    });\n                    return _this;\n                }\n                _createClass(ColorPicker, [\n                    {\n                        key: \"buildItem\",\n                        value: function buildItem(option) {\n                            var item = _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), \"buildItem\", this).call(this, option);\n                            item.style.backgroundColor = option.getAttribute(\"value\") || \"\";\n                            return item;\n                        }\n                    },\n                    {\n                        key: \"selectItem\",\n                        value: function selectItem(item, trigger) {\n                            _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), \"selectItem\", this).call(this, item, trigger);\n                            var colorLabel = this.label.querySelector(\".ql-color-label\");\n                            var value = item ? item.getAttribute(\"data-value\") || \"\" : \"\";\n                            if (colorLabel) {\n                                if (colorLabel.tagName === \"line\") {\n                                    colorLabel.style.stroke = value;\n                                } else {\n                                    colorLabel.style.fill = value;\n                                }\n                            }\n                        }\n                    }\n                ]);\n                return ColorPicker;\n            }(_picker2.default);\n            exports1.default = ColorPicker;\n        /***/ },\n        /* 60 */ /***/ function(module1, exports1, __nested_webpack_require_529553__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _picker = __nested_webpack_require_529553__(28);\n            var _picker2 = _interopRequireDefault(_picker);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var IconPicker = function(_Picker) {\n                _inherits(IconPicker, _Picker);\n                function IconPicker(select, icons) {\n                    _classCallCheck(this, IconPicker);\n                    var _this = _possibleConstructorReturn(this, (IconPicker.__proto__ || Object.getPrototypeOf(IconPicker)).call(this, select));\n                    _this.container.classList.add(\"ql-icon-picker\");\n                    [].forEach.call(_this.container.querySelectorAll(\".ql-picker-item\"), function(item) {\n                        item.innerHTML = icons[item.getAttribute(\"data-value\") || \"\"];\n                    });\n                    _this.defaultItem = _this.container.querySelector(\".ql-selected\");\n                    _this.selectItem(_this.defaultItem);\n                    return _this;\n                }\n                _createClass(IconPicker, [\n                    {\n                        key: \"selectItem\",\n                        value: function selectItem(item, trigger) {\n                            _get(IconPicker.prototype.__proto__ || Object.getPrototypeOf(IconPicker.prototype), \"selectItem\", this).call(this, item, trigger);\n                            item = item || this.defaultItem;\n                            this.label.innerHTML = item.innerHTML;\n                        }\n                    }\n                ]);\n                return IconPicker;\n            }(_picker2.default);\n            exports1.default = IconPicker;\n        /***/ },\n        /* 61 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var Tooltip = function() {\n                function Tooltip(quill, boundsContainer) {\n                    var _this = this;\n                    _classCallCheck(this, Tooltip);\n                    this.quill = quill;\n                    this.boundsContainer = boundsContainer || document.body;\n                    this.root = quill.addContainer(\"ql-tooltip\");\n                    this.root.innerHTML = this.constructor.TEMPLATE;\n                    if (this.quill.root === this.quill.scrollingContainer) {\n                        this.quill.root.addEventListener(\"scroll\", function() {\n                            _this.root.style.marginTop = -1 * _this.quill.root.scrollTop + \"px\";\n                        });\n                    }\n                    this.hide();\n                }\n                _createClass(Tooltip, [\n                    {\n                        key: \"hide\",\n                        value: function hide() {\n                            this.root.classList.add(\"ql-hidden\");\n                        }\n                    },\n                    {\n                        key: \"position\",\n                        value: function position(reference) {\n                            var left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;\n                            // root.scrollTop should be 0 if scrollContainer !== root\n                            var top = reference.bottom + this.quill.root.scrollTop;\n                            this.root.style.left = left + \"px\";\n                            this.root.style.top = top + \"px\";\n                            this.root.classList.remove(\"ql-flip\");\n                            var containerBounds = this.boundsContainer.getBoundingClientRect();\n                            var rootBounds = this.root.getBoundingClientRect();\n                            var shift = 0;\n                            if (rootBounds.right > containerBounds.right) {\n                                shift = containerBounds.right - rootBounds.right;\n                                this.root.style.left = left + shift + \"px\";\n                            }\n                            if (rootBounds.left < containerBounds.left) {\n                                shift = containerBounds.left - rootBounds.left;\n                                this.root.style.left = left + shift + \"px\";\n                            }\n                            if (rootBounds.bottom > containerBounds.bottom) {\n                                var height = rootBounds.bottom - rootBounds.top;\n                                var verticalShift = reference.bottom - reference.top + height;\n                                this.root.style.top = top - verticalShift + \"px\";\n                                this.root.classList.add(\"ql-flip\");\n                            }\n                            return shift;\n                        }\n                    },\n                    {\n                        key: \"show\",\n                        value: function show() {\n                            this.root.classList.remove(\"ql-editing\");\n                            this.root.classList.remove(\"ql-hidden\");\n                        }\n                    }\n                ]);\n                return Tooltip;\n            }();\n            exports1.default = Tooltip;\n        /***/ },\n        /* 62 */ /***/ function(module1, exports1, __nested_webpack_require_539229__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _slicedToArray = function() {\n                function sliceIterator(arr, i) {\n                    var _arr = [];\n                    var _n = true;\n                    var _d = false;\n                    var _e = undefined;\n                    try {\n                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                            _arr.push(_s.value);\n                            if (i && _arr.length === i) break;\n                        }\n                    } catch (err) {\n                        _d = true;\n                        _e = err;\n                    } finally{\n                        try {\n                            if (!_n && _i[\"return\"]) _i[\"return\"]();\n                        } finally{\n                            if (_d) throw _e;\n                        }\n                    }\n                    return _arr;\n                }\n                return function(arr, i) {\n                    if (Array.isArray(arr)) {\n                        return arr;\n                    } else if (Symbol.iterator in Object(arr)) {\n                        return sliceIterator(arr, i);\n                    } else {\n                        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                    }\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _extend = __nested_webpack_require_539229__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _emitter = __nested_webpack_require_539229__(8);\n            var _emitter2 = _interopRequireDefault(_emitter);\n            var _base = __nested_webpack_require_539229__(43);\n            var _base2 = _interopRequireDefault(_base);\n            var _link = __nested_webpack_require_539229__(27);\n            var _link2 = _interopRequireDefault(_link);\n            var _selection = __nested_webpack_require_539229__(15);\n            var _icons = __nested_webpack_require_539229__(41);\n            var _icons2 = _interopRequireDefault(_icons);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var TOOLBAR_CONFIG = [\n                [\n                    {\n                        header: [\n                            \"1\",\n                            \"2\",\n                            \"3\",\n                            false\n                        ]\n                    }\n                ],\n                [\n                    \"bold\",\n                    \"italic\",\n                    \"underline\",\n                    \"link\"\n                ],\n                [\n                    {\n                        list: \"ordered\"\n                    },\n                    {\n                        list: \"bullet\"\n                    }\n                ],\n                [\n                    \"clean\"\n                ]\n            ];\n            var SnowTheme = function(_BaseTheme) {\n                _inherits(SnowTheme, _BaseTheme);\n                function SnowTheme(quill, options) {\n                    _classCallCheck(this, SnowTheme);\n                    if (options.modules.toolbar != null && options.modules.toolbar.container == null) {\n                        options.modules.toolbar.container = TOOLBAR_CONFIG;\n                    }\n                    var _this = _possibleConstructorReturn(this, (SnowTheme.__proto__ || Object.getPrototypeOf(SnowTheme)).call(this, quill, options));\n                    _this.quill.container.classList.add(\"ql-snow\");\n                    return _this;\n                }\n                _createClass(SnowTheme, [\n                    {\n                        key: \"extendToolbar\",\n                        value: function extendToolbar(toolbar) {\n                            toolbar.container.classList.add(\"ql-snow\");\n                            this.buildButtons([].slice.call(toolbar.container.querySelectorAll(\"button\")), _icons2.default);\n                            this.buildPickers([].slice.call(toolbar.container.querySelectorAll(\"select\")), _icons2.default);\n                            this.tooltip = new SnowTooltip(this.quill, this.options.bounds);\n                            if (toolbar.container.querySelector(\".ql-link\")) {\n                                this.quill.keyboard.addBinding({\n                                    key: \"K\",\n                                    shortKey: true\n                                }, function(range, context) {\n                                    toolbar.handlers[\"link\"].call(toolbar, !context.format.link);\n                                });\n                            }\n                        }\n                    }\n                ]);\n                return SnowTheme;\n            }(_base2.default);\n            SnowTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {\n                modules: {\n                    toolbar: {\n                        handlers: {\n                            link: function link(value) {\n                                if (value) {\n                                    var range = this.quill.getSelection();\n                                    if (range == null || range.length == 0) return;\n                                    var preview = this.quill.getText(range);\n                                    if (/^\\S+@\\S+\\.\\S+$/.test(preview) && preview.indexOf(\"mailto:\") !== 0) {\n                                        preview = \"mailto:\" + preview;\n                                    }\n                                    var tooltip = this.quill.theme.tooltip;\n                                    tooltip.edit(\"link\", preview);\n                                } else {\n                                    this.quill.format(\"link\", false);\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n            var SnowTooltip = function(_BaseTooltip) {\n                _inherits(SnowTooltip, _BaseTooltip);\n                function SnowTooltip(quill, bounds) {\n                    _classCallCheck(this, SnowTooltip);\n                    var _this2 = _possibleConstructorReturn(this, (SnowTooltip.__proto__ || Object.getPrototypeOf(SnowTooltip)).call(this, quill, bounds));\n                    _this2.preview = _this2.root.querySelector(\"a.ql-preview\");\n                    return _this2;\n                }\n                _createClass(SnowTooltip, [\n                    {\n                        key: \"listen\",\n                        value: function listen() {\n                            var _this3 = this;\n                            _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), \"listen\", this).call(this);\n                            this.root.querySelector(\"a.ql-action\").addEventListener(\"click\", function(event) {\n                                if (_this3.root.classList.contains(\"ql-editing\")) {\n                                    _this3.save();\n                                } else {\n                                    _this3.edit(\"link\", _this3.preview.textContent);\n                                }\n                                event.preventDefault();\n                            });\n                            this.root.querySelector(\"a.ql-remove\").addEventListener(\"click\", function(event) {\n                                if (_this3.linkRange != null) {\n                                    var range = _this3.linkRange;\n                                    _this3.restoreFocus();\n                                    _this3.quill.formatText(range, \"link\", false, _emitter2.default.sources.USER);\n                                    delete _this3.linkRange;\n                                }\n                                event.preventDefault();\n                                _this3.hide();\n                            });\n                            this.quill.on(_emitter2.default.events.SELECTION_CHANGE, function(range, oldRange, source) {\n                                if (range == null) return;\n                                if (range.length === 0 && source === _emitter2.default.sources.USER) {\n                                    var _quill$scroll$descend = _this3.quill.scroll.descendant(_link2.default, range.index), _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2), link = _quill$scroll$descend2[0], offset = _quill$scroll$descend2[1];\n                                    if (link != null) {\n                                        _this3.linkRange = new _selection.Range(range.index - offset, link.length());\n                                        var preview = _link2.default.formats(link.domNode);\n                                        _this3.preview.textContent = preview;\n                                        _this3.preview.setAttribute(\"href\", preview);\n                                        _this3.show();\n                                        _this3.position(_this3.quill.getBounds(_this3.linkRange));\n                                        return;\n                                    }\n                                } else {\n                                    delete _this3.linkRange;\n                                }\n                                _this3.hide();\n                            });\n                        }\n                    },\n                    {\n                        key: \"show\",\n                        value: function show() {\n                            _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), \"show\", this).call(this);\n                            this.root.removeAttribute(\"data-mode\");\n                        }\n                    }\n                ]);\n                return SnowTooltip;\n            }(_base.BaseTooltip);\n            SnowTooltip.TEMPLATE = [\n                '<a class=\"ql-preview\" rel=\"noopener noreferrer\" target=\"_blank\" href=\"about:blank\"></a>',\n                '<input type=\"text\" data-formula=\"e=mc^2\" data-link=\"https://quilljs.com\" data-video=\"Embed URL\">',\n                '<a class=\"ql-action\"></a>',\n                '<a class=\"ql-remove\"></a>'\n            ].join(\"\");\n            exports1.default = SnowTheme;\n        /***/ },\n        /* 63 */ /***/ function(module1, exports1, __nested_webpack_require_552733__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _core = __nested_webpack_require_552733__(29);\n            var _core2 = _interopRequireDefault(_core);\n            var _align = __nested_webpack_require_552733__(36);\n            var _direction = __nested_webpack_require_552733__(38);\n            var _indent = __nested_webpack_require_552733__(64);\n            var _blockquote = __nested_webpack_require_552733__(65);\n            var _blockquote2 = _interopRequireDefault(_blockquote);\n            var _header = __nested_webpack_require_552733__(66);\n            var _header2 = _interopRequireDefault(_header);\n            var _list = __nested_webpack_require_552733__(67);\n            var _list2 = _interopRequireDefault(_list);\n            var _background = __nested_webpack_require_552733__(37);\n            var _color = __nested_webpack_require_552733__(26);\n            var _font = __nested_webpack_require_552733__(39);\n            var _size = __nested_webpack_require_552733__(40);\n            var _bold = __nested_webpack_require_552733__(56);\n            var _bold2 = _interopRequireDefault(_bold);\n            var _italic = __nested_webpack_require_552733__(68);\n            var _italic2 = _interopRequireDefault(_italic);\n            var _link = __nested_webpack_require_552733__(27);\n            var _link2 = _interopRequireDefault(_link);\n            var _script = __nested_webpack_require_552733__(69);\n            var _script2 = _interopRequireDefault(_script);\n            var _strike = __nested_webpack_require_552733__(70);\n            var _strike2 = _interopRequireDefault(_strike);\n            var _underline = __nested_webpack_require_552733__(71);\n            var _underline2 = _interopRequireDefault(_underline);\n            var _image = __nested_webpack_require_552733__(72);\n            var _image2 = _interopRequireDefault(_image);\n            var _video = __nested_webpack_require_552733__(73);\n            var _video2 = _interopRequireDefault(_video);\n            var _code = __nested_webpack_require_552733__(13);\n            var _code2 = _interopRequireDefault(_code);\n            var _formula = __nested_webpack_require_552733__(74);\n            var _formula2 = _interopRequireDefault(_formula);\n            var _syntax = __nested_webpack_require_552733__(75);\n            var _syntax2 = _interopRequireDefault(_syntax);\n            var _toolbar = __nested_webpack_require_552733__(57);\n            var _toolbar2 = _interopRequireDefault(_toolbar);\n            var _icons = __nested_webpack_require_552733__(41);\n            var _icons2 = _interopRequireDefault(_icons);\n            var _picker = __nested_webpack_require_552733__(28);\n            var _picker2 = _interopRequireDefault(_picker);\n            var _colorPicker = __nested_webpack_require_552733__(59);\n            var _colorPicker2 = _interopRequireDefault(_colorPicker);\n            var _iconPicker = __nested_webpack_require_552733__(60);\n            var _iconPicker2 = _interopRequireDefault(_iconPicker);\n            var _tooltip = __nested_webpack_require_552733__(61);\n            var _tooltip2 = _interopRequireDefault(_tooltip);\n            var _bubble = __nested_webpack_require_552733__(108);\n            var _bubble2 = _interopRequireDefault(_bubble);\n            var _snow = __nested_webpack_require_552733__(62);\n            var _snow2 = _interopRequireDefault(_snow);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            _core2.default.register({\n                \"attributors/attribute/direction\": _direction.DirectionAttribute,\n                \"attributors/class/align\": _align.AlignClass,\n                \"attributors/class/background\": _background.BackgroundClass,\n                \"attributors/class/color\": _color.ColorClass,\n                \"attributors/class/direction\": _direction.DirectionClass,\n                \"attributors/class/font\": _font.FontClass,\n                \"attributors/class/size\": _size.SizeClass,\n                \"attributors/style/align\": _align.AlignStyle,\n                \"attributors/style/background\": _background.BackgroundStyle,\n                \"attributors/style/color\": _color.ColorStyle,\n                \"attributors/style/direction\": _direction.DirectionStyle,\n                \"attributors/style/font\": _font.FontStyle,\n                \"attributors/style/size\": _size.SizeStyle\n            }, true);\n            _core2.default.register({\n                \"formats/align\": _align.AlignClass,\n                \"formats/direction\": _direction.DirectionClass,\n                \"formats/indent\": _indent.IndentClass,\n                \"formats/background\": _background.BackgroundStyle,\n                \"formats/color\": _color.ColorStyle,\n                \"formats/font\": _font.FontClass,\n                \"formats/size\": _size.SizeClass,\n                \"formats/blockquote\": _blockquote2.default,\n                \"formats/code-block\": _code2.default,\n                \"formats/header\": _header2.default,\n                \"formats/list\": _list2.default,\n                \"formats/bold\": _bold2.default,\n                \"formats/code\": _code.Code,\n                \"formats/italic\": _italic2.default,\n                \"formats/link\": _link2.default,\n                \"formats/script\": _script2.default,\n                \"formats/strike\": _strike2.default,\n                \"formats/underline\": _underline2.default,\n                \"formats/image\": _image2.default,\n                \"formats/video\": _video2.default,\n                \"formats/list/item\": _list.ListItem,\n                \"modules/formula\": _formula2.default,\n                \"modules/syntax\": _syntax2.default,\n                \"modules/toolbar\": _toolbar2.default,\n                \"themes/bubble\": _bubble2.default,\n                \"themes/snow\": _snow2.default,\n                \"ui/icons\": _icons2.default,\n                \"ui/picker\": _picker2.default,\n                \"ui/icon-picker\": _iconPicker2.default,\n                \"ui/color-picker\": _colorPicker2.default,\n                \"ui/tooltip\": _tooltip2.default\n            }, true);\n            exports1.default = _core2.default;\n        /***/ },\n        /* 64 */ /***/ function(module1, exports1, __nested_webpack_require_558705__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.IndentClass = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_558705__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var IdentAttributor = function(_Parchment$Attributor) {\n                _inherits(IdentAttributor, _Parchment$Attributor);\n                function IdentAttributor() {\n                    _classCallCheck(this, IdentAttributor);\n                    return _possibleConstructorReturn(this, (IdentAttributor.__proto__ || Object.getPrototypeOf(IdentAttributor)).apply(this, arguments));\n                }\n                _createClass(IdentAttributor, [\n                    {\n                        key: \"add\",\n                        value: function add(node, value) {\n                            if (value === \"+1\" || value === \"-1\") {\n                                var indent = this.value(node) || 0;\n                                value = value === \"+1\" ? indent + 1 : indent - 1;\n                            }\n                            if (value === 0) {\n                                this.remove(node);\n                                return true;\n                            } else {\n                                return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), \"add\", this).call(this, node, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"canAdd\",\n                        value: function canAdd(node, value) {\n                            return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), \"canAdd\", this).call(this, node, value) || _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), \"canAdd\", this).call(this, node, parseInt(value));\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(node) {\n                            return parseInt(_get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), \"value\", this).call(this, node)) || undefined; // Don't return NaN\n                        }\n                    }\n                ]);\n                return IdentAttributor;\n            }(_parchment2.default.Attributor.Class);\n            var IndentClass = new IdentAttributor(\"indent\", \"ql-indent\", {\n                scope: _parchment2.default.Scope.BLOCK,\n                whitelist: [\n                    1,\n                    2,\n                    3,\n                    4,\n                    5,\n                    6,\n                    7,\n                    8\n                ]\n            });\n            exports1.IndentClass = IndentClass;\n        /***/ },\n        /* 65 */ /***/ function(module1, exports1, __nested_webpack_require_564967__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _block = __nested_webpack_require_564967__(4);\n            var _block2 = _interopRequireDefault(_block);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Blockquote = function(_Block) {\n                _inherits(Blockquote, _Block);\n                function Blockquote() {\n                    _classCallCheck(this, Blockquote);\n                    return _possibleConstructorReturn(this, (Blockquote.__proto__ || Object.getPrototypeOf(Blockquote)).apply(this, arguments));\n                }\n                return Blockquote;\n            }(_block2.default);\n            Blockquote.blotName = \"blockquote\";\n            Blockquote.tagName = \"blockquote\";\n            exports1.default = Blockquote;\n        /***/ },\n        /* 66 */ /***/ function(module1, exports1, __nested_webpack_require_567346__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _block = __nested_webpack_require_567346__(4);\n            var _block2 = _interopRequireDefault(_block);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Header = function(_Block) {\n                _inherits(Header, _Block);\n                function Header() {\n                    _classCallCheck(this, Header);\n                    return _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).apply(this, arguments));\n                }\n                _createClass(Header, null, [\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            return this.tagName.indexOf(domNode.tagName) + 1;\n                        }\n                    }\n                ]);\n                return Header;\n            }(_block2.default);\n            Header.blotName = \"header\";\n            Header.tagName = [\n                \"H1\",\n                \"H2\",\n                \"H3\",\n                \"H4\",\n                \"H5\",\n                \"H6\"\n            ];\n            exports1.default = Header;\n        /***/ },\n        /* 67 */ /***/ function(module1, exports1, __nested_webpack_require_570996__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.ListItem = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_570996__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _block = __nested_webpack_require_570996__(4);\n            var _block2 = _interopRequireDefault(_block);\n            var _container = __nested_webpack_require_570996__(25);\n            var _container2 = _interopRequireDefault(_container);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ListItem = function(_Block) {\n                _inherits(ListItem, _Block);\n                function ListItem() {\n                    _classCallCheck(this, ListItem);\n                    return _possibleConstructorReturn(this, (ListItem.__proto__ || Object.getPrototypeOf(ListItem)).apply(this, arguments));\n                }\n                _createClass(ListItem, [\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (name === List.blotName && !value) {\n                                this.replaceWith(_parchment2.default.create(this.statics.scope));\n                            } else {\n                                _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), \"format\", this).call(this, name, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"remove\",\n                        value: function remove() {\n                            if (this.prev == null && this.next == null) {\n                                this.parent.remove();\n                            } else {\n                                _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), \"remove\", this).call(this);\n                            }\n                        }\n                    },\n                    {\n                        key: \"replaceWith\",\n                        value: function replaceWith(name, value) {\n                            this.parent.isolate(this.offset(this.parent), this.length());\n                            if (name === this.parent.statics.blotName) {\n                                this.parent.replaceWith(name, value);\n                                return this;\n                            } else {\n                                this.parent.unwrap();\n                                return _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), \"replaceWith\", this).call(this, name, value);\n                            }\n                        }\n                    }\n                ], [\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            return domNode.tagName === this.tagName ? undefined : _get(ListItem.__proto__ || Object.getPrototypeOf(ListItem), \"formats\", this).call(this, domNode);\n                        }\n                    }\n                ]);\n                return ListItem;\n            }(_block2.default);\n            ListItem.blotName = \"list-item\";\n            ListItem.tagName = \"LI\";\n            var List = function(_Container) {\n                _inherits(List, _Container);\n                _createClass(List, null, [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var tagName = value === \"ordered\" ? \"OL\" : \"UL\";\n                            var node = _get(List.__proto__ || Object.getPrototypeOf(List), \"create\", this).call(this, tagName);\n                            if (value === \"checked\" || value === \"unchecked\") {\n                                node.setAttribute(\"data-checked\", value === \"checked\");\n                            }\n                            return node;\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            if (domNode.tagName === \"OL\") return \"ordered\";\n                            if (domNode.tagName === \"UL\") {\n                                if (domNode.hasAttribute(\"data-checked\")) {\n                                    return domNode.getAttribute(\"data-checked\") === \"true\" ? \"checked\" : \"unchecked\";\n                                } else {\n                                    return \"bullet\";\n                                }\n                            }\n                            return undefined;\n                        }\n                    }\n                ]);\n                function List(domNode) {\n                    _classCallCheck(this, List);\n                    var _this2 = _possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this, domNode));\n                    var listEventHandler = function listEventHandler(e) {\n                        if (e.target.parentNode !== domNode) return;\n                        var format = _this2.statics.formats(domNode);\n                        var blot = _parchment2.default.find(e.target);\n                        if (format === \"checked\") {\n                            blot.format(\"list\", \"unchecked\");\n                        } else if (format === \"unchecked\") {\n                            blot.format(\"list\", \"checked\");\n                        }\n                    };\n                    domNode.addEventListener(\"touchstart\", listEventHandler);\n                    domNode.addEventListener(\"mousedown\", listEventHandler);\n                    return _this2;\n                }\n                _createClass(List, [\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (this.children.length > 0) {\n                                this.children.tail.format(name, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats() {\n                            // We don't inherit from FormatBlot\n                            return _defineProperty({}, this.statics.blotName, this.statics.formats(this.domNode));\n                        }\n                    },\n                    {\n                        key: \"insertBefore\",\n                        value: function insertBefore(blot, ref) {\n                            if (blot instanceof ListItem) {\n                                _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), \"insertBefore\", this).call(this, blot, ref);\n                            } else {\n                                var index = ref == null ? this.length() : ref.offset(this);\n                                var after = this.split(index);\n                                after.parent.insertBefore(blot, after);\n                            }\n                        }\n                    },\n                    {\n                        key: \"optimize\",\n                        value: function optimize(context) {\n                            _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), \"optimize\", this).call(this, context);\n                            var next = this.next;\n                            if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName && next.domNode.getAttribute(\"data-checked\") === this.domNode.getAttribute(\"data-checked\")) {\n                                next.moveChildren(this);\n                                next.remove();\n                            }\n                        }\n                    },\n                    {\n                        key: \"replace\",\n                        value: function replace(target) {\n                            if (target.statics.blotName !== this.statics.blotName) {\n                                var item = _parchment2.default.create(this.statics.defaultChild);\n                                target.moveChildren(item);\n                                this.appendChild(item);\n                            }\n                            _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), \"replace\", this).call(this, target);\n                        }\n                    }\n                ]);\n                return List;\n            }(_container2.default);\n            List.blotName = \"list\";\n            List.scope = _parchment2.default.Scope.BLOCK_BLOT;\n            List.tagName = [\n                \"OL\",\n                \"UL\"\n            ];\n            List.defaultChild = \"list-item\";\n            List.allowedChildren = [\n                ListItem\n            ];\n            exports1.ListItem = ListItem;\n            exports1.default = List;\n        /***/ },\n        /* 68 */ /***/ function(module1, exports1, __nested_webpack_require_583751__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _bold = __nested_webpack_require_583751__(56);\n            var _bold2 = _interopRequireDefault(_bold);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Italic = function(_Bold) {\n                _inherits(Italic, _Bold);\n                function Italic() {\n                    _classCallCheck(this, Italic);\n                    return _possibleConstructorReturn(this, (Italic.__proto__ || Object.getPrototypeOf(Italic)).apply(this, arguments));\n                }\n                return Italic;\n            }(_bold2.default);\n            Italic.blotName = \"italic\";\n            Italic.tagName = [\n                \"EM\",\n                \"I\"\n            ];\n            exports1.default = Italic;\n        /***/ },\n        /* 69 */ /***/ function(module1, exports1, __nested_webpack_require_586126__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _inline = __nested_webpack_require_586126__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Script = function(_Inline) {\n                _inherits(Script, _Inline);\n                function Script() {\n                    _classCallCheck(this, Script);\n                    return _possibleConstructorReturn(this, (Script.__proto__ || Object.getPrototypeOf(Script)).apply(this, arguments));\n                }\n                _createClass(Script, null, [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            if (value === \"super\") {\n                                return document.createElement(\"sup\");\n                            } else if (value === \"sub\") {\n                                return document.createElement(\"sub\");\n                            } else {\n                                return _get(Script.__proto__ || Object.getPrototypeOf(Script), \"create\", this).call(this, value);\n                            }\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            if (domNode.tagName === \"SUB\") return \"sub\";\n                            if (domNode.tagName === \"SUP\") return \"super\";\n                            return undefined;\n                        }\n                    }\n                ]);\n                return Script;\n            }(_inline2.default);\n            Script.blotName = \"script\";\n            Script.tagName = [\n                \"SUB\",\n                \"SUP\"\n            ];\n            exports1.default = Script;\n        /***/ },\n        /* 70 */ /***/ function(module1, exports1, __nested_webpack_require_591290__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _inline = __nested_webpack_require_591290__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Strike = function(_Inline) {\n                _inherits(Strike, _Inline);\n                function Strike() {\n                    _classCallCheck(this, Strike);\n                    return _possibleConstructorReturn(this, (Strike.__proto__ || Object.getPrototypeOf(Strike)).apply(this, arguments));\n                }\n                return Strike;\n            }(_inline2.default);\n            Strike.blotName = \"strike\";\n            Strike.tagName = \"S\";\n            exports1.default = Strike;\n        /***/ },\n        /* 71 */ /***/ function(module1, exports1, __nested_webpack_require_593622__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _inline = __nested_webpack_require_593622__(6);\n            var _inline2 = _interopRequireDefault(_inline);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var Underline = function(_Inline) {\n                _inherits(Underline, _Inline);\n                function Underline() {\n                    _classCallCheck(this, Underline);\n                    return _possibleConstructorReturn(this, (Underline.__proto__ || Object.getPrototypeOf(Underline)).apply(this, arguments));\n                }\n                return Underline;\n            }(_inline2.default);\n            Underline.blotName = \"underline\";\n            Underline.tagName = \"U\";\n            exports1.default = Underline;\n        /***/ },\n        /* 72 */ /***/ function(module1, exports1, __nested_webpack_require_595987__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_595987__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _link = __nested_webpack_require_595987__(27);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ATTRIBUTES = [\n                \"alt\",\n                \"height\",\n                \"width\"\n            ];\n            var Image = function(_Parchment$Embed) {\n                _inherits(Image, _Parchment$Embed);\n                function Image() {\n                    _classCallCheck(this, Image);\n                    return _possibleConstructorReturn(this, (Image.__proto__ || Object.getPrototypeOf(Image)).apply(this, arguments));\n                }\n                _createClass(Image, [\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (ATTRIBUTES.indexOf(name) > -1) {\n                                if (value) {\n                                    this.domNode.setAttribute(name, value);\n                                } else {\n                                    this.domNode.removeAttribute(name);\n                                }\n                            } else {\n                                _get(Image.prototype.__proto__ || Object.getPrototypeOf(Image.prototype), \"format\", this).call(this, name, value);\n                            }\n                        }\n                    }\n                ], [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var node = _get(Image.__proto__ || Object.getPrototypeOf(Image), \"create\", this).call(this, value);\n                            if (typeof value === \"string\") {\n                                node.setAttribute(\"src\", this.sanitize(value));\n                            }\n                            return node;\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            return ATTRIBUTES.reduce(function(formats, attribute) {\n                                if (domNode.hasAttribute(attribute)) {\n                                    formats[attribute] = domNode.getAttribute(attribute);\n                                }\n                                return formats;\n                            }, {});\n                        }\n                    },\n                    {\n                        key: \"match\",\n                        value: function match(url) {\n                            return /\\.(jpe?g|gif|png)$/.test(url) || /^data:image\\/.+;base64/.test(url);\n                        }\n                    },\n                    {\n                        key: \"sanitize\",\n                        value: function sanitize(url) {\n                            return (0, _link.sanitize)(url, [\n                                \"http\",\n                                \"https\",\n                                \"data\"\n                            ]) ? url : \"//:0\";\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(domNode) {\n                            return domNode.getAttribute(\"src\");\n                        }\n                    }\n                ]);\n                return Image;\n            }(_parchment2.default.Embed);\n            Image.blotName = \"image\";\n            Image.tagName = \"IMG\";\n            exports1.default = Image;\n        /***/ },\n        /* 73 */ /***/ function(module1, exports1, __nested_webpack_require_602976__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _block = __nested_webpack_require_602976__(4);\n            var _link = __nested_webpack_require_602976__(27);\n            var _link2 = _interopRequireDefault(_link);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var ATTRIBUTES = [\n                \"height\",\n                \"width\"\n            ];\n            var Video = function(_BlockEmbed) {\n                _inherits(Video, _BlockEmbed);\n                function Video() {\n                    _classCallCheck(this, Video);\n                    return _possibleConstructorReturn(this, (Video.__proto__ || Object.getPrototypeOf(Video)).apply(this, arguments));\n                }\n                _createClass(Video, [\n                    {\n                        key: \"format\",\n                        value: function format(name, value) {\n                            if (ATTRIBUTES.indexOf(name) > -1) {\n                                if (value) {\n                                    this.domNode.setAttribute(name, value);\n                                } else {\n                                    this.domNode.removeAttribute(name);\n                                }\n                            } else {\n                                _get(Video.prototype.__proto__ || Object.getPrototypeOf(Video.prototype), \"format\", this).call(this, name, value);\n                            }\n                        }\n                    }\n                ], [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var node = _get(Video.__proto__ || Object.getPrototypeOf(Video), \"create\", this).call(this, value);\n                            node.setAttribute(\"frameborder\", \"0\");\n                            node.setAttribute(\"allowfullscreen\", true);\n                            node.setAttribute(\"src\", this.sanitize(value));\n                            return node;\n                        }\n                    },\n                    {\n                        key: \"formats\",\n                        value: function formats(domNode) {\n                            return ATTRIBUTES.reduce(function(formats, attribute) {\n                                if (domNode.hasAttribute(attribute)) {\n                                    formats[attribute] = domNode.getAttribute(attribute);\n                                }\n                                return formats;\n                            }, {});\n                        }\n                    },\n                    {\n                        key: \"sanitize\",\n                        value: function sanitize(url) {\n                            return _link2.default.sanitize(url);\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(domNode) {\n                            return domNode.getAttribute(\"src\");\n                        }\n                    }\n                ]);\n                return Video;\n            }(_block.BlockEmbed);\n            Video.blotName = \"video\";\n            Video.className = \"ql-video\";\n            Video.tagName = \"IFRAME\";\n            exports1.default = Video;\n        /***/ },\n        /* 74 */ /***/ function(module1, exports1, __nested_webpack_require_609568__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.FormulaBlot = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _embed = __nested_webpack_require_609568__(35);\n            var _embed2 = _interopRequireDefault(_embed);\n            var _quill = __nested_webpack_require_609568__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _module = __nested_webpack_require_609568__(9);\n            var _module2 = _interopRequireDefault(_module);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var FormulaBlot = function(_Embed) {\n                _inherits(FormulaBlot, _Embed);\n                function FormulaBlot() {\n                    _classCallCheck(this, FormulaBlot);\n                    return _possibleConstructorReturn(this, (FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot)).apply(this, arguments));\n                }\n                _createClass(FormulaBlot, null, [\n                    {\n                        key: \"create\",\n                        value: function create(value) {\n                            var node = _get(FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot), \"create\", this).call(this, value);\n                            if (typeof value === \"string\") {\n                                window.katex.render(value, node, {\n                                    throwOnError: false,\n                                    errorColor: \"#f00\"\n                                });\n                                node.setAttribute(\"data-value\", value);\n                            }\n                            return node;\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(domNode) {\n                            return domNode.getAttribute(\"data-value\");\n                        }\n                    }\n                ]);\n                return FormulaBlot;\n            }(_embed2.default);\n            FormulaBlot.blotName = \"formula\";\n            FormulaBlot.className = \"ql-formula\";\n            FormulaBlot.tagName = \"SPAN\";\n            var Formula = function(_Module) {\n                _inherits(Formula, _Module);\n                _createClass(Formula, null, [\n                    {\n                        key: \"register\",\n                        value: function register() {\n                            _quill2.default.register(FormulaBlot, true);\n                        }\n                    }\n                ]);\n                function Formula() {\n                    _classCallCheck(this, Formula);\n                    var _this2 = _possibleConstructorReturn(this, (Formula.__proto__ || Object.getPrototypeOf(Formula)).call(this));\n                    if (window.katex == null) {\n                        throw new Error(\"Formula module requires KaTeX.\");\n                    }\n                    return _this2;\n                }\n                return Formula;\n            }(_module2.default);\n            exports1.FormulaBlot = FormulaBlot;\n            exports1.default = Formula;\n        /***/ },\n        /* 75 */ /***/ function(module1, exports1, __nested_webpack_require_615968__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.CodeToken = exports1.CodeBlock = undefined;\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _parchment = __nested_webpack_require_615968__(0);\n            var _parchment2 = _interopRequireDefault(_parchment);\n            var _quill = __nested_webpack_require_615968__(5);\n            var _quill2 = _interopRequireDefault(_quill);\n            var _module = __nested_webpack_require_615968__(9);\n            var _module2 = _interopRequireDefault(_module);\n            var _code = __nested_webpack_require_615968__(13);\n            var _code2 = _interopRequireDefault(_code);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var SyntaxCodeBlock = function(_CodeBlock) {\n                _inherits(SyntaxCodeBlock, _CodeBlock);\n                function SyntaxCodeBlock() {\n                    _classCallCheck(this, SyntaxCodeBlock);\n                    return _possibleConstructorReturn(this, (SyntaxCodeBlock.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock)).apply(this, arguments));\n                }\n                _createClass(SyntaxCodeBlock, [\n                    {\n                        key: \"replaceWith\",\n                        value: function replaceWith(block) {\n                            this.domNode.textContent = this.domNode.textContent;\n                            this.attach();\n                            _get(SyntaxCodeBlock.prototype.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock.prototype), \"replaceWith\", this).call(this, block);\n                        }\n                    },\n                    {\n                        key: \"highlight\",\n                        value: function highlight(_highlight) {\n                            var text = this.domNode.textContent;\n                            if (this.cachedText !== text) {\n                                if (text.trim().length > 0 || this.cachedText == null) {\n                                    this.domNode.innerHTML = _highlight(text);\n                                    this.domNode.normalize();\n                                    this.attach();\n                                }\n                                this.cachedText = text;\n                            }\n                        }\n                    }\n                ]);\n                return SyntaxCodeBlock;\n            }(_code2.default);\n            SyntaxCodeBlock.className = \"ql-syntax\";\n            var CodeToken = new _parchment2.default.Attributor.Class(\"token\", \"hljs\", {\n                scope: _parchment2.default.Scope.INLINE\n            });\n            var Syntax = function(_Module) {\n                _inherits(Syntax, _Module);\n                _createClass(Syntax, null, [\n                    {\n                        key: \"register\",\n                        value: function register() {\n                            _quill2.default.register(CodeToken, true);\n                            _quill2.default.register(SyntaxCodeBlock, true);\n                        }\n                    }\n                ]);\n                function Syntax(quill, options) {\n                    _classCallCheck(this, Syntax);\n                    var _this2 = _possibleConstructorReturn(this, (Syntax.__proto__ || Object.getPrototypeOf(Syntax)).call(this, quill, options));\n                    if (typeof _this2.options.highlight !== \"function\") {\n                        throw new Error(\"Syntax module requires highlight.js. Please include the library on the page before Quill.\");\n                    }\n                    var timer = null;\n                    _this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function() {\n                        clearTimeout(timer);\n                        timer = setTimeout(function() {\n                            _this2.highlight();\n                            timer = null;\n                        }, _this2.options.interval);\n                    });\n                    _this2.highlight();\n                    return _this2;\n                }\n                _createClass(Syntax, [\n                    {\n                        key: \"highlight\",\n                        value: function highlight() {\n                            var _this3 = this;\n                            if (this.quill.selection.composing) return;\n                            this.quill.update(_quill2.default.sources.USER);\n                            var range = this.quill.getSelection();\n                            this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function(code) {\n                                code.highlight(_this3.options.highlight);\n                            });\n                            this.quill.update(_quill2.default.sources.SILENT);\n                            if (range != null) {\n                                this.quill.setSelection(range, _quill2.default.sources.SILENT);\n                            }\n                        }\n                    }\n                ]);\n                return Syntax;\n            }(_module2.default);\n            Syntax.DEFAULTS = {\n                highlight: function() {\n                    if (window.hljs == null) return null;\n                    return function(text) {\n                        var result = window.hljs.highlightAuto(text);\n                        return result.value;\n                    };\n                }(),\n                interval: 1000\n            };\n            exports1.CodeBlock = SyntaxCodeBlock;\n            exports1.CodeToken = CodeToken;\n            exports1.default = Syntax;\n        /***/ },\n        /* 76 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>';\n        /***/ },\n        /* 77 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>';\n        /***/ },\n        /* 78 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>';\n        /***/ },\n        /* 79 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>';\n        /***/ },\n        /* 80 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <g class=\"ql-fill ql-color-label\"> <polygon points=\"6 6.868 6 6 5 6 5 7 5.942 7 6 6.868\"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points=\"6.817 5 6 5 6 6 6.38 6 6.817 5\"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points=\"4 11.439 4 11 3 11 3 12 3.755 12 4 11.439\"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points=\"4.63 10 4 10 4 11 4.192 11 4.63 10\"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points=\"13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174\"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points=\"12 6.868 12 6 11.62 6 12 6.868\"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points=\"12.933 9 13 9 13 8 12.495 8 12.933 9\"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points=\"5.5 13 9 5 12.5 13\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>';\n        /***/ },\n        /* 81 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=4 y=5></rect> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=11 y=5></rect> <path class=\"ql-even ql-fill ql-stroke\" d=M7,8c0,4.031-3,5-3,5></path> <path class=\"ql-even ql-fill ql-stroke\" d=M14,8c0,4.031-3,5-3,5></path> </svg>';\n        /***/ },\n        /* 82 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>';\n        /***/ },\n        /* 83 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>';\n        /***/ },\n        /* 84 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=\"ql-color-label ql-stroke ql-transparent\" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points=\"5.5 11 9 3 12.5 11\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>';\n        /***/ },\n        /* 85 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"3 11 5 9 3 7 3 11\"></polygon> <line class=\"ql-stroke ql-fill\" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>';\n        /***/ },\n        /* 86 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"15 12 13 10 15 8 15 12\"></polygon> <line class=\"ql-stroke ql-fill\" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>';\n        /***/ },\n        /* 87 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>';\n        /***/ },\n        /* 88 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>';\n        /***/ },\n        /* 89 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>';\n        /***/ },\n        /* 90 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform=\"translate(24 18) rotate(-180)\"/> </svg>';\n        /***/ },\n        /* 91 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>';\n        /***/ },\n        /* 92 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>';\n        /***/ },\n        /* 93 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>';\n        /***/ },\n        /* 94 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>';\n        /***/ },\n        /* 95 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class=\"ql-even ql-fill\" points=\"5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12\"></polyline> </svg>';\n        /***/ },\n        /* 96 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=\"ql-fill ql-stroke\" points=\"3 7 3 11 5 9 3 7\"></polyline> </svg>';\n        /***/ },\n        /* 97 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"5 7 5 11 3 9 5 7\"></polyline> </svg>';\n        /***/ },\n        /* 98 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class=\"ql-even ql-stroke\" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class=\"ql-even ql-stroke\" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>';\n        /***/ },\n        /* 99 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class=\"ql-stroke ql-thin\" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class=\"ql-stroke ql-thin\" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class=\"ql-stroke ql-thin\" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>';\n        /***/ },\n        /* 100 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>';\n        /***/ },\n        /* 101 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points=\"3 4 4 5 6 3\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points=\"3 14 4 15 6 13\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"3 9 4 10 6 8\"></polyline> </svg>';\n        /***/ },\n        /* 102 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>';\n        /***/ },\n        /* 103 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>';\n        /***/ },\n        /* 104 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <line class=\"ql-stroke ql-thin\" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>';\n        /***/ },\n        /* 105 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>';\n        /***/ },\n        /* 106 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>';\n        /***/ },\n        /* 107 */ /***/ function(module1, exports1) {\n            module1.exports = '<svg viewbox=\"0 0 18 18\"> <polygon class=ql-stroke points=\"7 11 9 13 11 11 7 11\"></polygon> <polygon class=ql-stroke points=\"7 7 9 5 11 7 7 7\"></polygon> </svg>';\n        /***/ },\n        /* 108 */ /***/ function(module1, exports1, __nested_webpack_require_642520__) {\n            \"use strict\";\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            exports1.default = exports1.BubbleTooltip = undefined;\n            var _get = function get(object, property, receiver) {\n                if (object === null) object = Function.prototype;\n                var desc = Object.getOwnPropertyDescriptor(object, property);\n                if (desc === undefined) {\n                    var parent = Object.getPrototypeOf(object);\n                    if (parent === null) {\n                        return undefined;\n                    } else {\n                        return get(parent, property, receiver);\n                    }\n                } else if (\"value\" in desc) {\n                    return desc.value;\n                } else {\n                    var getter = desc.get;\n                    if (getter === undefined) {\n                        return undefined;\n                    }\n                    return getter.call(receiver);\n                }\n            };\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            var _extend = __nested_webpack_require_642520__(3);\n            var _extend2 = _interopRequireDefault(_extend);\n            var _emitter = __nested_webpack_require_642520__(8);\n            var _emitter2 = _interopRequireDefault(_emitter);\n            var _base = __nested_webpack_require_642520__(43);\n            var _base2 = _interopRequireDefault(_base);\n            var _selection = __nested_webpack_require_642520__(15);\n            var _icons = __nested_webpack_require_642520__(41);\n            var _icons2 = _interopRequireDefault(_icons);\n            function _interopRequireDefault(obj) {\n                return obj && obj.__esModule ? obj : {\n                    default: obj\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _possibleConstructorReturn(self1, call) {\n                if (!self1) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self1;\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n            }\n            var TOOLBAR_CONFIG = [\n                [\n                    \"bold\",\n                    \"italic\",\n                    \"link\"\n                ],\n                [\n                    {\n                        header: 1\n                    },\n                    {\n                        header: 2\n                    },\n                    \"blockquote\"\n                ]\n            ];\n            var BubbleTheme = function(_BaseTheme) {\n                _inherits(BubbleTheme, _BaseTheme);\n                function BubbleTheme(quill, options) {\n                    _classCallCheck(this, BubbleTheme);\n                    if (options.modules.toolbar != null && options.modules.toolbar.container == null) {\n                        options.modules.toolbar.container = TOOLBAR_CONFIG;\n                    }\n                    var _this = _possibleConstructorReturn(this, (BubbleTheme.__proto__ || Object.getPrototypeOf(BubbleTheme)).call(this, quill, options));\n                    _this.quill.container.classList.add(\"ql-bubble\");\n                    return _this;\n                }\n                _createClass(BubbleTheme, [\n                    {\n                        key: \"extendToolbar\",\n                        value: function extendToolbar(toolbar) {\n                            this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);\n                            this.tooltip.root.appendChild(toolbar.container);\n                            this.buildButtons([].slice.call(toolbar.container.querySelectorAll(\"button\")), _icons2.default);\n                            this.buildPickers([].slice.call(toolbar.container.querySelectorAll(\"select\")), _icons2.default);\n                        }\n                    }\n                ]);\n                return BubbleTheme;\n            }(_base2.default);\n            BubbleTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {\n                modules: {\n                    toolbar: {\n                        handlers: {\n                            link: function link(value) {\n                                if (!value) {\n                                    this.quill.format(\"link\", false);\n                                } else {\n                                    this.quill.theme.tooltip.edit();\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n            var BubbleTooltip = function(_BaseTooltip) {\n                _inherits(BubbleTooltip, _BaseTooltip);\n                function BubbleTooltip(quill, bounds) {\n                    _classCallCheck(this, BubbleTooltip);\n                    var _this2 = _possibleConstructorReturn(this, (BubbleTooltip.__proto__ || Object.getPrototypeOf(BubbleTooltip)).call(this, quill, bounds));\n                    _this2.quill.on(_emitter2.default.events.EDITOR_CHANGE, function(type, range, oldRange, source) {\n                        if (type !== _emitter2.default.events.SELECTION_CHANGE) return;\n                        if (range != null && range.length > 0 && source === _emitter2.default.sources.USER) {\n                            _this2.show();\n                            // Lock our width so we will expand beyond our offsetParent boundaries\n                            _this2.root.style.left = \"0px\";\n                            _this2.root.style.width = \"\";\n                            _this2.root.style.width = _this2.root.offsetWidth + \"px\";\n                            var lines = _this2.quill.getLines(range.index, range.length);\n                            if (lines.length === 1) {\n                                _this2.position(_this2.quill.getBounds(range));\n                            } else {\n                                var lastLine = lines[lines.length - 1];\n                                var index = _this2.quill.getIndex(lastLine);\n                                var length = Math.min(lastLine.length() - 1, range.index + range.length - index);\n                                var _bounds = _this2.quill.getBounds(new _selection.Range(index, length));\n                                _this2.position(_bounds);\n                            }\n                        } else if (document.activeElement !== _this2.textbox && _this2.quill.hasFocus()) {\n                            _this2.hide();\n                        }\n                    });\n                    return _this2;\n                }\n                _createClass(BubbleTooltip, [\n                    {\n                        key: \"listen\",\n                        value: function listen() {\n                            var _this3 = this;\n                            _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), \"listen\", this).call(this);\n                            this.root.querySelector(\".ql-close\").addEventListener(\"click\", function() {\n                                _this3.root.classList.remove(\"ql-editing\");\n                            });\n                            this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE, function() {\n                                // Let selection be restored by toolbar handlers before repositioning\n                                setTimeout(function() {\n                                    if (_this3.root.classList.contains(\"ql-hidden\")) return;\n                                    var range = _this3.quill.getSelection();\n                                    if (range != null) {\n                                        _this3.position(_this3.quill.getBounds(range));\n                                    }\n                                }, 1);\n                            });\n                        }\n                    },\n                    {\n                        key: \"cancel\",\n                        value: function cancel() {\n                            this.show();\n                        }\n                    },\n                    {\n                        key: \"position\",\n                        value: function position(reference) {\n                            var shift = _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), \"position\", this).call(this, reference);\n                            var arrow = this.root.querySelector(\".ql-tooltip-arrow\");\n                            arrow.style.marginLeft = \"\";\n                            if (shift === 0) return shift;\n                            arrow.style.marginLeft = -1 * shift - arrow.offsetWidth / 2 + \"px\";\n                        }\n                    }\n                ]);\n                return BubbleTooltip;\n            }(_base.BaseTooltip);\n            BubbleTooltip.TEMPLATE = [\n                '<span class=\"ql-tooltip-arrow\"></span>',\n                '<div class=\"ql-tooltip-editor\">',\n                '<input type=\"text\" data-formula=\"e=mc^2\" data-link=\"https://quilljs.com\" data-video=\"Embed URL\">',\n                '<a class=\"ql-close\"></a>',\n                \"</div>\"\n            ].join(\"\");\n            exports1.BubbleTooltip = BubbleTooltip;\n            exports1.default = BubbleTheme;\n        /***/ },\n        /* 109 */ /***/ function(module1, exports1, __nested_webpack_require_653673__) {\n            module1.exports = __nested_webpack_require_653673__(63);\n        /***/ }\n    ])[\"default\"];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcXVpbGwvZGlzdC9xdWlsbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQyxHQUNBLFVBQVNBLGlDQUFpQ0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZELElBQUcsSUFBaUQsRUFDbkRFLE9BQU9ELE9BQU8sR0FBR0Q7U0FDYixFQUtzQkE7QUFDNUIsR0FBRyxPQUFPSyxTQUFTLGNBQWNBLE9BQU8sSUFBSSxFQUFFO0lBQzlDLE9BQWdCLE1BQUgsR0FBSSxTQUFTQyxPQUFPO1FBQ2pDLE1BQU0sR0FBSSxtQkFBbUI7UUFDN0IsTUFBTSxHQUFJLElBQUlDLG1CQUFtQixDQUFDO1FBQ2xDLE1BQU0sR0FDTixNQUFNLEdBQUksdUJBQXVCO1FBQ2pDLE1BQU0sR0FBSSxTQUFTQyw4QkFBbUJBLENBQUNDLFFBQVE7WUFDL0MsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7WUFDekMsTUFBTSxHQUFLLElBQUdGLGdCQUFnQixDQUFDRSxTQUFTLEVBQUU7Z0JBQzFDLE1BQU0sR0FBTSxPQUFPRixnQkFBZ0IsQ0FBQ0UsU0FBUyxDQUFDUixPQUFPO1lBQ3JELE1BQU0sR0FBSztZQUNYLE1BQU0sR0FBSyxrREFBa0Q7WUFDN0QsTUFBTSxHQUFLLElBQUlDLFVBQVNLLGdCQUFnQixDQUFDRSxTQUFTLEdBQUc7Z0JBQ3JELE1BQU0sR0FBTUMsR0FBR0Q7Z0JBQ2YsTUFBTSxHQUFNRSxHQUFHO2dCQUNmLE1BQU0sR0FBTVYsU0FBUyxDQUFDO1lBQ1g7WUFDWCxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUtLLE9BQU8sQ0FBQ0csU0FBUyxDQUFDRyxJQUFJLENBQUNWLFFBQU9ELE9BQU8sRUFBRUMsU0FBUUEsUUFBT0QsT0FBTyxFQUFFTyw4QkFBbUJBO1lBQzdGLE1BQU0sR0FDTixNQUFNLEdBQUssNEJBQTRCO1lBQ3ZDLE1BQU0sR0FBS04sUUFBT1MsQ0FBQyxHQUFHO1lBQ3RCLE1BQU0sR0FDTixNQUFNLEdB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QUFDLElBQUl2bEMsUUFBUXNsQyxNQUFNekYsV0FBVyxHQUFHLElBQUk7d0JBQ2hFO29CQUNGO2lCQUFFO2dCQUVGLE9BQU9xRjtZQUNULEVBQUVqRixNQUFNM1QsV0FBVztZQUVuQjRZLGNBQWN2RixRQUFRLEdBQUc7Z0JBQUM7Z0JBQTBDO2dCQUFtQztnQkFBb0c7Z0JBQTRCO2FBQVMsQ0FBQzdsQyxJQUFJLENBQUM7WUFFdFBuTCxTQUFRdTJDLGFBQWEsR0FBR0E7WUFDeEJ2MkMsU0FBUXNELE9BQU8sR0FBR2t6QztRQUVsQixHQUFHLEdBQUc7UUFDTixPQUFPLEdBQ1AsR0FBRyxHQUFJLFNBQVN2MkMsT0FBTSxFQUFFRCxRQUFPLEVBQUVPLGlDQUFtQjtZQUVwRE4sUUFBT0QsT0FBTyxHQUFHTyxpQ0FBbUJBLENBQUM7UUFHckMsR0FBRyxHQUFHO0tBQ0ksQ0FBQyxDQUFDLFVBQVU7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWFybmVhenktZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcXVpbGwvZGlzdC9xdWlsbC5qcz85OWY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogUXVpbGwgRWRpdG9yIHYxLjMuN1xuICogaHR0cHM6Ly9xdWlsbGpzLmNvbS9cbiAqIENvcHlyaWdodCAoYykgMjAxNCwgSmFzb24gQ2hlblxuICogQ29weXJpZ2h0IChjKSAyMDEzLCBzYWxlc2ZvcmNlLmNvbVxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJRdWlsbFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJRdWlsbFwiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTA5KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250YWluZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIGZvcm1hdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG52YXIgbGVhZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG52YXIgc2Nyb2xsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcbnZhciBpbmxpbmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xudmFyIGJsb2NrXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcbnZhciBlbWJlZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG52YXIgdGV4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG52YXIgYXR0cmlidXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG52YXIgY2xhc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIHN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbnZhciBzdG9yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG52YXIgUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIFBhcmNobWVudCA9IHtcbiAgICBTY29wZTogUmVnaXN0cnkuU2NvcGUsXG4gICAgY3JlYXRlOiBSZWdpc3RyeS5jcmVhdGUsXG4gICAgZmluZDogUmVnaXN0cnkuZmluZCxcbiAgICBxdWVyeTogUmVnaXN0cnkucXVlcnksXG4gICAgcmVnaXN0ZXI6IFJlZ2lzdHJ5LnJlZ2lzdGVyLFxuICAgIENvbnRhaW5lcjogY29udGFpbmVyXzEuZGVmYXVsdCxcbiAgICBGb3JtYXQ6IGZvcm1hdF8xLmRlZmF1bHQsXG4gICAgTGVhZjogbGVhZl8xLmRlZmF1bHQsXG4gICAgRW1iZWQ6IGVtYmVkXzEuZGVmYXVsdCxcbiAgICBTY3JvbGw6IHNjcm9sbF8xLmRlZmF1bHQsXG4gICAgQmxvY2s6IGJsb2NrXzEuZGVmYXVsdCxcbiAgICBJbmxpbmU6IGlubGluZV8xLmRlZmF1bHQsXG4gICAgVGV4dDogdGV4dF8xLmRlZmF1bHQsXG4gICAgQXR0cmlidXRvcjoge1xuICAgICAgICBBdHRyaWJ1dGU6IGF0dHJpYnV0b3JfMS5kZWZhdWx0LFxuICAgICAgICBDbGFzczogY2xhc3NfMS5kZWZhdWx0LFxuICAgICAgICBTdHlsZTogc3R5bGVfMS5kZWZhdWx0LFxuICAgICAgICBTdG9yZTogc3RvcmVfMS5kZWZhdWx0LFxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gUGFyY2htZW50O1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUGFyY2htZW50RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhcmNobWVudEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhcmNobWVudEVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbWVzc2FnZSA9ICdbUGFyY2htZW50XSAnICsgbWVzc2FnZTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgX3RoaXMubmFtZSA9IF90aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBhcmNobWVudEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5QYXJjaG1lbnRFcnJvciA9IFBhcmNobWVudEVycm9yO1xudmFyIGF0dHJpYnV0ZXMgPSB7fTtcbnZhciBjbGFzc2VzID0ge307XG52YXIgdGFncyA9IHt9O1xudmFyIHR5cGVzID0ge307XG5leHBvcnRzLkRBVEFfS0VZID0gJ19fYmxvdCc7XG52YXIgU2NvcGU7XG4oZnVuY3Rpb24gKFNjb3BlKSB7XG4gICAgU2NvcGVbU2NvcGVbXCJUWVBFXCJdID0gM10gPSBcIlRZUEVcIjtcbiAgICBTY29wZVtTY29wZVtcIkxFVkVMXCJdID0gMTJdID0gXCJMRVZFTFwiO1xuICAgIFNjb3BlW1Njb3BlW1wiQVRUUklCVVRFXCJdID0gMTNdID0gXCJBVFRSSUJVVEVcIjtcbiAgICBTY29wZVtTY29wZVtcIkJMT1RcIl0gPSAxNF0gPSBcIkJMT1RcIjtcbiAgICBTY29wZVtTY29wZVtcIklOTElORVwiXSA9IDddID0gXCJJTkxJTkVcIjtcbiAgICBTY29wZVtTY29wZVtcIkJMT0NLXCJdID0gMTFdID0gXCJCTE9DS1wiO1xuICAgIFNjb3BlW1Njb3BlW1wiQkxPQ0tfQkxPVFwiXSA9IDEwXSA9IFwiQkxPQ0tfQkxPVFwiO1xuICAgIFNjb3BlW1Njb3BlW1wiSU5MSU5FX0JMT1RcIl0gPSA2XSA9IFwiSU5MSU5FX0JMT1RcIjtcbiAgICBTY29wZVtTY29wZVtcIkJMT0NLX0FUVFJJQlVURVwiXSA9IDldID0gXCJCTE9DS19BVFRSSUJVVEVcIjtcbiAgICBTY29wZVtTY29wZVtcIklOTElORV9BVFRSSUJVVEVcIl0gPSA1XSA9IFwiSU5MSU5FX0FUVFJJQlVURVwiO1xuICAgIFNjb3BlW1Njb3BlW1wiQU5ZXCJdID0gMTVdID0gXCJBTllcIjtcbn0pKFNjb3BlID0gZXhwb3J0cy5TY29wZSB8fCAoZXhwb3J0cy5TY29wZSA9IHt9KSk7XG5mdW5jdGlvbiBjcmVhdGUoaW5wdXQsIHZhbHVlKSB7XG4gICAgdmFyIG1hdGNoID0gcXVlcnkoaW5wdXQpO1xuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJjaG1lbnRFcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgXCIgKyBpbnB1dCArIFwiIGJsb3RcIik7XG4gICAgfVxuICAgIHZhciBCbG90Q2xhc3MgPSBtYXRjaDtcbiAgICB2YXIgbm9kZSA9IFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpbnB1dCBpbnN0YW5jZW9mIE5vZGUgfHwgaW5wdXRbJ25vZGVUeXBlJ10gPT09IE5vZGUuVEVYVF9OT0RFID8gaW5wdXQgOiBCbG90Q2xhc3MuY3JlYXRlKHZhbHVlKTtcbiAgICByZXR1cm4gbmV3IEJsb3RDbGFzcyhub2RlLCB2YWx1ZSk7XG59XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmZ1bmN0aW9uIGZpbmQobm9kZSwgYnViYmxlKSB7XG4gICAgaWYgKGJ1YmJsZSA9PT0gdm9pZCAwKSB7IGJ1YmJsZSA9IGZhbHNlOyB9XG4gICAgaWYgKG5vZGUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChub2RlW2V4cG9ydHMuREFUQV9LRVldICE9IG51bGwpXG4gICAgICAgIHJldHVybiBub2RlW2V4cG9ydHMuREFUQV9LRVldLmJsb3Q7XG4gICAgaWYgKGJ1YmJsZSlcbiAgICAgICAgcmV0dXJuIGZpbmQobm9kZS5wYXJlbnROb2RlLCBidWJibGUpO1xuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5maW5kID0gZmluZDtcbmZ1bmN0aW9uIHF1ZXJ5KHF1ZXJ5LCBzY29wZSkge1xuICAgIGlmIChzY29wZSA9PT0gdm9pZCAwKSB7IHNjb3BlID0gU2NvcGUuQU5ZOyB9XG4gICAgdmFyIG1hdGNoO1xuICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hdGNoID0gdHlwZXNbcXVlcnldIHx8IGF0dHJpYnV0ZXNbcXVlcnldO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgfVxuICAgIGVsc2UgaWYgKHF1ZXJ5IGluc3RhbmNlb2YgVGV4dCB8fCBxdWVyeVsnbm9kZVR5cGUnXSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgbWF0Y2ggPSB0eXBlc1sndGV4dCddO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcXVlcnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChxdWVyeSAmIFNjb3BlLkxFVkVMICYgU2NvcGUuQkxPQ0spIHtcbiAgICAgICAgICAgIG1hdGNoID0gdHlwZXNbJ2Jsb2NrJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocXVlcnkgJiBTY29wZS5MRVZFTCAmIFNjb3BlLklOTElORSkge1xuICAgICAgICAgICAgbWF0Y2ggPSB0eXBlc1snaW5saW5lJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocXVlcnkgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICB2YXIgbmFtZXMgPSAocXVlcnkuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICBmb3IgKHZhciBpIGluIG5hbWVzKSB7XG4gICAgICAgICAgICBtYXRjaCA9IGNsYXNzZXNbbmFtZXNbaV1dO1xuICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gbWF0Y2ggfHwgdGFnc1txdWVyeS50YWdOYW1lXTtcbiAgICB9XG4gICAgaWYgKG1hdGNoID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoc2NvcGUgJiBTY29wZS5MRVZFTCAmIG1hdGNoLnNjb3BlICYmIHNjb3BlICYgU2NvcGUuVFlQRSAmIG1hdGNoLnNjb3BlKVxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLnF1ZXJ5ID0gcXVlcnk7XG5mdW5jdGlvbiByZWdpc3RlcigpIHtcbiAgICB2YXIgRGVmaW5pdGlvbnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBEZWZpbml0aW9uc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAoRGVmaW5pdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gRGVmaW5pdGlvbnMubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXIoZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgRGVmaW5pdGlvbiA9IERlZmluaXRpb25zWzBdO1xuICAgIGlmICh0eXBlb2YgRGVmaW5pdGlvbi5ibG90TmFtZSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIERlZmluaXRpb24uYXR0ck5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJjaG1lbnRFcnJvcignSW52YWxpZCBkZWZpbml0aW9uJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKERlZmluaXRpb24uYmxvdE5hbWUgPT09ICdhYnN0cmFjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcmNobWVudEVycm9yKCdDYW5ub3QgcmVnaXN0ZXIgYWJzdHJhY3QgY2xhc3MnKTtcbiAgICB9XG4gICAgdHlwZXNbRGVmaW5pdGlvbi5ibG90TmFtZSB8fCBEZWZpbml0aW9uLmF0dHJOYW1lXSA9IERlZmluaXRpb247XG4gICAgaWYgKHR5cGVvZiBEZWZpbml0aW9uLmtleU5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbRGVmaW5pdGlvbi5rZXlOYW1lXSA9IERlZmluaXRpb247XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoRGVmaW5pdGlvbi5jbGFzc05hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2xhc3Nlc1tEZWZpbml0aW9uLmNsYXNzTmFtZV0gPSBEZWZpbml0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChEZWZpbml0aW9uLnRhZ05hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoRGVmaW5pdGlvbi50YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIERlZmluaXRpb24udGFnTmFtZSA9IERlZmluaXRpb24udGFnTmFtZS5tYXAoZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhZ05hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIERlZmluaXRpb24udGFnTmFtZSA9IERlZmluaXRpb24udGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRhZ05hbWVzID0gQXJyYXkuaXNBcnJheShEZWZpbml0aW9uLnRhZ05hbWUpID8gRGVmaW5pdGlvbi50YWdOYW1lIDogW0RlZmluaXRpb24udGFnTmFtZV07XG4gICAgICAgICAgICB0YWdOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnc1t0YWddID09IG51bGwgfHwgRGVmaW5pdGlvbi5jbGFzc05hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0YWdzW3RhZ10gPSBEZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBEZWZpbml0aW9uO1xufVxuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZGlmZiA9IF9fd2VicGFja19yZXF1aXJlX18oNTEpO1xudmFyIGVxdWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG52YXIgZXh0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBvcCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG5cbnZhciBOVUxMX0NIQVJBQ1RFUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMCk7ICAvLyBQbGFjZWhvbGRlciBjaGFyIGZvciBlbWJlZCBpbiBkaWZmKClcblxuXG52YXIgRGVsdGEgPSBmdW5jdGlvbiAob3BzKSB7XG4gIC8vIEFzc3VtZSB3ZSBhcmUgZ2l2ZW4gYSB3ZWxsIGZvcm1lZCBvcHNcbiAgaWYgKEFycmF5LmlzQXJyYXkob3BzKSkge1xuICAgIHRoaXMub3BzID0gb3BzO1xuICB9IGVsc2UgaWYgKG9wcyAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkob3BzLm9wcykpIHtcbiAgICB0aGlzLm9wcyA9IG9wcy5vcHM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHMgPSBbXTtcbiAgfVxufTtcblxuXG5EZWx0YS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHRleHQsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIG5ld09wID0ge307XG4gIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gIG5ld09wLmluc2VydCA9IHRleHQ7XG4gIGlmIChhdHRyaWJ1dGVzICE9IG51bGwgJiYgdHlwZW9mIGF0dHJpYnV0ZXMgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICBuZXdPcC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgfVxuICByZXR1cm4gdGhpcy5wdXNoKG5ld09wKTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPD0gMCkgcmV0dXJuIHRoaXM7XG4gIHJldHVybiB0aGlzLnB1c2goeyAnZGVsZXRlJzogbGVuZ3RoIH0pO1xufTtcblxuRGVsdGEucHJvdG90eXBlLnJldGFpbiA9IGZ1bmN0aW9uIChsZW5ndGgsIGF0dHJpYnV0ZXMpIHtcbiAgaWYgKGxlbmd0aCA8PSAwKSByZXR1cm4gdGhpcztcbiAgdmFyIG5ld09wID0geyByZXRhaW46IGxlbmd0aCB9O1xuICBpZiAoYXR0cmlidXRlcyAhPSBudWxsICYmIHR5cGVvZiBhdHRyaWJ1dGVzID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgbmV3T3AuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMucHVzaChuZXdPcCk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChuZXdPcCkge1xuICB2YXIgaW5kZXggPSB0aGlzLm9wcy5sZW5ndGg7XG4gIHZhciBsYXN0T3AgPSB0aGlzLm9wc1tpbmRleCAtIDFdO1xuICBuZXdPcCA9IGV4dGVuZCh0cnVlLCB7fSwgbmV3T3ApO1xuICBpZiAodHlwZW9mIGxhc3RPcCA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAodHlwZW9mIG5ld09wWydkZWxldGUnXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGxhc3RPcFsnZGVsZXRlJ10gPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLm9wc1tpbmRleCAtIDFdID0geyAnZGVsZXRlJzogbGFzdE9wWydkZWxldGUnXSArIG5ld09wWydkZWxldGUnXSB9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIFNpbmNlIGl0IGRvZXMgbm90IG1hdHRlciBpZiB3ZSBpbnNlcnQgYmVmb3JlIG9yIGFmdGVyIGRlbGV0aW5nIGF0IHRoZSBzYW1lIGluZGV4LFxuICAgIC8vIGFsd2F5cyBwcmVmZXIgdG8gaW5zZXJ0IGZpcnN0XG4gICAgaWYgKHR5cGVvZiBsYXN0T3BbJ2RlbGV0ZSddID09PSAnbnVtYmVyJyAmJiBuZXdPcC5pbnNlcnQgIT0gbnVsbCkge1xuICAgICAgaW5kZXggLT0gMTtcbiAgICAgIGxhc3RPcCA9IHRoaXMub3BzW2luZGV4IC0gMV07XG4gICAgICBpZiAodHlwZW9mIGxhc3RPcCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5vcHMudW5zaGlmdChuZXdPcCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXF1YWwobmV3T3AuYXR0cmlidXRlcywgbGFzdE9wLmF0dHJpYnV0ZXMpKSB7XG4gICAgICBpZiAodHlwZW9mIG5ld09wLmluc2VydCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGxhc3RPcC5pbnNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub3BzW2luZGV4IC0gMV0gPSB7IGluc2VydDogbGFzdE9wLmluc2VydCArIG5ld09wLmluc2VydCB9O1xuICAgICAgICBpZiAodHlwZW9mIG5ld09wLmF0dHJpYnV0ZXMgPT09ICdvYmplY3QnKSB0aGlzLm9wc1tpbmRleCAtIDFdLmF0dHJpYnV0ZXMgPSBuZXdPcC5hdHRyaWJ1dGVzXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV3T3AucmV0YWluID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgbGFzdE9wLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5vcHNbaW5kZXggLSAxXSA9IHsgcmV0YWluOiBsYXN0T3AucmV0YWluICsgbmV3T3AucmV0YWluIH07XG4gICAgICAgIGlmICh0eXBlb2YgbmV3T3AuYXR0cmlidXRlcyA9PT0gJ29iamVjdCcpIHRoaXMub3BzW2luZGV4IC0gMV0uYXR0cmlidXRlcyA9IG5ld09wLmF0dHJpYnV0ZXNcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpbmRleCA9PT0gdGhpcy5vcHMubGVuZ3RoKSB7XG4gICAgdGhpcy5vcHMucHVzaChuZXdPcCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHMuc3BsaWNlKGluZGV4LCAwLCBuZXdPcCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUuY2hvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxhc3RPcCA9IHRoaXMub3BzW3RoaXMub3BzLmxlbmd0aCAtIDFdO1xuICBpZiAobGFzdE9wICYmIGxhc3RPcC5yZXRhaW4gJiYgIWxhc3RPcC5hdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5vcHMucG9wKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICByZXR1cm4gdGhpcy5vcHMuZmlsdGVyKHByZWRpY2F0ZSk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgdGhpcy5vcHMuZm9yRWFjaChwcmVkaWNhdGUpO1xufTtcblxuRGVsdGEucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIHRoaXMub3BzLm1hcChwcmVkaWNhdGUpO1xufTtcblxuRGVsdGEucHJvdG90eXBlLnBhcnRpdGlvbiA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgdmFyIHBhc3NlZCA9IFtdLCBmYWlsZWQgPSBbXTtcbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKG9wKSB7XG4gICAgdmFyIHRhcmdldCA9IHByZWRpY2F0ZShvcCkgPyBwYXNzZWQgOiBmYWlsZWQ7XG4gICAgdGFyZ2V0LnB1c2gob3ApO1xuICB9KTtcbiAgcmV0dXJuIFtwYXNzZWQsIGZhaWxlZF07XG59O1xuXG5EZWx0YS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgaW5pdGlhbCkge1xuICByZXR1cm4gdGhpcy5vcHMucmVkdWNlKHByZWRpY2F0ZSwgaW5pdGlhbCk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUuY2hhbmdlTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWR1Y2UoZnVuY3Rpb24gKGxlbmd0aCwgZWxlbSkge1xuICAgIGlmIChlbGVtLmluc2VydCkge1xuICAgICAgcmV0dXJuIGxlbmd0aCArIG9wLmxlbmd0aChlbGVtKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uZGVsZXRlKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoIC0gZWxlbS5kZWxldGU7XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGg7XG4gIH0sIDApO1xufTtcblxuRGVsdGEucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVkdWNlKGZ1bmN0aW9uIChsZW5ndGgsIGVsZW0pIHtcbiAgICByZXR1cm4gbGVuZ3RoICsgb3AubGVuZ3RoKGVsZW0pO1xuICB9LCAwKTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInKSBlbmQgPSBJbmZpbml0eTtcbiAgdmFyIG9wcyA9IFtdO1xuICB2YXIgaXRlciA9IG9wLml0ZXJhdG9yKHRoaXMub3BzKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgd2hpbGUgKGluZGV4IDwgZW5kICYmIGl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgdmFyIG5leHRPcDtcbiAgICBpZiAoaW5kZXggPCBzdGFydCkge1xuICAgICAgbmV4dE9wID0gaXRlci5uZXh0KHN0YXJ0IC0gaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0T3AgPSBpdGVyLm5leHQoZW5kIC0gaW5kZXgpO1xuICAgICAgb3BzLnB1c2gobmV4dE9wKTtcbiAgICB9XG4gICAgaW5kZXggKz0gb3AubGVuZ3RoKG5leHRPcCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBEZWx0YShvcHMpO1xufTtcblxuXG5EZWx0YS5wcm90b3R5cGUuY29tcG9zZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICB2YXIgdGhpc0l0ZXIgPSBvcC5pdGVyYXRvcih0aGlzLm9wcyk7XG4gIHZhciBvdGhlckl0ZXIgPSBvcC5pdGVyYXRvcihvdGhlci5vcHMpO1xuICB2YXIgb3BzID0gW107XG4gIHZhciBmaXJzdE90aGVyID0gb3RoZXJJdGVyLnBlZWsoKTtcbiAgaWYgKGZpcnN0T3RoZXIgIT0gbnVsbCAmJiB0eXBlb2YgZmlyc3RPdGhlci5yZXRhaW4gPT09ICdudW1iZXInICYmIGZpcnN0T3RoZXIuYXR0cmlidXRlcyA9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0TGVmdCA9IGZpcnN0T3RoZXIucmV0YWluO1xuICAgIHdoaWxlICh0aGlzSXRlci5wZWVrVHlwZSgpID09PSAnaW5zZXJ0JyAmJiB0aGlzSXRlci5wZWVrTGVuZ3RoKCkgPD0gZmlyc3RMZWZ0KSB7XG4gICAgICBmaXJzdExlZnQgLT0gdGhpc0l0ZXIucGVla0xlbmd0aCgpO1xuICAgICAgb3BzLnB1c2godGhpc0l0ZXIubmV4dCgpKTtcbiAgICB9XG4gICAgaWYgKGZpcnN0T3RoZXIucmV0YWluIC0gZmlyc3RMZWZ0ID4gMCkge1xuICAgICAgb3RoZXJJdGVyLm5leHQoZmlyc3RPdGhlci5yZXRhaW4gLSBmaXJzdExlZnQpO1xuICAgIH1cbiAgfVxuICB2YXIgZGVsdGEgPSBuZXcgRGVsdGEob3BzKTtcbiAgd2hpbGUgKHRoaXNJdGVyLmhhc05leHQoKSB8fCBvdGhlckl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgaWYgKG90aGVySXRlci5wZWVrVHlwZSgpID09PSAnaW5zZXJ0Jykge1xuICAgICAgZGVsdGEucHVzaChvdGhlckl0ZXIubmV4dCgpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXNJdGVyLnBlZWtUeXBlKCkgPT09ICdkZWxldGUnKSB7XG4gICAgICBkZWx0YS5wdXNoKHRoaXNJdGVyLm5leHQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbih0aGlzSXRlci5wZWVrTGVuZ3RoKCksIG90aGVySXRlci5wZWVrTGVuZ3RoKCkpO1xuICAgICAgdmFyIHRoaXNPcCA9IHRoaXNJdGVyLm5leHQobGVuZ3RoKTtcbiAgICAgIHZhciBvdGhlck9wID0gb3RoZXJJdGVyLm5leHQobGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2Ygb3RoZXJPcC5yZXRhaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBuZXdPcCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRoaXNPcC5yZXRhaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgbmV3T3AucmV0YWluID0gbGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld09wLmluc2VydCA9IHRoaXNPcC5pbnNlcnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlc2VydmUgbnVsbCB3aGVuIGNvbXBvc2luZyB3aXRoIGEgcmV0YWluLCBvdGhlcndpc2UgcmVtb3ZlIGl0IGZvciBpbnNlcnRzXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gb3AuYXR0cmlidXRlcy5jb21wb3NlKHRoaXNPcC5hdHRyaWJ1dGVzLCBvdGhlck9wLmF0dHJpYnV0ZXMsIHR5cGVvZiB0aGlzT3AucmV0YWluID09PSAnbnVtYmVyJyk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzKSBuZXdPcC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgZGVsdGEucHVzaChuZXdPcCk7XG5cbiAgICAgICAgLy8gT3B0aW1pemF0aW9uIGlmIHJlc3Qgb2Ygb3RoZXIgaXMganVzdCByZXRhaW5cbiAgICAgICAgaWYgKCFvdGhlckl0ZXIuaGFzTmV4dCgpICYmIGVxdWFsKGRlbHRhLm9wc1tkZWx0YS5vcHMubGVuZ3RoIC0gMV0sIG5ld09wKSkge1xuICAgICAgICAgIHZhciByZXN0ID0gbmV3IERlbHRhKHRoaXNJdGVyLnJlc3QoKSk7XG4gICAgICAgICAgcmV0dXJuIGRlbHRhLmNvbmNhdChyZXN0KS5jaG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgLy8gT3RoZXIgb3Agc2hvdWxkIGJlIGRlbGV0ZSwgd2UgY291bGQgYmUgYW4gaW5zZXJ0IG9yIHJldGFpblxuICAgICAgLy8gSW5zZXJ0ICsgZGVsZXRlIGNhbmNlbHMgb3V0XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvdGhlck9wWydkZWxldGUnXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHRoaXNPcC5yZXRhaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGRlbHRhLnB1c2gob3RoZXJPcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWx0YS5jaG9wKCk7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHZhciBkZWx0YSA9IG5ldyBEZWx0YSh0aGlzLm9wcy5zbGljZSgpKTtcbiAgaWYgKG90aGVyLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgZGVsdGEucHVzaChvdGhlci5vcHNbMF0pO1xuICAgIGRlbHRhLm9wcyA9IGRlbHRhLm9wcy5jb25jYXQob3RoZXIub3BzLnNsaWNlKDEpKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59O1xuXG5EZWx0YS5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChvdGhlciwgaW5kZXgpIHtcbiAgaWYgKHRoaXMub3BzID09PSBvdGhlci5vcHMpIHtcbiAgICByZXR1cm4gbmV3IERlbHRhKCk7XG4gIH1cbiAgdmFyIHN0cmluZ3MgPSBbdGhpcywgb3RoZXJdLm1hcChmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICByZXR1cm4gZGVsdGEubWFwKGZ1bmN0aW9uIChvcCkge1xuICAgICAgaWYgKG9wLmluc2VydCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb3AuaW5zZXJ0ID09PSAnc3RyaW5nJyA/IG9wLmluc2VydCA6IE5VTExfQ0hBUkFDVEVSO1xuICAgICAgfVxuICAgICAgdmFyIHByZXAgPSAoZGVsdGEgPT09IG90aGVyKSA/ICdvbicgOiAnd2l0aCc7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZmYoKSBjYWxsZWQgJyArIHByZXAgKyAnIG5vbi1kb2N1bWVudCcpO1xuICAgIH0pLmpvaW4oJycpO1xuICB9KTtcbiAgdmFyIGRlbHRhID0gbmV3IERlbHRhKCk7XG4gIHZhciBkaWZmUmVzdWx0ID0gZGlmZihzdHJpbmdzWzBdLCBzdHJpbmdzWzFdLCBpbmRleCk7XG4gIHZhciB0aGlzSXRlciA9IG9wLml0ZXJhdG9yKHRoaXMub3BzKTtcbiAgdmFyIG90aGVySXRlciA9IG9wLml0ZXJhdG9yKG90aGVyLm9wcyk7XG4gIGRpZmZSZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgdmFyIGxlbmd0aCA9IGNvbXBvbmVudFsxXS5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBvcExlbmd0aCA9IDA7XG4gICAgICBzd2l0Y2ggKGNvbXBvbmVudFswXSkge1xuICAgICAgICBjYXNlIGRpZmYuSU5TRVJUOlxuICAgICAgICAgIG9wTGVuZ3RoID0gTWF0aC5taW4ob3RoZXJJdGVyLnBlZWtMZW5ndGgoKSwgbGVuZ3RoKTtcbiAgICAgICAgICBkZWx0YS5wdXNoKG90aGVySXRlci5uZXh0KG9wTGVuZ3RoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZGlmZi5ERUxFVEU6XG4gICAgICAgICAgb3BMZW5ndGggPSBNYXRoLm1pbihsZW5ndGgsIHRoaXNJdGVyLnBlZWtMZW5ndGgoKSk7XG4gICAgICAgICAgdGhpc0l0ZXIubmV4dChvcExlbmd0aCk7XG4gICAgICAgICAgZGVsdGFbJ2RlbGV0ZSddKG9wTGVuZ3RoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBkaWZmLkVRVUFMOlxuICAgICAgICAgIG9wTGVuZ3RoID0gTWF0aC5taW4odGhpc0l0ZXIucGVla0xlbmd0aCgpLCBvdGhlckl0ZXIucGVla0xlbmd0aCgpLCBsZW5ndGgpO1xuICAgICAgICAgIHZhciB0aGlzT3AgPSB0aGlzSXRlci5uZXh0KG9wTGVuZ3RoKTtcbiAgICAgICAgICB2YXIgb3RoZXJPcCA9IG90aGVySXRlci5uZXh0KG9wTGVuZ3RoKTtcbiAgICAgICAgICBpZiAoZXF1YWwodGhpc09wLmluc2VydCwgb3RoZXJPcC5pbnNlcnQpKSB7XG4gICAgICAgICAgICBkZWx0YS5yZXRhaW4ob3BMZW5ndGgsIG9wLmF0dHJpYnV0ZXMuZGlmZih0aGlzT3AuYXR0cmlidXRlcywgb3RoZXJPcC5hdHRyaWJ1dGVzKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhLnB1c2gob3RoZXJPcClbJ2RlbGV0ZSddKG9wTGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsZW5ndGggLT0gb3BMZW5ndGg7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRlbHRhLmNob3AoKTtcbn07XG5cbkRlbHRhLnByb3RvdHlwZS5lYWNoTGluZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIG5ld2xpbmUpIHtcbiAgbmV3bGluZSA9IG5ld2xpbmUgfHwgJ1xcbic7XG4gIHZhciBpdGVyID0gb3AuaXRlcmF0b3IodGhpcy5vcHMpO1xuICB2YXIgbGluZSA9IG5ldyBEZWx0YSgpO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpdGVyLmhhc05leHQoKSkge1xuICAgIGlmIChpdGVyLnBlZWtUeXBlKCkgIT09ICdpbnNlcnQnKSByZXR1cm47XG4gICAgdmFyIHRoaXNPcCA9IGl0ZXIucGVlaygpO1xuICAgIHZhciBzdGFydCA9IG9wLmxlbmd0aCh0aGlzT3ApIC0gaXRlci5wZWVrTGVuZ3RoKCk7XG4gICAgdmFyIGluZGV4ID0gdHlwZW9mIHRoaXNPcC5pbnNlcnQgPT09ICdzdHJpbmcnID9cbiAgICAgIHRoaXNPcC5pbnNlcnQuaW5kZXhPZihuZXdsaW5lLCBzdGFydCkgLSBzdGFydCA6IC0xO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGxpbmUucHVzaChpdGVyLm5leHQoKSk7XG4gICAgfSBlbHNlIGlmIChpbmRleCA+IDApIHtcbiAgICAgIGxpbmUucHVzaChpdGVyLm5leHQoaW5kZXgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZWRpY2F0ZShsaW5lLCBpdGVyLm5leHQoMSkuYXR0cmlidXRlcyB8fCB7fSwgaSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGkgKz0gMTtcbiAgICAgIGxpbmUgPSBuZXcgRGVsdGEoKTtcbiAgICB9XG4gIH1cbiAgaWYgKGxpbmUubGVuZ3RoKCkgPiAwKSB7XG4gICAgcHJlZGljYXRlKGxpbmUsIHt9LCBpKTtcbiAgfVxufTtcblxuRGVsdGEucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChvdGhlciwgcHJpb3JpdHkpIHtcbiAgcHJpb3JpdHkgPSAhIXByaW9yaXR5O1xuICBpZiAodHlwZW9mIG90aGVyID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVBvc2l0aW9uKG90aGVyLCBwcmlvcml0eSk7XG4gIH1cbiAgdmFyIHRoaXNJdGVyID0gb3AuaXRlcmF0b3IodGhpcy5vcHMpO1xuICB2YXIgb3RoZXJJdGVyID0gb3AuaXRlcmF0b3Iob3RoZXIub3BzKTtcbiAgdmFyIGRlbHRhID0gbmV3IERlbHRhKCk7XG4gIHdoaWxlICh0aGlzSXRlci5oYXNOZXh0KCkgfHwgb3RoZXJJdGVyLmhhc05leHQoKSkge1xuICAgIGlmICh0aGlzSXRlci5wZWVrVHlwZSgpID09PSAnaW5zZXJ0JyAmJiAocHJpb3JpdHkgfHwgb3RoZXJJdGVyLnBlZWtUeXBlKCkgIT09ICdpbnNlcnQnKSkge1xuICAgICAgZGVsdGEucmV0YWluKG9wLmxlbmd0aCh0aGlzSXRlci5uZXh0KCkpKTtcbiAgICB9IGVsc2UgaWYgKG90aGVySXRlci5wZWVrVHlwZSgpID09PSAnaW5zZXJ0Jykge1xuICAgICAgZGVsdGEucHVzaChvdGhlckl0ZXIubmV4dCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHRoaXNJdGVyLnBlZWtMZW5ndGgoKSwgb3RoZXJJdGVyLnBlZWtMZW5ndGgoKSk7XG4gICAgICB2YXIgdGhpc09wID0gdGhpc0l0ZXIubmV4dChsZW5ndGgpO1xuICAgICAgdmFyIG90aGVyT3AgPSBvdGhlckl0ZXIubmV4dChsZW5ndGgpO1xuICAgICAgaWYgKHRoaXNPcFsnZGVsZXRlJ10pIHtcbiAgICAgICAgLy8gT3VyIGRlbGV0ZSBlaXRoZXIgbWFrZXMgdGhlaXIgZGVsZXRlIHJlZHVuZGFudCBvciByZW1vdmVzIHRoZWlyIHJldGFpblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAob3RoZXJPcFsnZGVsZXRlJ10pIHtcbiAgICAgICAgZGVsdGEucHVzaChvdGhlck9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIHJldGFpbiBlaXRoZXIgdGhlaXIgcmV0YWluIG9yIGluc2VydFxuICAgICAgICBkZWx0YS5yZXRhaW4obGVuZ3RoLCBvcC5hdHRyaWJ1dGVzLnRyYW5zZm9ybSh0aGlzT3AuYXR0cmlidXRlcywgb3RoZXJPcC5hdHRyaWJ1dGVzLCBwcmlvcml0eSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGVsdGEuY2hvcCgpO1xufTtcblxuRGVsdGEucHJvdG90eXBlLnRyYW5zZm9ybVBvc2l0aW9uID0gZnVuY3Rpb24gKGluZGV4LCBwcmlvcml0eSkge1xuICBwcmlvcml0eSA9ICEhcHJpb3JpdHk7XG4gIHZhciB0aGlzSXRlciA9IG9wLml0ZXJhdG9yKHRoaXMub3BzKTtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHdoaWxlICh0aGlzSXRlci5oYXNOZXh0KCkgJiYgb2Zmc2V0IDw9IGluZGV4KSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXNJdGVyLnBlZWtMZW5ndGgoKTtcbiAgICB2YXIgbmV4dFR5cGUgPSB0aGlzSXRlci5wZWVrVHlwZSgpO1xuICAgIHRoaXNJdGVyLm5leHQoKTtcbiAgICBpZiAobmV4dFR5cGUgPT09ICdkZWxldGUnKSB7XG4gICAgICBpbmRleCAtPSBNYXRoLm1pbihsZW5ndGgsIGluZGV4IC0gb2Zmc2V0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAobmV4dFR5cGUgPT09ICdpbnNlcnQnICYmIChvZmZzZXQgPCBpbmRleCB8fCAhcHJpb3JpdHkpKSB7XG4gICAgICBpbmRleCArPSBsZW5ndGg7XG4gICAgfVxuICAgIG9mZnNldCArPSBsZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IERlbHRhO1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KGFycikge1xuXHRpZiAodHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpO1xuXHR9XG5cblx0cmV0dXJuIHRvU3RyLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBpc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcblx0aWYgKCFvYmogfHwgdG9TdHIuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBoYXNPd25Db25zdHJ1Y3RvciA9IGhhc093bi5jYWxsKG9iaiwgJ2NvbnN0cnVjdG9yJyk7XG5cdHZhciBoYXNJc1Byb3RvdHlwZU9mID0gb2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgJiYgaGFzT3duLmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ2lzUHJvdG90eXBlT2YnKTtcblx0Ly8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuXHRpZiAob2JqLmNvbnN0cnVjdG9yICYmICFoYXNPd25Db25zdHJ1Y3RvciAmJiAhaGFzSXNQcm90b3R5cGVPZikge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIE93biBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIGZpcnN0bHksIHNvIHRvIHNwZWVkIHVwLFxuXHQvLyBpZiBsYXN0IG9uZSBpcyBvd24sIHRoZW4gYWxsIHByb3BlcnRpZXMgYXJlIG93bi5cblx0dmFyIGtleTtcblx0Zm9yIChrZXkgaW4gb2JqKSB7IC8qKi8gfVxuXG5cdHJldHVybiB0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJyB8fCBoYXNPd24uY2FsbChvYmosIGtleSk7XG59O1xuXG4vLyBJZiBuYW1lIGlzICdfX3Byb3RvX18nLCBhbmQgT2JqZWN0LmRlZmluZVByb3BlcnR5IGlzIGF2YWlsYWJsZSwgZGVmaW5lIF9fcHJvdG9fXyBhcyBhbiBvd24gcHJvcGVydHkgb24gdGFyZ2V0XG52YXIgc2V0UHJvcGVydHkgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0eSh0YXJnZXQsIG9wdGlvbnMpIHtcblx0aWYgKGRlZmluZVByb3BlcnR5ICYmIG9wdGlvbnMubmFtZSA9PT0gJ19fcHJvdG9fXycpIHtcblx0XHRkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG9wdGlvbnMubmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiBvcHRpb25zLm5ld1ZhbHVlLFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR0YXJnZXRbb3B0aW9ucy5uYW1lXSA9IG9wdGlvbnMubmV3VmFsdWU7XG5cdH1cbn07XG5cbi8vIFJldHVybiB1bmRlZmluZWQgaW5zdGVhZCBvZiBfX3Byb3RvX18gaWYgJ19fcHJvdG9fXycgaXMgbm90IGFuIG93biBwcm9wZXJ0eVxudmFyIGdldFByb3BlcnR5ID0gZnVuY3Rpb24gZ2V0UHJvcGVydHkob2JqLCBuYW1lKSB7XG5cdGlmIChuYW1lID09PSAnX19wcm90b19fJykge1xuXHRcdGlmICghaGFzT3duLmNhbGwob2JqLCBuYW1lKSkge1xuXHRcdFx0cmV0dXJuIHZvaWQgMDtcblx0XHR9IGVsc2UgaWYgKGdPUEQpIHtcblx0XHRcdC8vIEluIGVhcmx5IHZlcnNpb25zIG9mIG5vZGUsIG9ialsnX19wcm90b19fJ10gaXMgYnVnZ3kgd2hlbiBvYmogaGFzXG5cdFx0XHQvLyBfX3Byb3RvX18gYXMgYW4gb3duIHByb3BlcnR5LiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCkgd29ya3MuXG5cdFx0XHRyZXR1cm4gZ09QRChvYmosIG5hbWUpLnZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvYmpbbmFtZV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4dGVuZCgpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lO1xuXHR2YXIgdGFyZ2V0ID0gYXJndW1lbnRzWzBdO1xuXHR2YXIgaSA9IDE7XG5cdHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXHR2YXIgZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKHR5cGVvZiB0YXJnZXQgPT09ICdib29sZWFuJykge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuXHRcdC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHRpID0gMjtcblx0fVxuXHRpZiAodGFyZ2V0ID09IG51bGwgfHwgKHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnICYmIHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHRmb3IgKDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1tpXTtcblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yIChuYW1lIGluIG9wdGlvbnMpIHtcblx0XHRcdFx0c3JjID0gZ2V0UHJvcGVydHkodGFyZ2V0LCBuYW1lKTtcblx0XHRcdFx0Y29weSA9IGdldFByb3BlcnR5KG9wdGlvbnMsIG5hbWUpO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKHRhcmdldCAhPT0gY29weSkge1xuXHRcdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRcdGlmIChkZWVwICYmIGNvcHkgJiYgKGlzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0gaXNBcnJheShjb3B5KSkpKSB7XG5cdFx0XHRcdFx0XHRpZiAoY29weUlzQXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBpc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0XHRzZXRQcm9wZXJ0eSh0YXJnZXQsIHsgbmFtZTogbmFtZSwgbmV3VmFsdWU6IGV4dGVuZChkZWVwLCBjbG9uZSwgY29weSkgfSk7XG5cblx0XHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgY29weSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRcdHNldFByb3BlcnR5KHRhcmdldCwgeyBuYW1lOiBuYW1lLCBuZXdWYWx1ZTogY29weSB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuQmxvY2tFbWJlZCA9IGV4cG9ydHMuYnViYmxlRm9ybWF0cyA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2V4dGVuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZXh0ZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZCk7XG5cbnZhciBfcXVpbGxEZWx0YSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfcXVpbGxEZWx0YTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbERlbHRhKTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX2JyZWFrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBfYnJlYWsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJlYWspO1xuXG52YXIgX2lubGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfaW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lubGluZSk7XG5cbnZhciBfdGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZXh0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgTkVXTElORV9MRU5HVEggPSAxO1xuXG52YXIgQmxvY2tFbWJlZCA9IGZ1bmN0aW9uIChfUGFyY2htZW50JEVtYmVkKSB7XG4gIF9pbmhlcml0cyhCbG9ja0VtYmVkLCBfUGFyY2htZW50JEVtYmVkKTtcblxuICBmdW5jdGlvbiBCbG9ja0VtYmVkKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCbG9ja0VtYmVkKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQmxvY2tFbWJlZC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrRW1iZWQpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCbG9ja0VtYmVkLCBbe1xuICAgIGtleTogJ2F0dGFjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaCgpIHtcbiAgICAgIF9nZXQoQmxvY2tFbWJlZC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9ja0VtYmVkLnByb3RvdHlwZSksICdhdHRhY2gnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5TdG9yZSh0aGlzLmRvbU5vZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlbHRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsdGEoKSB7XG4gICAgICByZXR1cm4gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkuaW5zZXJ0KHRoaXMudmFsdWUoKSwgKDAsIF9leHRlbmQyLmRlZmF1bHQpKHRoaXMuZm9ybWF0cygpLCB0aGlzLmF0dHJpYnV0ZXMudmFsdWVzKCkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGUgPSBfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KG5hbWUsIF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0tfQVRUUklCVVRFKTtcbiAgICAgIGlmIChhdHRyaWJ1dGUgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMuYXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdEF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnNlcnRBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEF0KGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnXFxuJykpIHtcbiAgICAgICAgdmFyIGJsb2NrID0gX3BhcmNobWVudDIuZGVmYXVsdC5jcmVhdGUoQmxvY2suYmxvdE5hbWUpO1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYmxvY2ssIGluZGV4ID09PSAwID8gdGhpcyA6IHRoaXMubmV4dCk7XG4gICAgICAgIGJsb2NrLmluc2VydEF0KDAsIHZhbHVlLnNsaWNlKDAsIC0xKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0KEJsb2NrRW1iZWQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2tFbWJlZC5wcm90b3R5cGUpLCAnaW5zZXJ0QXQnLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4LCB2YWx1ZSwgZGVmKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmxvY2tFbWJlZDtcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5FbWJlZCk7XG5cbkJsb2NrRW1iZWQuc2NvcGUgPSBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLX0JMT1Q7XG4vLyBJdCBpcyBpbXBvcnRhbnQgZm9yIGN1cnNvciBiZWhhdmlvciBCbG9ja0VtYmVkcyB1c2UgdGFncyB0aGF0IGFyZSBibG9jayBsZXZlbCBlbGVtZW50c1xuXG5cbnZhciBCbG9jayA9IGZ1bmN0aW9uIChfUGFyY2htZW50JEJsb2NrKSB7XG4gIF9pbmhlcml0cyhCbG9jaywgX1BhcmNobWVudCRCbG9jayk7XG5cbiAgZnVuY3Rpb24gQmxvY2soZG9tTm9kZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCbG9jayk7XG5cbiAgICB2YXIgX3RoaXMyID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJsb2NrLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2spKS5jYWxsKHRoaXMsIGRvbU5vZGUpKTtcblxuICAgIF90aGlzMi5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmxvY2ssIFt7XG4gICAga2V5OiAnZGVsdGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWx0YSgpIHtcbiAgICAgIGlmICh0aGlzLmNhY2hlLmRlbHRhID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5kZWx0YSA9IHRoaXMuZGVzY2VuZGFudHMoX3BhcmNobWVudDIuZGVmYXVsdC5MZWFmKS5yZWR1Y2UoZnVuY3Rpb24gKGRlbHRhLCBsZWFmKSB7XG4gICAgICAgICAgaWYgKGxlYWYubGVuZ3RoKCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBkZWx0YTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhLmluc2VydChsZWFmLnZhbHVlKCksIGJ1YmJsZUZvcm1hdHMobGVhZikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkpLmluc2VydCgnXFxuJywgYnViYmxlRm9ybWF0cyh0aGlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZS5kZWx0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUF0KGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIF9nZXQoQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgJ2RlbGV0ZUF0JywgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAobGVuZ3RoIDw9IDApIHJldHVybjtcbiAgICAgIGlmIChfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KG5hbWUsIF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0spKSB7XG4gICAgICAgIGlmIChpbmRleCArIGxlbmd0aCA9PT0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICAgIHRoaXMuZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dldChCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCAnZm9ybWF0QXQnLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4LCBNYXRoLm1pbihsZW5ndGgsIHRoaXMubGVuZ3RoKCkgLSBpbmRleCAtIDEpLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0QXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRBdChpbmRleCwgdmFsdWUsIGRlZikge1xuICAgICAgaWYgKGRlZiAhPSBudWxsKSByZXR1cm4gX2dldChCbG9jay5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCAnaW5zZXJ0QXQnLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4LCB2YWx1ZSwgZGVmKTtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIHZhciBsaW5lcyA9IHZhbHVlLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciB0ZXh0ID0gbGluZXMuc2hpZnQoKTtcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5sZW5ndGgoKSAtIDEgfHwgdGhpcy5jaGlsZHJlbi50YWlsID09IG51bGwpIHtcbiAgICAgICAgICBfZ2V0KEJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksICdpbnNlcnRBdCcsIHRoaXMpLmNhbGwodGhpcywgTWF0aC5taW4oaW5kZXgsIHRoaXMubGVuZ3RoKCkgLSAxKSwgdGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbi50YWlsLmluc2VydEF0KHRoaXMuY2hpbGRyZW4udGFpbC5sZW5ndGgoKSwgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgICAgfVxuICAgICAgdmFyIGJsb2NrID0gdGhpcztcbiAgICAgIGxpbmVzLnJlZHVjZShmdW5jdGlvbiAoaW5kZXgsIGxpbmUpIHtcbiAgICAgICAgYmxvY2sgPSBibG9jay5zcGxpdChpbmRleCwgdHJ1ZSk7XG4gICAgICAgIGJsb2NrLmluc2VydEF0KDAsIGxpbmUpO1xuICAgICAgICByZXR1cm4gbGluZS5sZW5ndGg7XG4gICAgICB9LCBpbmRleCArIHRleHQubGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnNlcnRCZWZvcmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoYmxvdCwgcmVmKSB7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuY2hpbGRyZW4uaGVhZDtcbiAgICAgIF9nZXQoQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgJ2luc2VydEJlZm9yZScsIHRoaXMpLmNhbGwodGhpcywgYmxvdCwgcmVmKTtcbiAgICAgIGlmIChoZWFkIGluc3RhbmNlb2YgX2JyZWFrMi5kZWZhdWx0KSB7XG4gICAgICAgIGhlYWQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGVuZ3RoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5sZW5ndGggPSBfZ2V0KEJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksICdsZW5ndGgnLCB0aGlzKS5jYWxsKHRoaXMpICsgTkVXTElORV9MRU5HVEg7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZS5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbW92ZUNoaWxkcmVuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZUNoaWxkcmVuKHRhcmdldCwgcmVmKSB7XG4gICAgICBfZ2V0KEJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksICdtb3ZlQ2hpbGRyZW4nLCB0aGlzKS5jYWxsKHRoaXMsIHRhcmdldCwgcmVmKTtcbiAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvcHRpbWl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKGNvbnRleHQpIHtcbiAgICAgIF9nZXQoQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgJ29wdGltaXplJywgdGhpcykuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwYXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aChpbmRleCkge1xuICAgICAgcmV0dXJuIF9nZXQoQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgJ3BhdGgnLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4LCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmVDaGlsZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgICBfZ2V0KEJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksICdyZW1vdmVDaGlsZCcsIHRoaXMpLmNhbGwodGhpcywgY2hpbGQpO1xuICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NwbGl0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3BsaXQoaW5kZXgpIHtcbiAgICAgIHZhciBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgIGlmIChmb3JjZSAmJiAoaW5kZXggPT09IDAgfHwgaW5kZXggPj0gdGhpcy5sZW5ndGgoKSAtIE5FV0xJTkVfTEVOR1RIKSkge1xuICAgICAgICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShjbG9uZSwgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGNsb25lLCB0aGlzLm5leHQpO1xuICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5leHQgPSBfZ2V0KEJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksICdzcGxpdCcsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIGZvcmNlKTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmxvY2s7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuQmxvY2spO1xuXG5CbG9jay5ibG90TmFtZSA9ICdibG9jayc7XG5CbG9jay50YWdOYW1lID0gJ1AnO1xuQmxvY2suZGVmYXVsdENoaWxkID0gJ2JyZWFrJztcbkJsb2NrLmFsbG93ZWRDaGlsZHJlbiA9IFtfaW5saW5lMi5kZWZhdWx0LCBfcGFyY2htZW50Mi5kZWZhdWx0LkVtYmVkLCBfdGV4dDIuZGVmYXVsdF07XG5cbmZ1bmN0aW9uIGJ1YmJsZUZvcm1hdHMoYmxvdCkge1xuICB2YXIgZm9ybWF0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgaWYgKGJsb3QgPT0gbnVsbCkgcmV0dXJuIGZvcm1hdHM7XG4gIGlmICh0eXBlb2YgYmxvdC5mb3JtYXRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm9ybWF0cyA9ICgwLCBfZXh0ZW5kMi5kZWZhdWx0KShmb3JtYXRzLCBibG90LmZvcm1hdHMoKSk7XG4gIH1cbiAgaWYgKGJsb3QucGFyZW50ID09IG51bGwgfHwgYmxvdC5wYXJlbnQuYmxvdE5hbWUgPT0gJ3Njcm9sbCcgfHwgYmxvdC5wYXJlbnQuc3RhdGljcy5zY29wZSAhPT0gYmxvdC5zdGF0aWNzLnNjb3BlKSB7XG4gICAgcmV0dXJuIGZvcm1hdHM7XG4gIH1cbiAgcmV0dXJuIGJ1YmJsZUZvcm1hdHMoYmxvdC5wYXJlbnQsIGZvcm1hdHMpO1xufVxuXG5leHBvcnRzLmJ1YmJsZUZvcm1hdHMgPSBidWJibGVGb3JtYXRzO1xuZXhwb3J0cy5CbG9ja0VtYmVkID0gQmxvY2tFbWJlZDtcbmV4cG9ydHMuZGVmYXVsdCA9IEJsb2NrO1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMub3ZlcmxvYWQgPSBleHBvcnRzLmV4cGFuZENvbmZpZyA9IHVuZGVmaW5lZDtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oNTApO1xuXG52YXIgX3F1aWxsRGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX3F1aWxsRGVsdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGxEZWx0YSk7XG5cbnZhciBfZWRpdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbnZhciBfZWRpdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VkaXRvcik7XG5cbnZhciBfZW1pdHRlcjMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgX2VtaXR0ZXI0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZW1pdHRlcjMpO1xuXG52YXIgX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfbW9kdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZSk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9zZWxlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIF9zZWxlY3Rpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2VsZWN0aW9uKTtcblxudmFyIF9leHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2V4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmQpO1xuXG52YXIgX2xvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgX2xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2dnZXIpO1xuXG52YXIgX3RoZW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG5cbnZhciBfdGhlbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGhlbWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgZGVidWcgPSAoMCwgX2xvZ2dlcjIuZGVmYXVsdCkoJ3F1aWxsJyk7XG5cbnZhciBRdWlsbCA9IGZ1bmN0aW9uICgpIHtcbiAgX2NyZWF0ZUNsYXNzKFF1aWxsLCBudWxsLCBbe1xuICAgIGtleTogJ2RlYnVnJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVidWcobGltaXQpIHtcbiAgICAgIGlmIChsaW1pdCA9PT0gdHJ1ZSkge1xuICAgICAgICBsaW1pdCA9ICdsb2cnO1xuICAgICAgfVxuICAgICAgX2xvZ2dlcjIuZGVmYXVsdC5sZXZlbChsaW1pdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZmluZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmQobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuX19xdWlsbCB8fCBfcGFyY2htZW50Mi5kZWZhdWx0LmZpbmQobm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW1wb3J0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ltcG9ydChuYW1lKSB7XG4gICAgICBpZiAodGhpcy5pbXBvcnRzW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgZGVidWcuZXJyb3IoJ0Nhbm5vdCBpbXBvcnQgJyArIG5hbWUgKyAnLiBBcmUgeW91IHN1cmUgaXQgd2FzIHJlZ2lzdGVyZWQ/Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5pbXBvcnRzW25hbWVdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIocGF0aCwgdGFyZ2V0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgb3ZlcndyaXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgbmFtZSA9IHBhdGguYXR0ck5hbWUgfHwgcGF0aC5ibG90TmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIHJlZ2lzdGVyKEJsb3QgfCBBdHRyaWJ1dG9yLCBvdmVyd3JpdGUpXG4gICAgICAgICAgdGhpcy5yZWdpc3RlcignZm9ybWF0cy8nICsgbmFtZSwgcGF0aCwgdGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhwYXRoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIF90aGlzLnJlZ2lzdGVyKGtleSwgcGF0aFtrZXldLCB0YXJnZXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5pbXBvcnRzW3BhdGhdICE9IG51bGwgJiYgIW92ZXJ3cml0ZSkge1xuICAgICAgICAgIGRlYnVnLndhcm4oJ092ZXJ3cml0aW5nICcgKyBwYXRoICsgJyB3aXRoJywgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmltcG9ydHNbcGF0aF0gPSB0YXJnZXQ7XG4gICAgICAgIGlmICgocGF0aC5zdGFydHNXaXRoKCdibG90cy8nKSB8fCBwYXRoLnN0YXJ0c1dpdGgoJ2Zvcm1hdHMvJykpICYmIHRhcmdldC5ibG90TmFtZSAhPT0gJ2Fic3RyYWN0Jykge1xuICAgICAgICAgIF9wYXJjaG1lbnQyLmRlZmF1bHQucmVnaXN0ZXIodGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXRoLnN0YXJ0c1dpdGgoJ21vZHVsZXMnKSAmJiB0eXBlb2YgdGFyZ2V0LnJlZ2lzdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlZ2lzdGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBRdWlsbChjb250YWluZXIpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRdWlsbCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBleHBhbmRDb25maWcoY29udGFpbmVyLCBvcHRpb25zKTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBkZWJ1Zy5lcnJvcignSW52YWxpZCBRdWlsbCBjb250YWluZXInLCBjb250YWluZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICBRdWlsbC5kZWJ1Zyh0aGlzLm9wdGlvbnMuZGVidWcpO1xuICAgIH1cbiAgICB2YXIgaHRtbCA9IHRoaXMuY29udGFpbmVyLmlubmVySFRNTC50cmltKCk7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCgncWwtY29udGFpbmVyJyk7XG4gICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgdGhpcy5jb250YWluZXIuX19xdWlsbCA9IHRoaXM7XG4gICAgdGhpcy5yb290ID0gdGhpcy5hZGRDb250YWluZXIoJ3FsLWVkaXRvcicpO1xuICAgIHRoaXMucm9vdC5jbGFzc0xpc3QuYWRkKCdxbC1ibGFuaycpO1xuICAgIHRoaXMucm9vdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZ3JhbW0nLCBmYWxzZSk7XG4gICAgdGhpcy5zY3JvbGxpbmdDb250YWluZXIgPSB0aGlzLm9wdGlvbnMuc2Nyb2xsaW5nQ29udGFpbmVyIHx8IHRoaXMucm9vdDtcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgX2VtaXR0ZXI0LmRlZmF1bHQoKTtcbiAgICB0aGlzLnNjcm9sbCA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKHRoaXMucm9vdCwge1xuICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxuICAgICAgd2hpdGVsaXN0OiB0aGlzLm9wdGlvbnMuZm9ybWF0c1xuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yID0gbmV3IF9lZGl0b3IyLmRlZmF1bHQodGhpcy5zY3JvbGwpO1xuICAgIHRoaXMuc2VsZWN0aW9uID0gbmV3IF9zZWxlY3Rpb24yLmRlZmF1bHQodGhpcy5zY3JvbGwsIHRoaXMuZW1pdHRlcik7XG4gICAgdGhpcy50aGVtZSA9IG5ldyB0aGlzLm9wdGlvbnMudGhlbWUodGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLmtleWJvYXJkID0gdGhpcy50aGVtZS5hZGRNb2R1bGUoJ2tleWJvYXJkJyk7XG4gICAgdGhpcy5jbGlwYm9hcmQgPSB0aGlzLnRoZW1lLmFkZE1vZHVsZSgnY2xpcGJvYXJkJyk7XG4gICAgdGhpcy5oaXN0b3J5ID0gdGhpcy50aGVtZS5hZGRNb2R1bGUoJ2hpc3RvcnknKTtcbiAgICB0aGlzLnRoZW1lLmluaXQoKTtcbiAgICB0aGlzLmVtaXR0ZXIub24oX2VtaXR0ZXI0LmRlZmF1bHQuZXZlbnRzLkVESVRPUl9DSEFOR0UsIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gX2VtaXR0ZXI0LmRlZmF1bHQuZXZlbnRzLlRFWFRfQ0hBTkdFKSB7XG4gICAgICAgIF90aGlzMi5yb290LmNsYXNzTGlzdC50b2dnbGUoJ3FsLWJsYW5rJywgX3RoaXMyLmVkaXRvci5pc0JsYW5rKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdHRlci5vbihfZW1pdHRlcjQuZGVmYXVsdC5ldmVudHMuU0NST0xMX1VQREFURSwgZnVuY3Rpb24gKHNvdXJjZSwgbXV0YXRpb25zKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBfdGhpczIuc2VsZWN0aW9uLmxhc3RSYW5nZTtcbiAgICAgIHZhciBpbmRleCA9IHJhbmdlICYmIHJhbmdlLmxlbmd0aCA9PT0gMCA/IHJhbmdlLmluZGV4IDogdW5kZWZpbmVkO1xuICAgICAgbW9kaWZ5LmNhbGwoX3RoaXMyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuZWRpdG9yLnVwZGF0ZShudWxsLCBtdXRhdGlvbnMsIGluZGV4KTtcbiAgICAgIH0sIHNvdXJjZSk7XG4gICAgfSk7XG4gICAgdmFyIGNvbnRlbnRzID0gdGhpcy5jbGlwYm9hcmQuY29udmVydCgnPGRpdiBjbGFzcz1cXCdxbC1lZGl0b3JcXCcgc3R5bGU9XCJ3aGl0ZS1zcGFjZTogbm9ybWFsO1wiPicgKyBodG1sICsgJzxwPjxicj48L3A+PC9kaXY+Jyk7XG4gICAgdGhpcy5zZXRDb250ZW50cyhjb250ZW50cyk7XG4gICAgdGhpcy5oaXN0b3J5LmNsZWFyKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcikge1xuICAgICAgdGhpcy5yb290LnNldEF0dHJpYnV0ZSgnZGF0YS1wbGFjZWhvbGRlcicsIHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVhZE9ubHkpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhRdWlsbCwgW3tcbiAgICBrZXk6ICdhZGRDb250YWluZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICB2YXIgcmVmTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiBjb250YWluZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBjb250YWluZXI7XG4gICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgcmVmTm9kZSk7XG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2JsdXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBibHVyKCkge1xuICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0UmFuZ2UobnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVsZXRlVGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVRleHQoaW5kZXgsIGxlbmd0aCwgc291cmNlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIF9vdmVybG9hZCA9IG92ZXJsb2FkKGluZGV4LCBsZW5ndGgsIHNvdXJjZSk7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQyID0gX3NsaWNlZFRvQXJyYXkoX292ZXJsb2FkLCA0KTtcblxuICAgICAgaW5kZXggPSBfb3ZlcmxvYWQyWzBdO1xuICAgICAgbGVuZ3RoID0gX292ZXJsb2FkMlsxXTtcbiAgICAgIHNvdXJjZSA9IF9vdmVybG9hZDJbM107XG5cbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMuZWRpdG9yLmRlbGV0ZVRleHQoaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9LCBzb3VyY2UsIGluZGV4LCAtMSAqIGxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzYWJsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICB0aGlzLmVuYWJsZShmYWxzZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgdmFyIGVuYWJsZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG5cbiAgICAgIHRoaXMuc2Nyb2xsLmVuYWJsZShlbmFibGVkKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC50b2dnbGUoJ3FsLWRpc2FibGVkJywgIWVuYWJsZWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZvY3VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wO1xuICAgICAgdGhpcy5zZWxlY3Rpb24uZm9jdXMoKTtcbiAgICAgIHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLkFQSTtcblxuICAgICAgcmV0dXJuIG1vZGlmeS5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gX3RoaXM0LmdldFNlbGVjdGlvbih0cnVlKTtcbiAgICAgICAgdmFyIGNoYW5nZSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpO1xuICAgICAgICBpZiAocmFuZ2UgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgICAgIH0gZWxzZSBpZiAoX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShuYW1lLCBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLKSkge1xuICAgICAgICAgIGNoYW5nZSA9IF90aGlzNC5lZGl0b3IuZm9ybWF0TGluZShyYW5nZS5pbmRleCwgcmFuZ2UubGVuZ3RoLCBfZGVmaW5lUHJvcGVydHkoe30sIG5hbWUsIHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmFuZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgX3RoaXM0LnNlbGVjdGlvbi5mb3JtYXQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhbmdlID0gX3RoaXM0LmVkaXRvci5mb3JtYXRUZXh0KHJhbmdlLmluZGV4LCByYW5nZS5sZW5ndGgsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgbmFtZSwgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczQuc2V0U2VsZWN0aW9uKHJhbmdlLCBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgICB9LCBzb3VyY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdExpbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRMaW5lKGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlLCBzb3VyY2UpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgZm9ybWF0cyA9IHZvaWQgMDtcblxuICAgICAgdmFyIF9vdmVybG9hZDMgPSBvdmVybG9hZChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSwgc291cmNlKTtcblxuICAgICAgdmFyIF9vdmVybG9hZDQgPSBfc2xpY2VkVG9BcnJheShfb3ZlcmxvYWQzLCA0KTtcblxuICAgICAgaW5kZXggPSBfb3ZlcmxvYWQ0WzBdO1xuICAgICAgbGVuZ3RoID0gX292ZXJsb2FkNFsxXTtcbiAgICAgIGZvcm1hdHMgPSBfb3ZlcmxvYWQ0WzJdO1xuICAgICAgc291cmNlID0gX292ZXJsb2FkNFszXTtcblxuICAgICAgcmV0dXJuIG1vZGlmeS5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNS5lZGl0b3IuZm9ybWF0TGluZShpbmRleCwgbGVuZ3RoLCBmb3JtYXRzKTtcbiAgICAgIH0sIHNvdXJjZSwgaW5kZXgsIDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdFRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRUZXh0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlLCBzb3VyY2UpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB2YXIgZm9ybWF0cyA9IHZvaWQgMDtcblxuICAgICAgdmFyIF9vdmVybG9hZDUgPSBvdmVybG9hZChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSwgc291cmNlKTtcblxuICAgICAgdmFyIF9vdmVybG9hZDYgPSBfc2xpY2VkVG9BcnJheShfb3ZlcmxvYWQ1LCA0KTtcblxuICAgICAgaW5kZXggPSBfb3ZlcmxvYWQ2WzBdO1xuICAgICAgbGVuZ3RoID0gX292ZXJsb2FkNlsxXTtcbiAgICAgIGZvcm1hdHMgPSBfb3ZlcmxvYWQ2WzJdO1xuICAgICAgc291cmNlID0gX292ZXJsb2FkNlszXTtcblxuICAgICAgcmV0dXJuIG1vZGlmeS5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNi5lZGl0b3IuZm9ybWF0VGV4dChpbmRleCwgbGVuZ3RoLCBmb3JtYXRzKTtcbiAgICAgIH0sIHNvdXJjZSwgaW5kZXgsIDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEJvdW5kcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kcyhpbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICAgICAgdmFyIGJvdW5kcyA9IHZvaWQgMDtcbiAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgIGJvdW5kcyA9IHRoaXMuc2VsZWN0aW9uLmdldEJvdW5kcyhpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kcyA9IHRoaXMuc2VsZWN0aW9uLmdldEJvdW5kcyhpbmRleC5pbmRleCwgaW5kZXgubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb250YWluZXJCb3VuZHMgPSB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJvdHRvbTogYm91bmRzLmJvdHRvbSAtIGNvbnRhaW5lckJvdW5kcy50b3AsXG4gICAgICAgIGhlaWdodDogYm91bmRzLmhlaWdodCxcbiAgICAgICAgbGVmdDogYm91bmRzLmxlZnQgLSBjb250YWluZXJCb3VuZHMubGVmdCxcbiAgICAgICAgcmlnaHQ6IGJvdW5kcy5yaWdodCAtIGNvbnRhaW5lckJvdW5kcy5sZWZ0LFxuICAgICAgICB0b3A6IGJvdW5kcy50b3AgLSBjb250YWluZXJCb3VuZHMudG9wLFxuICAgICAgICB3aWR0aDogYm91bmRzLndpZHRoXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldENvbnRlbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGVudHMoKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLmdldExlbmd0aCgpIC0gaW5kZXg7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQ3ID0gb3ZlcmxvYWQoaW5kZXgsIGxlbmd0aCk7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQ4ID0gX3NsaWNlZFRvQXJyYXkoX292ZXJsb2FkNywgMik7XG5cbiAgICAgIGluZGV4ID0gX292ZXJsb2FkOFswXTtcbiAgICAgIGxlbmd0aCA9IF9vdmVybG9hZDhbMV07XG5cbiAgICAgIHJldHVybiB0aGlzLmVkaXRvci5nZXRDb250ZW50cyhpbmRleCwgbGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRGb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JtYXQoKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuZ2V0U2VsZWN0aW9uKHRydWUpO1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmdldEZvcm1hdChpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5nZXRGb3JtYXQoaW5kZXguaW5kZXgsIGluZGV4Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0SW5kZXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmRleChibG90KSB7XG4gICAgICByZXR1cm4gYmxvdC5vZmZzZXQodGhpcy5zY3JvbGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldExlbmd0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExlbmd0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbC5sZW5ndGgoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRMZWFmJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGVhZihpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsLmxlYWYoaW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldExpbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMaW5lKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGwubGluZShpbmRleCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0TGluZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMaW5lcygpIHtcbiAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbC5saW5lcyhpbmRleC5pbmRleCwgaW5kZXgubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbC5saW5lcyhpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRNb2R1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb2R1bGUobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbWUubW9kdWxlc1tuYW1lXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTZWxlY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3Rpb24oKSB7XG4gICAgICB2YXIgZm9jdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoZm9jdXMpIHRoaXMuZm9jdXMoKTtcbiAgICAgIHRoaXMudXBkYXRlKCk7IC8vIE1ha2Ugc3VyZSB3ZSBhY2Nlc3MgZ2V0UmFuZ2Ugd2l0aCBlZGl0b3IgaW4gY29uc2lzdGVudCBzdGF0ZVxuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmdldFJhbmdlKClbMF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRleHQoKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLmdldExlbmd0aCgpIC0gaW5kZXg7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQ5ID0gb3ZlcmxvYWQoaW5kZXgsIGxlbmd0aCk7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQxMCA9IF9zbGljZWRUb0FycmF5KF9vdmVybG9hZDksIDIpO1xuXG4gICAgICBpbmRleCA9IF9vdmVybG9hZDEwWzBdO1xuICAgICAgbGVuZ3RoID0gX292ZXJsb2FkMTBbMV07XG5cbiAgICAgIHJldHVybiB0aGlzLmVkaXRvci5nZXRUZXh0KGluZGV4LCBsZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hhc0ZvY3VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzRm9jdXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uaGFzRm9jdXMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnNlcnRFbWJlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEVtYmVkKGluZGV4LCBlbWJlZCwgdmFsdWUpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBRdWlsbC5zb3VyY2VzLkFQSTtcblxuICAgICAgcmV0dXJuIG1vZGlmeS5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNy5lZGl0b3IuaW5zZXJ0RW1iZWQoaW5kZXgsIGVtYmVkLCB2YWx1ZSk7XG4gICAgICB9LCBzb3VyY2UsIGluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnNlcnRUZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0VGV4dChpbmRleCwgdGV4dCwgbmFtZSwgdmFsdWUsIHNvdXJjZSkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3JtYXRzID0gdm9pZCAwO1xuXG4gICAgICB2YXIgX292ZXJsb2FkMTEgPSBvdmVybG9hZChpbmRleCwgMCwgbmFtZSwgdmFsdWUsIHNvdXJjZSk7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQxMiA9IF9zbGljZWRUb0FycmF5KF9vdmVybG9hZDExLCA0KTtcblxuICAgICAgaW5kZXggPSBfb3ZlcmxvYWQxMlswXTtcbiAgICAgIGZvcm1hdHMgPSBfb3ZlcmxvYWQxMlsyXTtcbiAgICAgIHNvdXJjZSA9IF9vdmVybG9hZDEyWzNdO1xuXG4gICAgICByZXR1cm4gbW9kaWZ5LmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM4LmVkaXRvci5pbnNlcnRUZXh0KGluZGV4LCB0ZXh0LCBmb3JtYXRzKTtcbiAgICAgIH0sIHNvdXJjZSwgaW5kZXgsIHRleHQubGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpc0VuYWJsZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucygncWwtZGlzYWJsZWQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvZmYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvZmYoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0dGVyLm9mZi5hcHBseSh0aGlzLmVtaXR0ZXIsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXR0ZXIub24uYXBwbHkodGhpcy5lbWl0dGVyLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbmNlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdHRlci5vbmNlLmFwcGx5KHRoaXMuZW1pdHRlciwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwYXN0ZUhUTUwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXN0ZUhUTUwoaW5kZXgsIGh0bWwsIHNvdXJjZSkge1xuICAgICAgdGhpcy5jbGlwYm9hcmQuZGFuZ2Vyb3VzbHlQYXN0ZUhUTUwoaW5kZXgsIGh0bWwsIHNvdXJjZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlRm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRm9ybWF0KGluZGV4LCBsZW5ndGgsIHNvdXJjZSkge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQxMyA9IG92ZXJsb2FkKGluZGV4LCBsZW5ndGgsIHNvdXJjZSk7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQxNCA9IF9zbGljZWRUb0FycmF5KF9vdmVybG9hZDEzLCA0KTtcblxuICAgICAgaW5kZXggPSBfb3ZlcmxvYWQxNFswXTtcbiAgICAgIGxlbmd0aCA9IF9vdmVybG9hZDE0WzFdO1xuICAgICAgc291cmNlID0gX292ZXJsb2FkMTRbM107XG5cbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczkuZWRpdG9yLnJlbW92ZUZvcm1hdChpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH0sIHNvdXJjZSwgaW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Njcm9sbEludG9WaWV3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5zY3JvbGxJbnRvVmlldyh0aGlzLnNjcm9sbGluZ0NvbnRhaW5lcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0Q29udGVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb250ZW50cyhkZWx0YSkge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLkFQSTtcblxuICAgICAgcmV0dXJuIG1vZGlmeS5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVsdGEgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoZGVsdGEpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gX3RoaXMxMC5nZXRMZW5ndGgoKTtcbiAgICAgICAgdmFyIGRlbGV0ZWQgPSBfdGhpczEwLmVkaXRvci5kZWxldGVUZXh0KDAsIGxlbmd0aCk7XG4gICAgICAgIHZhciBhcHBsaWVkID0gX3RoaXMxMC5lZGl0b3IuYXBwbHlEZWx0YShkZWx0YSk7XG4gICAgICAgIHZhciBsYXN0T3AgPSBhcHBsaWVkLm9wc1thcHBsaWVkLm9wcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RPcCAhPSBudWxsICYmIHR5cGVvZiBsYXN0T3AuaW5zZXJ0ID09PSAnc3RyaW5nJyAmJiBsYXN0T3AuaW5zZXJ0W2xhc3RPcC5pbnNlcnQubGVuZ3RoIC0gMV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgX3RoaXMxMC5lZGl0b3IuZGVsZXRlVGV4dChfdGhpczEwLmdldExlbmd0aCgpIC0gMSwgMSk7XG4gICAgICAgICAgYXBwbGllZC5kZWxldGUoMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldCA9IGRlbGV0ZWQuY29tcG9zZShhcHBsaWVkKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sIHNvdXJjZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0U2VsZWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGluZGV4LCBsZW5ndGgsIHNvdXJjZSkge1xuICAgICAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0UmFuZ2UobnVsbCwgbGVuZ3RoIHx8IFF1aWxsLnNvdXJjZXMuQVBJKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfb3ZlcmxvYWQxNSA9IG92ZXJsb2FkKGluZGV4LCBsZW5ndGgsIHNvdXJjZSk7XG5cbiAgICAgICAgdmFyIF9vdmVybG9hZDE2ID0gX3NsaWNlZFRvQXJyYXkoX292ZXJsb2FkMTUsIDQpO1xuXG4gICAgICAgIGluZGV4ID0gX292ZXJsb2FkMTZbMF07XG4gICAgICAgIGxlbmd0aCA9IF9vdmVybG9hZDE2WzFdO1xuICAgICAgICBzb3VyY2UgPSBfb3ZlcmxvYWQxNlszXTtcblxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZShuZXcgX3NlbGVjdGlvbi5SYW5nZShpbmRleCwgbGVuZ3RoKSwgc291cmNlKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5TSUxFTlQpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zY3JvbGxJbnRvVmlldyh0aGlzLnNjcm9sbGluZ0NvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRUZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGV4dCh0ZXh0KSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLkFQSTtcblxuICAgICAgdmFyIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkuaW5zZXJ0KHRleHQpO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q29udGVudHMoZGVsdGEsIHNvdXJjZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5VU0VSO1xuXG4gICAgICB2YXIgY2hhbmdlID0gdGhpcy5zY3JvbGwudXBkYXRlKHNvdXJjZSk7IC8vIFdpbGwgdXBkYXRlIHNlbGVjdGlvbiBiZWZvcmUgc2VsZWN0aW9uLnVwZGF0ZSgpIGRvZXMgaWYgdGV4dCBjaGFuZ2VzXG4gICAgICB0aGlzLnNlbGVjdGlvbi51cGRhdGUoc291cmNlKTtcbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlQ29udGVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDb250ZW50cyhkZWx0YSkge1xuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLkFQSTtcblxuICAgICAgcmV0dXJuIG1vZGlmeS5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVsdGEgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoZGVsdGEpO1xuICAgICAgICByZXR1cm4gX3RoaXMxMS5lZGl0b3IuYXBwbHlEZWx0YShkZWx0YSwgc291cmNlKTtcbiAgICAgIH0sIHNvdXJjZSwgdHJ1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFF1aWxsO1xufSgpO1xuXG5RdWlsbC5ERUZBVUxUUyA9IHtcbiAgYm91bmRzOiBudWxsLFxuICBmb3JtYXRzOiBudWxsLFxuICBtb2R1bGVzOiB7fSxcbiAgcGxhY2Vob2xkZXI6ICcnLFxuICByZWFkT25seTogZmFsc2UsXG4gIHNjcm9sbGluZ0NvbnRhaW5lcjogbnVsbCxcbiAgc3RyaWN0OiB0cnVlLFxuICB0aGVtZTogJ2RlZmF1bHQnXG59O1xuUXVpbGwuZXZlbnRzID0gX2VtaXR0ZXI0LmRlZmF1bHQuZXZlbnRzO1xuUXVpbGwuc291cmNlcyA9IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXM7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblF1aWxsLnZlcnNpb24gPSAgZmFsc2UgPyAnZGV2JyA6IFwiMS4zLjdcIjtcblxuUXVpbGwuaW1wb3J0cyA9IHtcbiAgJ2RlbHRhJzogX3F1aWxsRGVsdGEyLmRlZmF1bHQsXG4gICdwYXJjaG1lbnQnOiBfcGFyY2htZW50Mi5kZWZhdWx0LFxuICAnY29yZS9tb2R1bGUnOiBfbW9kdWxlMi5kZWZhdWx0LFxuICAnY29yZS90aGVtZSc6IF90aGVtZTIuZGVmYXVsdFxufTtcblxuZnVuY3Rpb24gZXhwYW5kQ29uZmlnKGNvbnRhaW5lciwgdXNlckNvbmZpZykge1xuICB1c2VyQ29uZmlnID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKHRydWUsIHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBtb2R1bGVzOiB7XG4gICAgICBjbGlwYm9hcmQ6IHRydWUsXG4gICAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICAgIGhpc3Rvcnk6IHRydWVcbiAgICB9XG4gIH0sIHVzZXJDb25maWcpO1xuICBpZiAoIXVzZXJDb25maWcudGhlbWUgfHwgdXNlckNvbmZpZy50aGVtZSA9PT0gUXVpbGwuREVGQVVMVFMudGhlbWUpIHtcbiAgICB1c2VyQ29uZmlnLnRoZW1lID0gX3RoZW1lMi5kZWZhdWx0O1xuICB9IGVsc2Uge1xuICAgIHVzZXJDb25maWcudGhlbWUgPSBRdWlsbC5pbXBvcnQoJ3RoZW1lcy8nICsgdXNlckNvbmZpZy50aGVtZSk7XG4gICAgaWYgKHVzZXJDb25maWcudGhlbWUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRoZW1lICcgKyB1c2VyQ29uZmlnLnRoZW1lICsgJy4gRGlkIHlvdSByZWdpc3RlciBpdD8nKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRoZW1lQ29uZmlnID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKHRydWUsIHt9LCB1c2VyQ29uZmlnLnRoZW1lLkRFRkFVTFRTKTtcbiAgW3RoZW1lQ29uZmlnLCB1c2VyQ29uZmlnXS5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICBjb25maWcubW9kdWxlcyA9IGNvbmZpZy5tb2R1bGVzIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGNvbmZpZy5tb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgIGlmIChjb25maWcubW9kdWxlc1ttb2R1bGVdID09PSB0cnVlKSB7XG4gICAgICAgIGNvbmZpZy5tb2R1bGVzW21vZHVsZV0gPSB7fTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHZhciBtb2R1bGVOYW1lcyA9IE9iamVjdC5rZXlzKHRoZW1lQ29uZmlnLm1vZHVsZXMpLmNvbmNhdChPYmplY3Qua2V5cyh1c2VyQ29uZmlnLm1vZHVsZXMpKTtcbiAgdmFyIG1vZHVsZUNvbmZpZyA9IG1vZHVsZU5hbWVzLnJlZHVjZShmdW5jdGlvbiAoY29uZmlnLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZUNsYXNzID0gUXVpbGwuaW1wb3J0KCdtb2R1bGVzLycgKyBuYW1lKTtcbiAgICBpZiAobW9kdWxlQ2xhc3MgPT0gbnVsbCkge1xuICAgICAgZGVidWcuZXJyb3IoJ0Nhbm5vdCBsb2FkICcgKyBuYW1lICsgJyBtb2R1bGUuIEFyZSB5b3Ugc3VyZSB5b3UgcmVnaXN0ZXJlZCBpdD8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlnW25hbWVdID0gbW9kdWxlQ2xhc3MuREVGQVVMVFMgfHwge307XG4gICAgfVxuICAgIHJldHVybiBjb25maWc7XG4gIH0sIHt9KTtcbiAgLy8gU3BlY2lhbCBjYXNlIHRvb2xiYXIgc2hvcnRoYW5kXG4gIGlmICh1c2VyQ29uZmlnLm1vZHVsZXMgIT0gbnVsbCAmJiB1c2VyQ29uZmlnLm1vZHVsZXMudG9vbGJhciAmJiB1c2VyQ29uZmlnLm1vZHVsZXMudG9vbGJhci5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgdXNlckNvbmZpZy5tb2R1bGVzLnRvb2xiYXIgPSB7XG4gICAgICBjb250YWluZXI6IHVzZXJDb25maWcubW9kdWxlcy50b29sYmFyXG4gICAgfTtcbiAgfVxuICB1c2VyQ29uZmlnID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKHRydWUsIHt9LCBRdWlsbC5ERUZBVUxUUywgeyBtb2R1bGVzOiBtb2R1bGVDb25maWcgfSwgdGhlbWVDb25maWcsIHVzZXJDb25maWcpO1xuICBbJ2JvdW5kcycsICdjb250YWluZXInLCAnc2Nyb2xsaW5nQ29udGFpbmVyJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiB1c2VyQ29uZmlnW2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB1c2VyQ29uZmlnW2tleV0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHVzZXJDb25maWdba2V5XSk7XG4gICAgfVxuICB9KTtcbiAgdXNlckNvbmZpZy5tb2R1bGVzID0gT2JqZWN0LmtleXModXNlckNvbmZpZy5tb2R1bGVzKS5yZWR1Y2UoZnVuY3Rpb24gKGNvbmZpZywgbmFtZSkge1xuICAgIGlmICh1c2VyQ29uZmlnLm1vZHVsZXNbbmFtZV0pIHtcbiAgICAgIGNvbmZpZ1tuYW1lXSA9IHVzZXJDb25maWcubW9kdWxlc1tuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfSwge30pO1xuICByZXR1cm4gdXNlckNvbmZpZztcbn1cblxuLy8gSGFuZGxlIHNlbGVjdGlvbiBwcmVzZXJ2YXRpb24gYW5kIFRFWFRfQ0hBTkdFIGVtaXNzaW9uXG4vLyBjb21tb24gdG8gbW9kaWZpY2F0aW9uIEFQSXNcbmZ1bmN0aW9uIG1vZGlmeShtb2RpZmllciwgc291cmNlLCBpbmRleCwgc2hpZnQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5zdHJpY3QgJiYgIXRoaXMuaXNFbmFibGVkKCkgJiYgc291cmNlID09PSBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlVTRVIpIHtcbiAgICByZXR1cm4gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCk7XG4gIH1cbiAgdmFyIHJhbmdlID0gaW5kZXggPT0gbnVsbCA/IG51bGwgOiB0aGlzLmdldFNlbGVjdGlvbigpO1xuICB2YXIgb2xkRGVsdGEgPSB0aGlzLmVkaXRvci5kZWx0YTtcbiAgdmFyIGNoYW5nZSA9IG1vZGlmaWVyKCk7XG4gIGlmIChyYW5nZSAhPSBudWxsKSB7XG4gICAgaWYgKGluZGV4ID09PSB0cnVlKSBpbmRleCA9IHJhbmdlLmluZGV4O1xuICAgIGlmIChzaGlmdCA9PSBudWxsKSB7XG4gICAgICByYW5nZSA9IHNoaWZ0UmFuZ2UocmFuZ2UsIGNoYW5nZSwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgICByYW5nZSA9IHNoaWZ0UmFuZ2UocmFuZ2UsIGluZGV4LCBzaGlmdCwgc291cmNlKTtcbiAgICB9XG4gICAgdGhpcy5zZXRTZWxlY3Rpb24ocmFuZ2UsIF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgfVxuICBpZiAoY2hhbmdlLmxlbmd0aCgpID4gMCkge1xuICAgIHZhciBfZW1pdHRlcjtcblxuICAgIHZhciBhcmdzID0gW19lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5URVhUX0NIQU5HRSwgY2hhbmdlLCBvbGREZWx0YSwgc291cmNlXTtcbiAgICAoX2VtaXR0ZXIgPSB0aGlzLmVtaXR0ZXIpLmVtaXQuYXBwbHkoX2VtaXR0ZXIsIFtfZW1pdHRlcjQuZGVmYXVsdC5ldmVudHMuRURJVE9SX0NIQU5HRV0uY29uY2F0KGFyZ3MpKTtcbiAgICBpZiAoc291cmNlICE9PSBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCkge1xuICAgICAgdmFyIF9lbWl0dGVyMjtcblxuICAgICAgKF9lbWl0dGVyMiA9IHRoaXMuZW1pdHRlcikuZW1pdC5hcHBseShfZW1pdHRlcjIsIGFyZ3MpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2hhbmdlO1xufVxuXG5mdW5jdGlvbiBvdmVybG9hZChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSwgc291cmNlKSB7XG4gIHZhciBmb3JtYXRzID0ge307XG4gIGlmICh0eXBlb2YgaW5kZXguaW5kZXggPT09ICdudW1iZXInICYmIHR5cGVvZiBpbmRleC5sZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gQWxsb3cgZm9yIHRocm93YXdheSBlbmQgKHVzZWQgYnkgaW5zZXJ0VGV4dC9pbnNlcnRFbWJlZClcbiAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHNvdXJjZSA9IHZhbHVlLCB2YWx1ZSA9IG5hbWUsIG5hbWUgPSBsZW5ndGgsIGxlbmd0aCA9IGluZGV4Lmxlbmd0aCwgaW5kZXggPSBpbmRleC5pbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gaW5kZXgubGVuZ3RoLCBpbmRleCA9IGluZGV4LmluZGV4O1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgIHNvdXJjZSA9IHZhbHVlLCB2YWx1ZSA9IG5hbWUsIG5hbWUgPSBsZW5ndGgsIGxlbmd0aCA9IDA7XG4gIH1cbiAgLy8gSGFuZGxlIGZvcm1hdCBiZWluZyBvYmplY3QsIHR3byBmb3JtYXQgbmFtZS92YWx1ZSBzdHJpbmdzIG9yIGV4Y2x1ZGVkXG4gIGlmICgodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3JtYXRzID0gbmFtZTtcbiAgICBzb3VyY2UgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgZm9ybWF0c1tuYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2UgPSBuYW1lO1xuICAgIH1cbiAgfVxuICAvLyBIYW5kbGUgb3B0aW9uYWwgc291cmNlXG4gIHNvdXJjZSA9IHNvdXJjZSB8fCBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLkFQSTtcbiAgcmV0dXJuIFtpbmRleCwgbGVuZ3RoLCBmb3JtYXRzLCBzb3VyY2VdO1xufVxuXG5mdW5jdGlvbiBzaGlmdFJhbmdlKHJhbmdlLCBpbmRleCwgbGVuZ3RoLCBzb3VyY2UpIHtcbiAgaWYgKHJhbmdlID09IG51bGwpIHJldHVybiBudWxsO1xuICB2YXIgc3RhcnQgPSB2b2lkIDAsXG4gICAgICBlbmQgPSB2b2lkIDA7XG4gIGlmIChpbmRleCBpbnN0YW5jZW9mIF9xdWlsbERlbHRhMi5kZWZhdWx0KSB7XG4gICAgdmFyIF9tYXAgPSBbcmFuZ2UuaW5kZXgsIHJhbmdlLmluZGV4ICsgcmFuZ2UubGVuZ3RoXS5tYXAoZnVuY3Rpb24gKHBvcykge1xuICAgICAgcmV0dXJuIGluZGV4LnRyYW5zZm9ybVBvc2l0aW9uKHBvcywgc291cmNlICE9PSBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9tYXAyID0gX3NsaWNlZFRvQXJyYXkoX21hcCwgMik7XG5cbiAgICBzdGFydCA9IF9tYXAyWzBdO1xuICAgIGVuZCA9IF9tYXAyWzFdO1xuICB9IGVsc2Uge1xuICAgIHZhciBfbWFwMyA9IFtyYW5nZS5pbmRleCwgcmFuZ2UuaW5kZXggKyByYW5nZS5sZW5ndGhdLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICBpZiAocG9zIDwgaW5kZXggfHwgcG9zID09PSBpbmRleCAmJiBzb3VyY2UgPT09IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuVVNFUikgcmV0dXJuIHBvcztcbiAgICAgIGlmIChsZW5ndGggPj0gMCkge1xuICAgICAgICByZXR1cm4gcG9zICsgbGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGluZGV4LCBwb3MgKyBsZW5ndGgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIF9tYXA0ID0gX3NsaWNlZFRvQXJyYXkoX21hcDMsIDIpO1xuXG4gICAgc3RhcnQgPSBfbWFwNFswXTtcbiAgICBlbmQgPSBfbWFwNFsxXTtcbiAgfVxuICByZXR1cm4gbmV3IF9zZWxlY3Rpb24uUmFuZ2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcbn1cblxuZXhwb3J0cy5leHBhbmRDb25maWcgPSBleHBhbmRDb25maWc7XG5leHBvcnRzLm92ZXJsb2FkID0gb3ZlcmxvYWQ7XG5leHBvcnRzLmRlZmF1bHQgPSBRdWlsbDtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF90ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RleHQpO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIElubGluZSA9IGZ1bmN0aW9uIChfUGFyY2htZW50JElubGluZSkge1xuICBfaW5oZXJpdHMoSW5saW5lLCBfUGFyY2htZW50JElubGluZSk7XG5cbiAgZnVuY3Rpb24gSW5saW5lKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmxpbmUpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChJbmxpbmUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbmxpbmUpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbmxpbmUsIFt7XG4gICAga2V5OiAnZm9ybWF0QXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKElubGluZS5jb21wYXJlKHRoaXMuc3RhdGljcy5ibG90TmFtZSwgbmFtZSkgPCAwICYmIF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkobmFtZSwgX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9UKSkge1xuICAgICAgICB2YXIgYmxvdCA9IHRoaXMuaXNvbGF0ZShpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgYmxvdC53cmFwKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dldChJbmxpbmUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSW5saW5lLnByb3RvdHlwZSksICdmb3JtYXRBdCcsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29wdGltaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW1pemUoY29udGV4dCkge1xuICAgICAgX2dldChJbmxpbmUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSW5saW5lLnByb3RvdHlwZSksICdvcHRpbWl6ZScsIHRoaXMpLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBJbmxpbmUgJiYgSW5saW5lLmNvbXBhcmUodGhpcy5zdGF0aWNzLmJsb3ROYW1lLCB0aGlzLnBhcmVudC5zdGF0aWNzLmJsb3ROYW1lKSA+IDApIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Lmlzb2xhdGUodGhpcy5vZmZzZXQoKSwgdGhpcy5sZW5ndGgoKSk7XG4gICAgICAgIHRoaXMubW92ZUNoaWxkcmVuKHBhcmVudCk7XG4gICAgICAgIHBhcmVudC53cmFwKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnY29tcGFyZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmUoc2VsZiwgb3RoZXIpIHtcbiAgICAgIHZhciBzZWxmSW5kZXggPSBJbmxpbmUub3JkZXIuaW5kZXhPZihzZWxmKTtcbiAgICAgIHZhciBvdGhlckluZGV4ID0gSW5saW5lLm9yZGVyLmluZGV4T2Yob3RoZXIpO1xuICAgICAgaWYgKHNlbGZJbmRleCA+PSAwIHx8IG90aGVySW5kZXggPj0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZkluZGV4IC0gb3RoZXJJbmRleDtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZiA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYgPCBvdGhlcikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW5saW5lO1xufShfcGFyY2htZW50Mi5kZWZhdWx0LklubGluZSk7XG5cbklubGluZS5hbGxvd2VkQ2hpbGRyZW4gPSBbSW5saW5lLCBfcGFyY2htZW50Mi5kZWZhdWx0LkVtYmVkLCBfdGV4dDIuZGVmYXVsdF07XG4vLyBMb3dlciBpbmRleCBtZWFucyBkZWVwZXIgaW4gdGhlIERPTSB0cmVlLCBzaW5jZSBub3QgZm91bmQgKC0xKSBpcyBmb3IgZW1iZWRzXG5JbmxpbmUub3JkZXIgPSBbJ2N1cnNvcicsICdpbmxpbmUnLCAvLyBNdXN0IGJlIGxvd2VyXG4ndW5kZXJsaW5lJywgJ3N0cmlrZScsICdpdGFsaWMnLCAnYm9sZCcsICdzY3JpcHQnLCAnbGluaycsICdjb2RlJyAvLyBNdXN0IGJlIGhpZ2hlclxuXTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSW5saW5lO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBUZXh0QmxvdCA9IGZ1bmN0aW9uIChfUGFyY2htZW50JFRleHQpIHtcbiAgX2luaGVyaXRzKFRleHRCbG90LCBfUGFyY2htZW50JFRleHQpO1xuXG4gIGZ1bmN0aW9uIFRleHRCbG90KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0QmxvdCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFRleHRCbG90Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGV4dEJsb3QpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBUZXh0QmxvdDtcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5UZXh0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVGV4dEJsb3Q7XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfZXZlbnRlbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCk7XG5cbnZhciBfZXZlbnRlbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50ZW1pdHRlcik7XG5cbnZhciBfbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBfbG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZ2dlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGRlYnVnID0gKDAsIF9sb2dnZXIyLmRlZmF1bHQpKCdxdWlsbDpldmVudHMnKTtcblxudmFyIEVWRU5UUyA9IFsnc2VsZWN0aW9uY2hhbmdlJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ2NsaWNrJ107XG5cbkVWRU5UUy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5xbC1jb250YWluZXInKSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgLy8gVE9ETyB1c2UgV2Vha01hcFxuICAgICAgaWYgKG5vZGUuX19xdWlsbCAmJiBub2RlLl9fcXVpbGwuZW1pdHRlcikge1xuICAgICAgICB2YXIgX25vZGUkX19xdWlsbCRlbWl0dGVyO1xuXG4gICAgICAgIChfbm9kZSRfX3F1aWxsJGVtaXR0ZXIgPSBub2RlLl9fcXVpbGwuZW1pdHRlcikuaGFuZGxlRE9NLmFwcGx5KF9ub2RlJF9fcXVpbGwkZW1pdHRlciwgYXJncyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbnZhciBFbWl0dGVyID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKEVtaXR0ZXIsIF9FdmVudEVtaXR0ZXIpO1xuXG4gIGZ1bmN0aW9uIEVtaXR0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVtaXR0ZXIpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEVtaXR0ZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihFbWl0dGVyKSkuY2FsbCh0aGlzKSk7XG5cbiAgICBfdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICBfdGhpcy5vbignZXJyb3InLCBkZWJ1Zy5lcnJvcik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVtaXR0ZXIsIFt7XG4gICAga2V5OiAnZW1pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXQoKSB7XG4gICAgICBkZWJ1Zy5sb2cuYXBwbHkoZGVidWcsIGFyZ3VtZW50cyk7XG4gICAgICBfZ2V0KEVtaXR0ZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRW1pdHRlci5wcm90b3R5cGUpLCAnZW1pdCcsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlRE9NJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRE9NKGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgICh0aGlzLmxpc3RlbmVyc1tldmVudC50eXBlXSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgbm9kZSA9IF9yZWYubm9kZSxcbiAgICAgICAgICAgIGhhbmRsZXIgPSBfcmVmLmhhbmRsZXI7XG5cbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gbm9kZSB8fCBub2RlLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICBoYW5kbGVyLmFwcGx5KHVuZGVmaW5lZCwgW2V2ZW50XS5jb25jYXQoYXJncykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsaXN0ZW5ET00nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW5ET00oZXZlbnROYW1lLCBub2RlLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIXRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXS5wdXNoKHsgbm9kZTogbm9kZSwgaGFuZGxlcjogaGFuZGxlciB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRW1pdHRlcjtcbn0oX2V2ZW50ZW1pdHRlcjIuZGVmYXVsdCk7XG5cbkVtaXR0ZXIuZXZlbnRzID0ge1xuICBFRElUT1JfQ0hBTkdFOiAnZWRpdG9yLWNoYW5nZScsXG4gIFNDUk9MTF9CRUZPUkVfVVBEQVRFOiAnc2Nyb2xsLWJlZm9yZS11cGRhdGUnLFxuICBTQ1JPTExfT1BUSU1JWkU6ICdzY3JvbGwtb3B0aW1pemUnLFxuICBTQ1JPTExfVVBEQVRFOiAnc2Nyb2xsLXVwZGF0ZScsXG4gIFNFTEVDVElPTl9DSEFOR0U6ICdzZWxlY3Rpb24tY2hhbmdlJyxcbiAgVEVYVF9DSEFOR0U6ICd0ZXh0LWNoYW5nZSdcbn07XG5FbWl0dGVyLnNvdXJjZXMgPSB7XG4gIEFQSTogJ2FwaScsXG4gIFNJTEVOVDogJ3NpbGVudCcsXG4gIFVTRVI6ICd1c2VyJ1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRW1pdHRlcjtcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBNb2R1bGUgPSBmdW5jdGlvbiBNb2R1bGUocXVpbGwpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2R1bGUpO1xuXG4gIHRoaXMucXVpbGwgPSBxdWlsbDtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbn07XG5cbk1vZHVsZS5ERUZBVUxUUyA9IHt9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNb2R1bGU7XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBsZXZlbHMgPSBbJ2Vycm9yJywgJ3dhcm4nLCAnbG9nJywgJ2luZm8nXTtcbnZhciBsZXZlbCA9ICd3YXJuJztcblxuZnVuY3Rpb24gZGVidWcobWV0aG9kKSB7XG4gIGlmIChsZXZlbHMuaW5kZXhPZihtZXRob2QpIDw9IGxldmVscy5pbmRleE9mKGxldmVsKSkge1xuICAgIHZhciBfY29uc29sZTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgKF9jb25zb2xlID0gY29uc29sZSlbbWV0aG9kXS5hcHBseShfY29uc29sZSwgYXJncyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICB9XG59XG5cbmZ1bmN0aW9uIG5hbWVzcGFjZShucykge1xuICByZXR1cm4gbGV2ZWxzLnJlZHVjZShmdW5jdGlvbiAobG9nZ2VyLCBtZXRob2QpIHtcbiAgICBsb2dnZXJbbWV0aG9kXSA9IGRlYnVnLmJpbmQoY29uc29sZSwgbWV0aG9kLCBucyk7XG4gICAgcmV0dXJuIGxvZ2dlcjtcbiAgfSwge30pO1xufVxuXG5kZWJ1Zy5sZXZlbCA9IG5hbWVzcGFjZS5sZXZlbCA9IGZ1bmN0aW9uIChuZXdMZXZlbCkge1xuICBsZXZlbCA9IG5ld0xldmVsO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gbmFtZXNwYWNlO1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgb2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xudmFyIGlzQXJndW1lbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQgfHwgdHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzKSB7XG4gIHZhciBpLCBrZXk7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgb3B0cyk7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKGEpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG9wdHMpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYjtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIEF0dHJpYnV0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXR0cmlidXRvcihhdHRyTmFtZSwga2V5TmFtZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB0aGlzLmF0dHJOYW1lID0gYXR0ck5hbWU7XG4gICAgICAgIHRoaXMua2V5TmFtZSA9IGtleU5hbWU7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVCaXQgPSBSZWdpc3RyeS5TY29wZS5UWVBFICYgUmVnaXN0cnkuU2NvcGUuQVRUUklCVVRFO1xuICAgICAgICBpZiAob3B0aW9ucy5zY29wZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgdHlwZSBiaXRzLCBmb3JjZSBhdHRyaWJ1dGUgYml0XG4gICAgICAgICAgICB0aGlzLnNjb3BlID0gKG9wdGlvbnMuc2NvcGUgJiBSZWdpc3RyeS5TY29wZS5MRVZFTCkgfCBhdHRyaWJ1dGVCaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjb3BlID0gUmVnaXN0cnkuU2NvcGUuQVRUUklCVVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLndoaXRlbGlzdCAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy53aGl0ZWxpc3QgPSBvcHRpb25zLndoaXRlbGlzdDtcbiAgICB9XG4gICAgQXR0cmlidXRvci5rZXlzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtdLm1hcC5jYWxsKG5vZGUuYXR0cmlidXRlcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLm5hbWU7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXR0cmlidXRvci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW5BZGQobm9kZSwgdmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSh0aGlzLmtleU5hbWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBBdHRyaWJ1dG9yLnByb3RvdHlwZS5jYW5BZGQgPSBmdW5jdGlvbiAobm9kZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gUmVnaXN0cnkucXVlcnkobm9kZSwgUmVnaXN0cnkuU2NvcGUuQkxPVCAmICh0aGlzLnNjb3BlIHwgUmVnaXN0cnkuU2NvcGUuVFlQRSkpO1xuICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMud2hpdGVsaXN0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndoaXRlbGlzdC5pbmRleE9mKHZhbHVlLnJlcGxhY2UoL1tcIiddL2csICcnKSkgPiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndoaXRlbGlzdC5pbmRleE9mKHZhbHVlKSA+IC0xO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdHRyaWJ1dG9yLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmtleU5hbWUpO1xuICAgIH07XG4gICAgQXR0cmlidXRvci5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZSh0aGlzLmtleU5hbWUpO1xuICAgICAgICBpZiAodGhpcy5jYW5BZGQobm9kZSwgdmFsdWUpICYmIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH07XG4gICAgcmV0dXJuIEF0dHJpYnV0b3I7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXR0cmlidXRvcjtcblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLkNvZGUgPSB1bmRlZmluZWQ7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3F1aWxsRGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX3F1aWxsRGVsdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGxEZWx0YSk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9ibG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfYmxvY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmxvY2spO1xuXG52YXIgX2lubGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfaW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lubGluZSk7XG5cbnZhciBfdGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZXh0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ29kZSA9IGZ1bmN0aW9uIChfSW5saW5lKSB7XG4gIF9pbmhlcml0cyhDb2RlLCBfSW5saW5lKTtcblxuICBmdW5jdGlvbiBDb2RlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2RlKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ29kZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvZGUpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBDb2RlO1xufShfaW5saW5lMi5kZWZhdWx0KTtcblxuQ29kZS5ibG90TmFtZSA9ICdjb2RlJztcbkNvZGUudGFnTmFtZSA9ICdDT0RFJztcblxudmFyIENvZGVCbG9jayA9IGZ1bmN0aW9uIChfQmxvY2spIHtcbiAgX2luaGVyaXRzKENvZGVCbG9jaywgX0Jsb2NrKTtcblxuICBmdW5jdGlvbiBDb2RlQmxvY2soKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvZGVCbG9jayk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvZGVCbG9jay5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvZGVCbG9jaykpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvZGVCbG9jaywgW3tcbiAgICBrZXk6ICdkZWx0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbHRhKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciB0ZXh0ID0gdGhpcy5kb21Ob2RlLnRleHRDb250ZW50O1xuICAgICAgaWYgKHRleHQuZW5kc1dpdGgoJ1xcbicpKSB7XG4gICAgICAgIC8vIFNob3VsZCBhbHdheXMgYmUgdHJ1ZVxuICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dC5zcGxpdCgnXFxuJykucmVkdWNlKGZ1bmN0aW9uIChkZWx0YSwgZnJhZykge1xuICAgICAgICByZXR1cm4gZGVsdGEuaW5zZXJ0KGZyYWcpLmluc2VydCgnXFxuJywgX3RoaXMzLmZvcm1hdHMoKSk7XG4gICAgICB9LCBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAobmFtZSA9PT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lICYmIHZhbHVlKSByZXR1cm47XG5cbiAgICAgIHZhciBfZGVzY2VuZGFudCA9IHRoaXMuZGVzY2VuZGFudChfdGV4dDIuZGVmYXVsdCwgdGhpcy5sZW5ndGgoKSAtIDEpLFxuICAgICAgICAgIF9kZXNjZW5kYW50MiA9IF9zbGljZWRUb0FycmF5KF9kZXNjZW5kYW50LCAxKSxcbiAgICAgICAgICB0ZXh0ID0gX2Rlc2NlbmRhbnQyWzBdO1xuXG4gICAgICBpZiAodGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHRleHQuZGVsZXRlQXQodGV4dC5sZW5ndGgoKSAtIDEsIDEpO1xuICAgICAgfVxuICAgICAgX2dldChDb2RlQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29kZUJsb2NrLnByb3RvdHlwZSksICdmb3JtYXQnLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICBpZiAoX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShuYW1lLCBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLKSA9PSBudWxsIHx8IG5hbWUgPT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSAmJiB2YWx1ZSA9PT0gdGhpcy5zdGF0aWNzLmZvcm1hdHModGhpcy5kb21Ob2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmV4dE5ld2xpbmUgPSB0aGlzLm5ld2xpbmVJbmRleChpbmRleCk7XG4gICAgICBpZiAobmV4dE5ld2xpbmUgPCAwIHx8IG5leHROZXdsaW5lID49IGluZGV4ICsgbGVuZ3RoKSByZXR1cm47XG4gICAgICB2YXIgcHJldk5ld2xpbmUgPSB0aGlzLm5ld2xpbmVJbmRleChpbmRleCwgdHJ1ZSkgKyAxO1xuICAgICAgdmFyIGlzb2xhdGVMZW5ndGggPSBuZXh0TmV3bGluZSAtIHByZXZOZXdsaW5lICsgMTtcbiAgICAgIHZhciBibG90ID0gdGhpcy5pc29sYXRlKHByZXZOZXdsaW5lLCBpc29sYXRlTGVuZ3RoKTtcbiAgICAgIHZhciBuZXh0ID0gYmxvdC5uZXh0O1xuICAgICAgYmxvdC5mb3JtYXQobmFtZSwgdmFsdWUpO1xuICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBDb2RlQmxvY2spIHtcbiAgICAgICAgbmV4dC5mb3JtYXRBdCgwLCBpbmRleCAtIHByZXZOZXdsaW5lICsgbGVuZ3RoIC0gaXNvbGF0ZUxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydEF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QXQoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICAgIGlmIChkZWYgIT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICB2YXIgX2Rlc2NlbmRhbnQzID0gdGhpcy5kZXNjZW5kYW50KF90ZXh0Mi5kZWZhdWx0LCBpbmRleCksXG4gICAgICAgICAgX2Rlc2NlbmRhbnQ0ID0gX3NsaWNlZFRvQXJyYXkoX2Rlc2NlbmRhbnQzLCAyKSxcbiAgICAgICAgICB0ZXh0ID0gX2Rlc2NlbmRhbnQ0WzBdLFxuICAgICAgICAgIG9mZnNldCA9IF9kZXNjZW5kYW50NFsxXTtcblxuICAgICAgdGV4dC5pbnNlcnRBdChvZmZzZXQsIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsZW5ndGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy5kb21Ob2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgIGlmICghdGhpcy5kb21Ob2RlLnRleHRDb250ZW50LmVuZHNXaXRoKCdcXG4nKSkge1xuICAgICAgICByZXR1cm4gbGVuZ3RoICsgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbmV3bGluZUluZGV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV3bGluZUluZGV4KHNlYXJjaEluZGV4KSB7XG4gICAgICB2YXIgcmV2ZXJzZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgIGlmICghcmV2ZXJzZSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5kb21Ob2RlLnRleHRDb250ZW50LnNsaWNlKHNlYXJjaEluZGV4KS5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA+IC0xID8gc2VhcmNoSW5kZXggKyBvZmZzZXQgOiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbU5vZGUudGV4dENvbnRlbnQuc2xpY2UoMCwgc2VhcmNoSW5kZXgpLmxhc3RJbmRleE9mKCdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvcHRpbWl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKGNvbnRleHQpIHtcbiAgICAgIGlmICghdGhpcy5kb21Ob2RlLnRleHRDb250ZW50LmVuZHNXaXRoKCdcXG4nKSkge1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKCd0ZXh0JywgJ1xcbicpKTtcbiAgICAgIH1cbiAgICAgIF9nZXQoQ29kZUJsb2NrLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvZGVCbG9jay5wcm90b3R5cGUpLCAnb3B0aW1pemUnLCB0aGlzKS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgdmFyIG5leHQgPSB0aGlzLm5leHQ7XG4gICAgICBpZiAobmV4dCAhPSBudWxsICYmIG5leHQucHJldiA9PT0gdGhpcyAmJiBuZXh0LnN0YXRpY3MuYmxvdE5hbWUgPT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSAmJiB0aGlzLnN0YXRpY3MuZm9ybWF0cyh0aGlzLmRvbU5vZGUpID09PSBuZXh0LnN0YXRpY3MuZm9ybWF0cyhuZXh0LmRvbU5vZGUpKSB7XG4gICAgICAgIG5leHQub3B0aW1pemUoY29udGV4dCk7XG4gICAgICAgIG5leHQubW92ZUNoaWxkcmVuKHRoaXMpO1xuICAgICAgICBuZXh0LnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlcGxhY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKHRhcmdldCkge1xuICAgICAgX2dldChDb2RlQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29kZUJsb2NrLnByb3RvdHlwZSksICdyZXBsYWNlJywgdGhpcykuY2FsbCh0aGlzLCB0YXJnZXQpO1xuICAgICAgW10uc2xpY2UuY2FsbCh0aGlzLmRvbU5vZGUucXVlcnlTZWxlY3RvckFsbCgnKicpKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBibG90ID0gX3BhcmNobWVudDIuZGVmYXVsdC5maW5kKG5vZGUpO1xuICAgICAgICBpZiAoYmxvdCA9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGJsb3QgaW5zdGFuY2VvZiBfcGFyY2htZW50Mi5kZWZhdWx0LkVtYmVkKSB7XG4gICAgICAgICAgYmxvdC5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibG90LnVud3JhcCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgdmFyIGRvbU5vZGUgPSBfZ2V0KENvZGVCbG9jay5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvZGVCbG9jayksICdjcmVhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgIGRvbU5vZGUuc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgZmFsc2UpO1xuICAgICAgcmV0dXJuIGRvbU5vZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29kZUJsb2NrO1xufShfYmxvY2syLmRlZmF1bHQpO1xuXG5Db2RlQmxvY2suYmxvdE5hbWUgPSAnY29kZS1ibG9jayc7XG5Db2RlQmxvY2sudGFnTmFtZSA9ICdQUkUnO1xuQ29kZUJsb2NrLlRBQiA9ICcgICc7XG5cbmV4cG9ydHMuQ29kZSA9IENvZGU7XG5leHBvcnRzLmRlZmF1bHQgPSBDb2RlQmxvY2s7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcXVpbGxEZWx0YSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfcXVpbGxEZWx0YTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbERlbHRhKTtcblxudmFyIF9vcCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG52YXIgX29wMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29wKTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX2NvZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIF9jb2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvZGUpO1xuXG52YXIgX2N1cnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG52YXIgX2N1cnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jdXJzb3IpO1xuXG52YXIgX2Jsb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9ibG9jazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ibG9jayk7XG5cbnZhciBfYnJlYWsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIF9icmVhazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9icmVhayk7XG5cbnZhciBfY2xvbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblxudmFyIF9jbG9uZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9uZSk7XG5cbnZhciBfZGVlcEVxdWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBfZGVlcEVxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZXBFcXVhbCk7XG5cbnZhciBfZXh0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9leHRlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXh0ZW5kKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEFTQ0lJID0gL15bIC1+XSokLztcblxudmFyIEVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRWRpdG9yKHNjcm9sbCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGl0b3IpO1xuXG4gICAgdGhpcy5zY3JvbGwgPSBzY3JvbGw7XG4gICAgdGhpcy5kZWx0YSA9IHRoaXMuZ2V0RGVsdGEoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFZGl0b3IsIFt7XG4gICAga2V5OiAnYXBwbHlEZWx0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5RGVsdGEoZGVsdGEpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBjb25zdW1lTmV4dE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2Nyb2xsLnVwZGF0ZSgpO1xuICAgICAgdmFyIHNjcm9sbExlbmd0aCA9IHRoaXMuc2Nyb2xsLmxlbmd0aCgpO1xuICAgICAgdGhpcy5zY3JvbGwuYmF0Y2hTdGFydCgpO1xuICAgICAgZGVsdGEgPSBub3JtYWxpemVEZWx0YShkZWx0YSk7XG4gICAgICBkZWx0YS5yZWR1Y2UoZnVuY3Rpb24gKGluZGV4LCBvcCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gb3AucmV0YWluIHx8IG9wLmRlbGV0ZSB8fCBvcC5pbnNlcnQubGVuZ3RoIHx8IDE7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gb3AuYXR0cmlidXRlcyB8fCB7fTtcbiAgICAgICAgaWYgKG9wLmluc2VydCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcC5pbnNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IG9wLmluc2VydDtcbiAgICAgICAgICAgIGlmICh0ZXh0LmVuZHNXaXRoKCdcXG4nKSAmJiBjb25zdW1lTmV4dE5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgY29uc3VtZU5leHROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCA+PSBzY3JvbGxMZW5ndGggJiYgIXRleHQuZW5kc1dpdGgoJ1xcbicpKSB7XG4gICAgICAgICAgICAgIGNvbnN1bWVOZXh0TmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5zY3JvbGwuaW5zZXJ0QXQoaW5kZXgsIHRleHQpO1xuXG4gICAgICAgICAgICB2YXIgX3Njcm9sbCRsaW5lID0gX3RoaXMuc2Nyb2xsLmxpbmUoaW5kZXgpLFxuICAgICAgICAgICAgICAgIF9zY3JvbGwkbGluZTIgPSBfc2xpY2VkVG9BcnJheShfc2Nyb2xsJGxpbmUsIDIpLFxuICAgICAgICAgICAgICAgIGxpbmUgPSBfc2Nyb2xsJGxpbmUyWzBdLFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IF9zY3JvbGwkbGluZTJbMV07XG5cbiAgICAgICAgICAgIHZhciBmb3JtYXRzID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKHt9LCAoMCwgX2Jsb2NrLmJ1YmJsZUZvcm1hdHMpKGxpbmUpKTtcbiAgICAgICAgICAgIGlmIChsaW5lIGluc3RhbmNlb2YgX2Jsb2NrMi5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgIHZhciBfbGluZSRkZXNjZW5kYW50ID0gbGluZS5kZXNjZW5kYW50KF9wYXJjaG1lbnQyLmRlZmF1bHQuTGVhZiwgb2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgIF9saW5lJGRlc2NlbmRhbnQyID0gX3NsaWNlZFRvQXJyYXkoX2xpbmUkZGVzY2VuZGFudCwgMSksXG4gICAgICAgICAgICAgICAgICBsZWFmID0gX2xpbmUkZGVzY2VuZGFudDJbMF07XG5cbiAgICAgICAgICAgICAgZm9ybWF0cyA9ICgwLCBfZXh0ZW5kMi5kZWZhdWx0KShmb3JtYXRzLCAoMCwgX2Jsb2NrLmJ1YmJsZUZvcm1hdHMpKGxlYWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBfb3AyLmRlZmF1bHQuYXR0cmlidXRlcy5kaWZmKGZvcm1hdHMsIGF0dHJpYnV0ZXMpIHx8IHt9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihvcC5pbnNlcnQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFyIGtleSA9IE9iamVjdC5rZXlzKG9wLmluc2VydClbMF07IC8vIFRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSBrZXlcbiAgICAgICAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgX3RoaXMuc2Nyb2xsLmluc2VydEF0KGluZGV4LCBrZXksIG9wLmluc2VydFtrZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2Nyb2xsTGVuZ3RoICs9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgX3RoaXMuc2Nyb2xsLmZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIG5hbWUsIGF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGluZGV4ICsgbGVuZ3RoO1xuICAgICAgfSwgMCk7XG4gICAgICBkZWx0YS5yZWR1Y2UoZnVuY3Rpb24gKGluZGV4LCBvcCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wLmRlbGV0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBfdGhpcy5zY3JvbGwuZGVsZXRlQXQoaW5kZXgsIG9wLmRlbGV0ZSk7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleCArIChvcC5yZXRhaW4gfHwgb3AuaW5zZXJ0Lmxlbmd0aCB8fCAxKTtcbiAgICAgIH0sIDApO1xuICAgICAgdGhpcy5zY3JvbGwuYmF0Y2hFbmQoKTtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShkZWx0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVsZXRlVGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVRleHQoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgdGhpcy5zY3JvbGwuZGVsZXRlQXQoaW5kZXgsIGxlbmd0aCk7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUobmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKGluZGV4KS5kZWxldGUobGVuZ3RoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0TGluZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdExpbmUoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3JtYXRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgdGhpcy5zY3JvbGwudXBkYXRlKCk7XG4gICAgICBPYmplY3Qua2V5cyhmb3JtYXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgaWYgKF90aGlzMi5zY3JvbGwud2hpdGVsaXN0ICE9IG51bGwgJiYgIV90aGlzMi5zY3JvbGwud2hpdGVsaXN0W2Zvcm1hdF0pIHJldHVybjtcbiAgICAgICAgdmFyIGxpbmVzID0gX3RoaXMyLnNjcm9sbC5saW5lcyhpbmRleCwgTWF0aC5tYXgobGVuZ3RoLCAxKSk7XG4gICAgICAgIHZhciBsZW5ndGhSZW1haW5pbmcgPSBsZW5ndGg7XG4gICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICB2YXIgbGluZUxlbmd0aCA9IGxpbmUubGVuZ3RoKCk7XG4gICAgICAgICAgaWYgKCEobGluZSBpbnN0YW5jZW9mIF9jb2RlMi5kZWZhdWx0KSkge1xuICAgICAgICAgICAgbGluZS5mb3JtYXQoZm9ybWF0LCBmb3JtYXRzW2Zvcm1hdF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29kZUluZGV4ID0gaW5kZXggLSBsaW5lLm9mZnNldChfdGhpczIuc2Nyb2xsKTtcbiAgICAgICAgICAgIHZhciBjb2RlTGVuZ3RoID0gbGluZS5uZXdsaW5lSW5kZXgoY29kZUluZGV4ICsgbGVuZ3RoUmVtYWluaW5nKSAtIGNvZGVJbmRleCArIDE7XG4gICAgICAgICAgICBsaW5lLmZvcm1hdEF0KGNvZGVJbmRleCwgY29kZUxlbmd0aCwgZm9ybWF0LCBmb3JtYXRzW2Zvcm1hdF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGhSZW1haW5pbmcgLT0gbGluZUxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2Nyb2xsLm9wdGltaXplKCk7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUobmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKGluZGV4KS5yZXRhaW4obGVuZ3RoLCAoMCwgX2Nsb25lMi5kZWZhdWx0KShmb3JtYXRzKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdFRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRUZXh0KGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgZm9ybWF0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIE9iamVjdC5rZXlzKGZvcm1hdHMpLmZvckVhY2goZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICBfdGhpczMuc2Nyb2xsLmZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIGZvcm1hdCwgZm9ybWF0c1tmb3JtYXRdKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihpbmRleCkucmV0YWluKGxlbmd0aCwgKDAsIF9jbG9uZTIuZGVmYXVsdCkoZm9ybWF0cykpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDb250ZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRlbnRzKGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbHRhLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0RGVsdGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWx0YSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbC5saW5lcygpLnJlZHVjZShmdW5jdGlvbiAoZGVsdGEsIGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGRlbHRhLmNvbmNhdChsaW5lLmRlbHRhKCkpO1xuICAgICAgfSwgbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEZvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvcm1hdChpbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICAgICAgdmFyIGxpbmVzID0gW10sXG4gICAgICAgICAgbGVhdmVzID0gW107XG4gICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsLnBhdGgoaW5kZXgpLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICB2YXIgX3BhdGggPSBfc2xpY2VkVG9BcnJheShwYXRoLCAxKSxcbiAgICAgICAgICAgICAgYmxvdCA9IF9wYXRoWzBdO1xuXG4gICAgICAgICAgaWYgKGJsb3QgaW5zdGFuY2VvZiBfYmxvY2syLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goYmxvdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChibG90IGluc3RhbmNlb2YgX3BhcmNobWVudDIuZGVmYXVsdC5MZWFmKSB7XG4gICAgICAgICAgICBsZWF2ZXMucHVzaChibG90KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZXMgPSB0aGlzLnNjcm9sbC5saW5lcyhpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgbGVhdmVzID0gdGhpcy5zY3JvbGwuZGVzY2VuZGFudHMoX3BhcmNobWVudDIuZGVmYXVsdC5MZWFmLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHZhciBmb3JtYXRzQXJyID0gW2xpbmVzLCBsZWF2ZXNdLm1hcChmdW5jdGlvbiAoYmxvdHMpIHtcbiAgICAgICAgaWYgKGJsb3RzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHt9O1xuICAgICAgICB2YXIgZm9ybWF0cyA9ICgwLCBfYmxvY2suYnViYmxlRm9ybWF0cykoYmxvdHMuc2hpZnQoKSk7XG4gICAgICAgIHdoaWxlIChPYmplY3Qua2V5cyhmb3JtYXRzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGJsb3QgPSBibG90cy5zaGlmdCgpO1xuICAgICAgICAgIGlmIChibG90ID09IG51bGwpIHJldHVybiBmb3JtYXRzO1xuICAgICAgICAgIGZvcm1hdHMgPSBjb21iaW5lRm9ybWF0cygoMCwgX2Jsb2NrLmJ1YmJsZUZvcm1hdHMpKGJsb3QpLCBmb3JtYXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0cztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9leHRlbmQyLmRlZmF1bHQuYXBwbHkoX2V4dGVuZDIuZGVmYXVsdCwgZm9ybWF0c0Fycik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRleHQoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29udGVudHMoaW5kZXgsIGxlbmd0aCkuZmlsdGVyKGZ1bmN0aW9uIChvcCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9wLmluc2VydCA9PT0gJ3N0cmluZyc7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgIHJldHVybiBvcC5pbnNlcnQ7XG4gICAgICB9KS5qb2luKCcnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnNlcnRFbWJlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEVtYmVkKGluZGV4LCBlbWJlZCwgdmFsdWUpIHtcbiAgICAgIHRoaXMuc2Nyb2xsLmluc2VydEF0KGluZGV4LCBlbWJlZCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihpbmRleCkuaW5zZXJ0KF9kZWZpbmVQcm9wZXJ0eSh7fSwgZW1iZWQsIHZhbHVlKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydFRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRUZXh0KGluZGV4LCB0ZXh0KSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIGZvcm1hdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxuJyk7XG4gICAgICB0aGlzLnNjcm9sbC5pbnNlcnRBdChpbmRleCwgdGV4dCk7XG4gICAgICBPYmplY3Qua2V5cyhmb3JtYXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgX3RoaXM0LnNjcm9sbC5mb3JtYXRBdChpbmRleCwgdGV4dC5sZW5ndGgsIGZvcm1hdCwgZm9ybWF0c1tmb3JtYXRdKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihpbmRleCkuaW5zZXJ0KHRleHQsICgwLCBfY2xvbmUyLmRlZmF1bHQpKGZvcm1hdHMpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXNCbGFuaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQmxhbmsoKSB7XG4gICAgICBpZiAodGhpcy5zY3JvbGwuY2hpbGRyZW4ubGVuZ3RoID09IDApIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMuc2Nyb2xsLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBibG9jayA9IHRoaXMuc2Nyb2xsLmNoaWxkcmVuLmhlYWQ7XG4gICAgICBpZiAoYmxvY2suc3RhdGljcy5ibG90TmFtZSAhPT0gX2Jsb2NrMi5kZWZhdWx0LmJsb3ROYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoYmxvY2suY2hpbGRyZW4ubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIGJsb2NrLmNoaWxkcmVuLmhlYWQgaW5zdGFuY2VvZiBfYnJlYWsyLmRlZmF1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlRm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRm9ybWF0KGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRUZXh0KGluZGV4LCBsZW5ndGgpO1xuXG4gICAgICB2YXIgX3Njcm9sbCRsaW5lMyA9IHRoaXMuc2Nyb2xsLmxpbmUoaW5kZXggKyBsZW5ndGgpLFxuICAgICAgICAgIF9zY3JvbGwkbGluZTQgPSBfc2xpY2VkVG9BcnJheShfc2Nyb2xsJGxpbmUzLCAyKSxcbiAgICAgICAgICBsaW5lID0gX3Njcm9sbCRsaW5lNFswXSxcbiAgICAgICAgICBvZmZzZXQgPSBfc2Nyb2xsJGxpbmU0WzFdO1xuXG4gICAgICB2YXIgc3VmZml4TGVuZ3RoID0gMCxcbiAgICAgICAgICBzdWZmaXggPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKTtcbiAgICAgIGlmIChsaW5lICE9IG51bGwpIHtcbiAgICAgICAgaWYgKCEobGluZSBpbnN0YW5jZW9mIF9jb2RlMi5kZWZhdWx0KSkge1xuICAgICAgICAgIHN1ZmZpeExlbmd0aCA9IGxpbmUubGVuZ3RoKCkgLSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VmZml4TGVuZ3RoID0gbGluZS5uZXdsaW5lSW5kZXgob2Zmc2V0KSAtIG9mZnNldCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgc3VmZml4ID0gbGluZS5kZWx0YSgpLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3VmZml4TGVuZ3RoIC0gMSkuaW5zZXJ0KCdcXG4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb250ZW50cyA9IHRoaXMuZ2V0Q29udGVudHMoaW5kZXgsIGxlbmd0aCArIHN1ZmZpeExlbmd0aCk7XG4gICAgICB2YXIgZGlmZiA9IGNvbnRlbnRzLmRpZmYobmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkuaW5zZXJ0KHRleHQpLmNvbmNhdChzdWZmaXgpKTtcbiAgICAgIHZhciBkZWx0YSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihpbmRleCkuY29uY2F0KGRpZmYpO1xuICAgICAgcmV0dXJuIHRoaXMuYXBwbHlEZWx0YShkZWx0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGNoYW5nZSkge1xuICAgICAgdmFyIG11dGF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICB2YXIgY3Vyc29ySW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIG9sZERlbHRhID0gdGhpcy5kZWx0YTtcbiAgICAgIGlmIChtdXRhdGlvbnMubGVuZ3RoID09PSAxICYmIG11dGF0aW9uc1swXS50eXBlID09PSAnY2hhcmFjdGVyRGF0YScgJiYgbXV0YXRpb25zWzBdLnRhcmdldC5kYXRhLm1hdGNoKEFTQ0lJKSAmJiBfcGFyY2htZW50Mi5kZWZhdWx0LmZpbmQobXV0YXRpb25zWzBdLnRhcmdldCkpIHtcbiAgICAgICAgLy8gT3B0aW1pemF0aW9uIGZvciBjaGFyYWN0ZXIgY2hhbmdlc1xuICAgICAgICB2YXIgdGV4dEJsb3QgPSBfcGFyY2htZW50Mi5kZWZhdWx0LmZpbmQobXV0YXRpb25zWzBdLnRhcmdldCk7XG4gICAgICAgIHZhciBmb3JtYXRzID0gKDAsIF9ibG9jay5idWJibGVGb3JtYXRzKSh0ZXh0QmxvdCk7XG4gICAgICAgIHZhciBpbmRleCA9IHRleHRCbG90Lm9mZnNldCh0aGlzLnNjcm9sbCk7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IG11dGF0aW9uc1swXS5vbGRWYWx1ZS5yZXBsYWNlKF9jdXJzb3IyLmRlZmF1bHQuQ09OVEVOVFMsICcnKTtcbiAgICAgICAgdmFyIG9sZFRleHQgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5pbnNlcnQob2xkVmFsdWUpO1xuICAgICAgICB2YXIgbmV3VGV4dCA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLmluc2VydCh0ZXh0QmxvdC52YWx1ZSgpKTtcbiAgICAgICAgdmFyIGRpZmZEZWx0YSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihpbmRleCkuY29uY2F0KG9sZFRleHQuZGlmZihuZXdUZXh0LCBjdXJzb3JJbmRleCkpO1xuICAgICAgICBjaGFuZ2UgPSBkaWZmRGVsdGEucmVkdWNlKGZ1bmN0aW9uIChkZWx0YSwgb3ApIHtcbiAgICAgICAgICBpZiAob3AuaW5zZXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsdGEuaW5zZXJ0KG9wLmluc2VydCwgZm9ybWF0cyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZWx0YS5wdXNoKG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpKTtcbiAgICAgICAgdGhpcy5kZWx0YSA9IG9sZERlbHRhLmNvbXBvc2UoY2hhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVsdGEgPSB0aGlzLmdldERlbHRhKCk7XG4gICAgICAgIGlmICghY2hhbmdlIHx8ICEoMCwgX2RlZXBFcXVhbDIuZGVmYXVsdCkob2xkRGVsdGEuY29tcG9zZShjaGFuZ2UpLCB0aGlzLmRlbHRhKSkge1xuICAgICAgICAgIGNoYW5nZSA9IG9sZERlbHRhLmRpZmYodGhpcy5kZWx0YSwgY3Vyc29ySW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFZGl0b3I7XG59KCk7XG5cbmZ1bmN0aW9uIGNvbWJpbmVGb3JtYXRzKGZvcm1hdHMsIGNvbWJpbmVkKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhjb21iaW5lZCkucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIG5hbWUpIHtcbiAgICBpZiAoZm9ybWF0c1tuYW1lXSA9PSBudWxsKSByZXR1cm4gbWVyZ2VkO1xuICAgIGlmIChjb21iaW5lZFtuYW1lXSA9PT0gZm9ybWF0c1tuYW1lXSkge1xuICAgICAgbWVyZ2VkW25hbWVdID0gY29tYmluZWRbbmFtZV07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbWJpbmVkW25hbWVdKSkge1xuICAgICAgaWYgKGNvbWJpbmVkW25hbWVdLmluZGV4T2YoZm9ybWF0c1tuYW1lXSkgPCAwKSB7XG4gICAgICAgIG1lcmdlZFtuYW1lXSA9IGNvbWJpbmVkW25hbWVdLmNvbmNhdChbZm9ybWF0c1tuYW1lXV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZWRbbmFtZV0gPSBbY29tYmluZWRbbmFtZV0sIGZvcm1hdHNbbmFtZV1dO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURlbHRhKGRlbHRhKSB7XG4gIHJldHVybiBkZWx0YS5yZWR1Y2UoZnVuY3Rpb24gKGRlbHRhLCBvcCkge1xuICAgIGlmIChvcC5pbnNlcnQgPT09IDEpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gKDAsIF9jbG9uZTIuZGVmYXVsdCkob3AuYXR0cmlidXRlcyk7XG4gICAgICBkZWxldGUgYXR0cmlidXRlc1snaW1hZ2UnXTtcbiAgICAgIHJldHVybiBkZWx0YS5pbnNlcnQoeyBpbWFnZTogb3AuYXR0cmlidXRlcy5pbWFnZSB9LCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgaWYgKG9wLmF0dHJpYnV0ZXMgIT0gbnVsbCAmJiAob3AuYXR0cmlidXRlcy5saXN0ID09PSB0cnVlIHx8IG9wLmF0dHJpYnV0ZXMuYnVsbGV0ID09PSB0cnVlKSkge1xuICAgICAgb3AgPSAoMCwgX2Nsb25lMi5kZWZhdWx0KShvcCk7XG4gICAgICBpZiAob3AuYXR0cmlidXRlcy5saXN0KSB7XG4gICAgICAgIG9wLmF0dHJpYnV0ZXMubGlzdCA9ICdvcmRlcmVkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wLmF0dHJpYnV0ZXMubGlzdCA9ICdidWxsZXQnO1xuICAgICAgICBkZWxldGUgb3AuYXR0cmlidXRlcy5idWxsZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3AuaW5zZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHRleHQgPSBvcC5pbnNlcnQucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKS5yZXBsYWNlKC9cXHIvZywgJ1xcbicpO1xuICAgICAgcmV0dXJuIGRlbHRhLmluc2VydCh0ZXh0LCBvcC5hdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbHRhLnB1c2gob3ApO1xuICB9LCBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKSk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEVkaXRvcjtcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5SYW5nZSA9IHVuZGVmaW5lZDtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfY2xvbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblxudmFyIF9jbG9uZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9uZSk7XG5cbnZhciBfZGVlcEVxdWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBfZGVlcEVxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZXBFcXVhbCk7XG5cbnZhciBfZW1pdHRlcjMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgX2VtaXR0ZXI0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZW1pdHRlcjMpO1xuXG52YXIgX2xvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgX2xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2dnZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGRlYnVnID0gKDAsIF9sb2dnZXIyLmRlZmF1bHQpKCdxdWlsbDpzZWxlY3Rpb24nKTtcblxudmFyIFJhbmdlID0gZnVuY3Rpb24gUmFuZ2UoaW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFuZ2UpO1xuXG4gIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG59O1xuXG52YXIgU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTZWxlY3Rpb24oc2Nyb2xsLCBlbWl0dGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZWxlY3Rpb24pO1xuXG4gICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICB0aGlzLnNjcm9sbCA9IHNjcm9sbDtcbiAgICB0aGlzLmNvbXBvc2luZyA9IGZhbHNlO1xuICAgIHRoaXMubW91c2VEb3duID0gZmFsc2U7XG4gICAgdGhpcy5yb290ID0gdGhpcy5zY3JvbGwuZG9tTm9kZTtcbiAgICB0aGlzLmN1cnNvciA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKCdjdXJzb3InLCB0aGlzKTtcbiAgICAvLyBzYXZlZFJhbmdlIGlzIGxhc3Qgbm9uLW51bGwgcmFuZ2VcbiAgICB0aGlzLmxhc3RSYW5nZSA9IHRoaXMuc2F2ZWRSYW5nZSA9IG5ldyBSYW5nZSgwLCAwKTtcbiAgICB0aGlzLmhhbmRsZUNvbXBvc2l0aW9uKCk7XG4gICAgdGhpcy5oYW5kbGVEcmFnZ2luZygpO1xuICAgIHRoaXMuZW1pdHRlci5saXN0ZW5ET00oJ3NlbGVjdGlvbmNoYW5nZScsIGRvY3VtZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLm1vdXNlRG93bikge1xuICAgICAgICBzZXRUaW1lb3V0KF90aGlzLnVwZGF0ZS5iaW5kKF90aGlzLCBfZW1pdHRlcjQuZGVmYXVsdC5zb3VyY2VzLlVTRVIpLCAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVtaXR0ZXIub24oX2VtaXR0ZXI0LmRlZmF1bHQuZXZlbnRzLkVESVRPUl9DSEFOR0UsIGZ1bmN0aW9uICh0eXBlLCBkZWx0YSkge1xuICAgICAgaWYgKHR5cGUgPT09IF9lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5URVhUX0NIQU5HRSAmJiBkZWx0YS5sZW5ndGgoKSA+IDApIHtcbiAgICAgICAgX3RoaXMudXBkYXRlKF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVtaXR0ZXIub24oX2VtaXR0ZXI0LmRlZmF1bHQuZXZlbnRzLlNDUk9MTF9CRUZPUkVfVVBEQVRFLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLmhhc0ZvY3VzKCkpIHJldHVybjtcbiAgICAgIHZhciBuYXRpdmUgPSBfdGhpcy5nZXROYXRpdmVSYW5nZSgpO1xuICAgICAgaWYgKG5hdGl2ZSA9PSBudWxsKSByZXR1cm47XG4gICAgICBpZiAobmF0aXZlLnN0YXJ0Lm5vZGUgPT09IF90aGlzLmN1cnNvci50ZXh0Tm9kZSkgcmV0dXJuOyAvLyBjdXJzb3IucmVzdG9yZSgpIHdpbGwgaGFuZGxlXG4gICAgICAvLyBUT0RPIHVuY2xlYXIgaWYgdGhpcyBoYXMgbmVnYXRpdmUgc2lkZSBlZmZlY3RzXG4gICAgICBfdGhpcy5lbWl0dGVyLm9uY2UoX2VtaXR0ZXI0LmRlZmF1bHQuZXZlbnRzLlNDUk9MTF9VUERBVEUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfdGhpcy5zZXROYXRpdmVSYW5nZShuYXRpdmUuc3RhcnQubm9kZSwgbmF0aXZlLnN0YXJ0Lm9mZnNldCwgbmF0aXZlLmVuZC5ub2RlLCBuYXRpdmUuZW5kLm9mZnNldCk7XG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHt9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmVtaXR0ZXIub24oX2VtaXR0ZXI0LmRlZmF1bHQuZXZlbnRzLlNDUk9MTF9PUFRJTUlaRSwgZnVuY3Rpb24gKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgICAgaWYgKGNvbnRleHQucmFuZ2UpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0JHJhbmdlID0gY29udGV4dC5yYW5nZSxcbiAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IF9jb250ZXh0JHJhbmdlLnN0YXJ0Tm9kZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gX2NvbnRleHQkcmFuZ2Uuc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICBlbmROb2RlID0gX2NvbnRleHQkcmFuZ2UuZW5kTm9kZSxcbiAgICAgICAgICAgIGVuZE9mZnNldCA9IF9jb250ZXh0JHJhbmdlLmVuZE9mZnNldDtcblxuICAgICAgICBfdGhpcy5zZXROYXRpdmVSYW5nZShzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0LCBlbmROb2RlLCBlbmRPZmZzZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlKF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTZWxlY3Rpb24sIFt7XG4gICAga2V5OiAnaGFuZGxlQ29tcG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDb21wb3NpdGlvbigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmNvbXBvc2luZyA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucm9vdC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICBpZiAoX3RoaXMyLmN1cnNvci5wYXJlbnQpIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBfdGhpczIuY3Vyc29yLnJlc3RvcmUoKTtcbiAgICAgICAgICBpZiAoIXJhbmdlKSByZXR1cm47XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuc2V0TmF0aXZlUmFuZ2UocmFuZ2Uuc3RhcnROb2RlLCByYW5nZS5zdGFydE9mZnNldCwgcmFuZ2UuZW5kTm9kZSwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlRHJhZ2dpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVEcmFnZ2luZygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmVtaXR0ZXIubGlzdGVuRE9NKCdtb3VzZWRvd24nLCBkb2N1bWVudC5ib2R5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5tb3VzZURvd24gPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXR0ZXIubGlzdGVuRE9NKCdtb3VzZXVwJywgZG9jdW1lbnQuYm9keSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMubW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIF90aGlzMy51cGRhdGUoX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZvY3VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgICBpZiAodGhpcy5oYXNGb2N1cygpKSByZXR1cm47XG4gICAgICB0aGlzLnJvb3QuZm9jdXMoKTtcbiAgICAgIHRoaXMuc2V0UmFuZ2UodGhpcy5zYXZlZFJhbmdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQoX2Zvcm1hdCwgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLnNjcm9sbC53aGl0ZWxpc3QgIT0gbnVsbCAmJiAhdGhpcy5zY3JvbGwud2hpdGVsaXN0W19mb3JtYXRdKSByZXR1cm47XG4gICAgICB0aGlzLnNjcm9sbC51cGRhdGUoKTtcbiAgICAgIHZhciBuYXRpdmVSYW5nZSA9IHRoaXMuZ2V0TmF0aXZlUmFuZ2UoKTtcbiAgICAgIGlmIChuYXRpdmVSYW5nZSA9PSBudWxsIHx8ICFuYXRpdmVSYW5nZS5uYXRpdmUuY29sbGFwc2VkIHx8IF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkoX2Zvcm1hdCwgX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DSykpIHJldHVybjtcbiAgICAgIGlmIChuYXRpdmVSYW5nZS5zdGFydC5ub2RlICE9PSB0aGlzLmN1cnNvci50ZXh0Tm9kZSkge1xuICAgICAgICB2YXIgYmxvdCA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuZmluZChuYXRpdmVSYW5nZS5zdGFydC5ub2RlLCBmYWxzZSk7XG4gICAgICAgIGlmIChibG90ID09IG51bGwpIHJldHVybjtcbiAgICAgICAgLy8gVE9ETyBHaXZlIGJsb3QgYWJpbGl0eSB0byBub3Qgc3BsaXRcbiAgICAgICAgaWYgKGJsb3QgaW5zdGFuY2VvZiBfcGFyY2htZW50Mi5kZWZhdWx0LkxlYWYpIHtcbiAgICAgICAgICB2YXIgYWZ0ZXIgPSBibG90LnNwbGl0KG5hdGl2ZVJhbmdlLnN0YXJ0Lm9mZnNldCk7XG4gICAgICAgICAgYmxvdC5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuY3Vyc29yLCBhZnRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmxvdC5pbnNlcnRCZWZvcmUodGhpcy5jdXJzb3IsIG5hdGl2ZVJhbmdlLnN0YXJ0Lm5vZGUpOyAvLyBTaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJzb3IuYXR0YWNoKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnNvci5mb3JtYXQoX2Zvcm1hdCwgdmFsdWUpO1xuICAgICAgdGhpcy5zY3JvbGwub3B0aW1pemUoKTtcbiAgICAgIHRoaXMuc2V0TmF0aXZlUmFuZ2UodGhpcy5jdXJzb3IudGV4dE5vZGUsIHRoaXMuY3Vyc29yLnRleHROb2RlLmRhdGEubGVuZ3RoKTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Qm91bmRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm91bmRzKGluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gICAgICB2YXIgc2Nyb2xsTGVuZ3RoID0gdGhpcy5zY3JvbGwubGVuZ3RoKCk7XG4gICAgICBpbmRleCA9IE1hdGgubWluKGluZGV4LCBzY3JvbGxMZW5ndGggLSAxKTtcbiAgICAgIGxlbmd0aCA9IE1hdGgubWluKGluZGV4ICsgbGVuZ3RoLCBzY3JvbGxMZW5ndGggLSAxKSAtIGluZGV4O1xuICAgICAgdmFyIG5vZGUgPSB2b2lkIDAsXG4gICAgICAgICAgX3Njcm9sbCRsZWFmID0gdGhpcy5zY3JvbGwubGVhZihpbmRleCksXG4gICAgICAgICAgX3Njcm9sbCRsZWFmMiA9IF9zbGljZWRUb0FycmF5KF9zY3JvbGwkbGVhZiwgMiksXG4gICAgICAgICAgbGVhZiA9IF9zY3JvbGwkbGVhZjJbMF0sXG4gICAgICAgICAgb2Zmc2V0ID0gX3Njcm9sbCRsZWFmMlsxXTtcbiAgICAgIGlmIChsZWFmID09IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgICB2YXIgX2xlYWYkcG9zaXRpb24gPSBsZWFmLnBvc2l0aW9uKG9mZnNldCwgdHJ1ZSk7XG5cbiAgICAgIHZhciBfbGVhZiRwb3NpdGlvbjIgPSBfc2xpY2VkVG9BcnJheShfbGVhZiRwb3NpdGlvbiwgMik7XG5cbiAgICAgIG5vZGUgPSBfbGVhZiRwb3NpdGlvbjJbMF07XG4gICAgICBvZmZzZXQgPSBfbGVhZiRwb3NpdGlvbjJbMV07XG5cbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuXG4gICAgICAgIHZhciBfc2Nyb2xsJGxlYWYzID0gdGhpcy5zY3JvbGwubGVhZihpbmRleCArIGxlbmd0aCk7XG5cbiAgICAgICAgdmFyIF9zY3JvbGwkbGVhZjQgPSBfc2xpY2VkVG9BcnJheShfc2Nyb2xsJGxlYWYzLCAyKTtcblxuICAgICAgICBsZWFmID0gX3Njcm9sbCRsZWFmNFswXTtcbiAgICAgICAgb2Zmc2V0ID0gX3Njcm9sbCRsZWFmNFsxXTtcblxuICAgICAgICBpZiAobGVhZiA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgX2xlYWYkcG9zaXRpb24zID0gbGVhZi5wb3NpdGlvbihvZmZzZXQsIHRydWUpO1xuXG4gICAgICAgIHZhciBfbGVhZiRwb3NpdGlvbjQgPSBfc2xpY2VkVG9BcnJheShfbGVhZiRwb3NpdGlvbjMsIDIpO1xuXG4gICAgICAgIG5vZGUgPSBfbGVhZiRwb3NpdGlvbjRbMF07XG4gICAgICAgIG9mZnNldCA9IF9sZWFmJHBvc2l0aW9uNFsxXTtcblxuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNpZGUgPSAnbGVmdCc7XG4gICAgICAgIHZhciByZWN0ID0gdm9pZCAwO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgbm9kZS5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHJhbmdlLnNldEVuZChub2RlLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0IC0gMSk7XG4gICAgICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHNpZGUgPSAncmlnaHQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWN0ID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdCA9IGxlYWYuZG9tTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBpZiAob2Zmc2V0ID4gMCkgc2lkZSA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBib3R0b206IHJlY3QudG9wICsgcmVjdC5oZWlnaHQsXG4gICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgICAgICBsZWZ0OiByZWN0W3NpZGVdLFxuICAgICAgICAgIHJpZ2h0OiByZWN0W3NpZGVdLFxuICAgICAgICAgIHRvcDogcmVjdC50b3AsXG4gICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXROYXRpdmVSYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5hdGl2ZVJhbmdlKCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKHNlbGVjdGlvbiA9PSBudWxsIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50IDw9IDApIHJldHVybiBudWxsO1xuICAgICAgdmFyIG5hdGl2ZVJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICBpZiAobmF0aXZlUmFuZ2UgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLm5vcm1hbGl6ZU5hdGl2ZShuYXRpdmVSYW5nZSk7XG4gICAgICBkZWJ1Zy5pbmZvKCdnZXROYXRpdmVSYW5nZScsIHJhbmdlKTtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRSYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhbmdlKCkge1xuICAgICAgdmFyIG5vcm1hbGl6ZWQgPSB0aGlzLmdldE5hdGl2ZVJhbmdlKCk7XG4gICAgICBpZiAobm9ybWFsaXplZCA9PSBudWxsKSByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5ub3JtYWxpemVkVG9SYW5nZShub3JtYWxpemVkKTtcbiAgICAgIHJldHVybiBbcmFuZ2UsIG5vcm1hbGl6ZWRdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hhc0ZvY3VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzRm9jdXMoKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5yb290O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25vcm1hbGl6ZWRUb1JhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplZFRvUmFuZ2UocmFuZ2UpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgcG9zaXRpb25zID0gW1tyYW5nZS5zdGFydC5ub2RlLCByYW5nZS5zdGFydC5vZmZzZXRdXTtcbiAgICAgIGlmICghcmFuZ2UubmF0aXZlLmNvbGxhcHNlZCkge1xuICAgICAgICBwb3NpdGlvbnMucHVzaChbcmFuZ2UuZW5kLm5vZGUsIHJhbmdlLmVuZC5vZmZzZXRdKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleGVzID0gcG9zaXRpb25zLm1hcChmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF9wb3NpdGlvbiA9IF9zbGljZWRUb0FycmF5KHBvc2l0aW9uLCAyKSxcbiAgICAgICAgICAgIG5vZGUgPSBfcG9zaXRpb25bMF0sXG4gICAgICAgICAgICBvZmZzZXQgPSBfcG9zaXRpb25bMV07XG5cbiAgICAgICAgdmFyIGJsb3QgPSBfcGFyY2htZW50Mi5kZWZhdWx0LmZpbmQobm9kZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBpbmRleCA9IGJsb3Qub2Zmc2V0KF90aGlzNC5zY3JvbGwpO1xuICAgICAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9IGVsc2UgaWYgKGJsb3QgaW5zdGFuY2VvZiBfcGFyY2htZW50Mi5kZWZhdWx0LkNvbnRhaW5lcikge1xuICAgICAgICAgIHJldHVybiBpbmRleCArIGJsb3QubGVuZ3RoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ICsgYmxvdC5pbmRleChub2RlLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBlbmQgPSBNYXRoLm1pbihNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoaW5kZXhlcykpLCB0aGlzLnNjcm9sbC5sZW5ndGgoKSAtIDEpO1xuICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgW2VuZF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShpbmRleGVzKSkpO1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25vcm1hbGl6ZU5hdGl2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGl6ZU5hdGl2ZShuYXRpdmVSYW5nZSkge1xuICAgICAgaWYgKCFjb250YWlucyh0aGlzLnJvb3QsIG5hdGl2ZVJhbmdlLnN0YXJ0Q29udGFpbmVyKSB8fCAhbmF0aXZlUmFuZ2UuY29sbGFwc2VkICYmICFjb250YWlucyh0aGlzLnJvb3QsIG5hdGl2ZVJhbmdlLmVuZENvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICAgIHN0YXJ0OiB7IG5vZGU6IG5hdGl2ZVJhbmdlLnN0YXJ0Q29udGFpbmVyLCBvZmZzZXQ6IG5hdGl2ZVJhbmdlLnN0YXJ0T2Zmc2V0IH0sXG4gICAgICAgIGVuZDogeyBub2RlOiBuYXRpdmVSYW5nZS5lbmRDb250YWluZXIsIG9mZnNldDogbmF0aXZlUmFuZ2UuZW5kT2Zmc2V0IH0sXG4gICAgICAgIG5hdGl2ZTogbmF0aXZlUmFuZ2VcbiAgICAgIH07XG4gICAgICBbcmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZF0uZm9yRWFjaChmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBwb3NpdGlvbi5ub2RlLFxuICAgICAgICAgICAgb2Zmc2V0ID0gcG9zaXRpb24ub2Zmc2V0O1xuICAgICAgICB3aGlsZSAoIShub2RlIGluc3RhbmNlb2YgVGV4dCkgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IG9mZnNldCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT09IG9mZnNldCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZSBpbnN0YW5jZW9mIFRleHQgPyBub2RlLmRhdGEubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbi5ub2RlID0gbm9kZSwgcG9zaXRpb24ub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmFuZ2VUb05hdGl2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhbmdlVG9OYXRpdmUocmFuZ2UpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgaW5kZXhlcyA9IHJhbmdlLmNvbGxhcHNlZCA/IFtyYW5nZS5pbmRleF0gOiBbcmFuZ2UuaW5kZXgsIHJhbmdlLmluZGV4ICsgcmFuZ2UubGVuZ3RoXTtcbiAgICAgIHZhciBhcmdzID0gW107XG4gICAgICB2YXIgc2Nyb2xsTGVuZ3RoID0gdGhpcy5zY3JvbGwubGVuZ3RoKCk7XG4gICAgICBpbmRleGVzLmZvckVhY2goZnVuY3Rpb24gKGluZGV4LCBpKSB7XG4gICAgICAgIGluZGV4ID0gTWF0aC5taW4oc2Nyb2xsTGVuZ3RoIC0gMSwgaW5kZXgpO1xuICAgICAgICB2YXIgbm9kZSA9IHZvaWQgMCxcbiAgICAgICAgICAgIF9zY3JvbGwkbGVhZjUgPSBfdGhpczUuc2Nyb2xsLmxlYWYoaW5kZXgpLFxuICAgICAgICAgICAgX3Njcm9sbCRsZWFmNiA9IF9zbGljZWRUb0FycmF5KF9zY3JvbGwkbGVhZjUsIDIpLFxuICAgICAgICAgICAgbGVhZiA9IF9zY3JvbGwkbGVhZjZbMF0sXG4gICAgICAgICAgICBvZmZzZXQgPSBfc2Nyb2xsJGxlYWY2WzFdO1xuICAgICAgICB2YXIgX2xlYWYkcG9zaXRpb241ID0gbGVhZi5wb3NpdGlvbihvZmZzZXQsIGkgIT09IDApO1xuXG4gICAgICAgIHZhciBfbGVhZiRwb3NpdGlvbjYgPSBfc2xpY2VkVG9BcnJheShfbGVhZiRwb3NpdGlvbjUsIDIpO1xuXG4gICAgICAgIG5vZGUgPSBfbGVhZiRwb3NpdGlvbjZbMF07XG4gICAgICAgIG9mZnNldCA9IF9sZWFmJHBvc2l0aW9uNlsxXTtcblxuICAgICAgICBhcmdzLnB1c2gobm9kZSwgb2Zmc2V0KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICBhcmdzID0gYXJncy5jb25jYXQoYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzY3JvbGxJbnRvVmlldycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KHNjcm9sbGluZ0NvbnRhaW5lcikge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5sYXN0UmFuZ2U7XG4gICAgICBpZiAocmFuZ2UgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKHJhbmdlLmluZGV4LCByYW5nZS5sZW5ndGgpO1xuICAgICAgaWYgKGJvdW5kcyA9PSBudWxsKSByZXR1cm47XG4gICAgICB2YXIgbGltaXQgPSB0aGlzLnNjcm9sbC5sZW5ndGgoKSAtIDE7XG5cbiAgICAgIHZhciBfc2Nyb2xsJGxpbmUgPSB0aGlzLnNjcm9sbC5saW5lKE1hdGgubWluKHJhbmdlLmluZGV4LCBsaW1pdCkpLFxuICAgICAgICAgIF9zY3JvbGwkbGluZTIgPSBfc2xpY2VkVG9BcnJheShfc2Nyb2xsJGxpbmUsIDEpLFxuICAgICAgICAgIGZpcnN0ID0gX3Njcm9sbCRsaW5lMlswXTtcblxuICAgICAgdmFyIGxhc3QgPSBmaXJzdDtcbiAgICAgIGlmIChyYW5nZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBfc2Nyb2xsJGxpbmUzID0gdGhpcy5zY3JvbGwubGluZShNYXRoLm1pbihyYW5nZS5pbmRleCArIHJhbmdlLmxlbmd0aCwgbGltaXQpKTtcblxuICAgICAgICB2YXIgX3Njcm9sbCRsaW5lNCA9IF9zbGljZWRUb0FycmF5KF9zY3JvbGwkbGluZTMsIDEpO1xuXG4gICAgICAgIGxhc3QgPSBfc2Nyb2xsJGxpbmU0WzBdO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0ID09IG51bGwgfHwgbGFzdCA9PSBudWxsKSByZXR1cm47XG4gICAgICB2YXIgc2Nyb2xsQm91bmRzID0gc2Nyb2xsaW5nQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKGJvdW5kcy50b3AgPCBzY3JvbGxCb3VuZHMudG9wKSB7XG4gICAgICAgIHNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3AgLT0gc2Nyb2xsQm91bmRzLnRvcCAtIGJvdW5kcy50b3A7XG4gICAgICB9IGVsc2UgaWYgKGJvdW5kcy5ib3R0b20gPiBzY3JvbGxCb3VuZHMuYm90dG9tKSB7XG4gICAgICAgIHNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3AgKz0gYm91bmRzLmJvdHRvbSAtIHNjcm9sbEJvdW5kcy5ib3R0b207XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0TmF0aXZlUmFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXROYXRpdmVSYW5nZShzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0KSB7XG4gICAgICB2YXIgZW5kTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogc3RhcnROb2RlO1xuICAgICAgdmFyIGVuZE9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogc3RhcnRPZmZzZXQ7XG4gICAgICB2YXIgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gICAgICBkZWJ1Zy5pbmZvKCdzZXROYXRpdmVSYW5nZScsIHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQsIGVuZE5vZGUsIGVuZE9mZnNldCk7XG4gICAgICBpZiAoc3RhcnROb2RlICE9IG51bGwgJiYgKHRoaXMucm9vdC5wYXJlbnROb2RlID09IG51bGwgfHwgc3RhcnROb2RlLnBhcmVudE5vZGUgPT0gbnVsbCB8fCBlbmROb2RlLnBhcmVudE5vZGUgPT0gbnVsbCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKHNlbGVjdGlvbiA9PSBudWxsKSByZXR1cm47XG4gICAgICBpZiAoc3RhcnROb2RlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHRoaXMucm9vdC5mb2N1cygpO1xuICAgICAgICB2YXIgbmF0aXZlID0gKHRoaXMuZ2V0TmF0aXZlUmFuZ2UoKSB8fCB7fSkubmF0aXZlO1xuICAgICAgICBpZiAobmF0aXZlID09IG51bGwgfHwgZm9yY2UgfHwgc3RhcnROb2RlICE9PSBuYXRpdmUuc3RhcnRDb250YWluZXIgfHwgc3RhcnRPZmZzZXQgIT09IG5hdGl2ZS5zdGFydE9mZnNldCB8fCBlbmROb2RlICE9PSBuYXRpdmUuZW5kQ29udGFpbmVyIHx8IGVuZE9mZnNldCAhPT0gbmF0aXZlLmVuZE9mZnNldCkge1xuXG4gICAgICAgICAgaWYgKHN0YXJ0Tm9kZS50YWdOYW1lID09IFwiQlJcIikge1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBbXS5pbmRleE9mLmNhbGwoc3RhcnROb2RlLnBhcmVudE5vZGUuY2hpbGROb2Rlcywgc3RhcnROb2RlKTtcbiAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kTm9kZS50YWdOYW1lID09IFwiQlJcIikge1xuICAgICAgICAgICAgZW5kT2Zmc2V0ID0gW10uaW5kZXhPZi5jYWxsKGVuZE5vZGUucGFyZW50Tm9kZS5jaGlsZE5vZGVzLCBlbmROb2RlKTtcbiAgICAgICAgICAgIGVuZE5vZGUgPSBlbmROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnROb2RlLCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE5vZGUsIGVuZE9mZnNldCk7XG4gICAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgdGhpcy5yb290LmJsdXIoKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpOyAvLyByb290LmJsdXIoKSBub3QgZW5vdWdoIG9uIElFMTErVHJhdmlzK1NhdWNlTGFicyAoYnV0IG5vdCBsb2NhbCBWTXMpXG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0UmFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSYW5nZShyYW5nZSkge1xuICAgICAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuQVBJO1xuXG4gICAgICBpZiAodHlwZW9mIGZvcmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICBzb3VyY2UgPSBmb3JjZTtcbiAgICAgICAgZm9yY2UgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGRlYnVnLmluZm8oJ3NldFJhbmdlJywgcmFuZ2UpO1xuICAgICAgaWYgKHJhbmdlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnJhbmdlVG9OYXRpdmUocmFuZ2UpO1xuICAgICAgICB0aGlzLnNldE5hdGl2ZVJhbmdlLmFwcGx5KHRoaXMsIF90b0NvbnN1bWFibGVBcnJheShhcmdzKS5jb25jYXQoW2ZvcmNlXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXROYXRpdmVSYW5nZShudWxsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlKHNvdXJjZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogX2VtaXR0ZXI0LmRlZmF1bHQuc291cmNlcy5VU0VSO1xuXG4gICAgICB2YXIgb2xkUmFuZ2UgPSB0aGlzLmxhc3RSYW5nZTtcblxuICAgICAgdmFyIF9nZXRSYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKSxcbiAgICAgICAgICBfZ2V0UmFuZ2UyID0gX3NsaWNlZFRvQXJyYXkoX2dldFJhbmdlLCAyKSxcbiAgICAgICAgICBsYXN0UmFuZ2UgPSBfZ2V0UmFuZ2UyWzBdLFxuICAgICAgICAgIG5hdGl2ZVJhbmdlID0gX2dldFJhbmdlMlsxXTtcblxuICAgICAgdGhpcy5sYXN0UmFuZ2UgPSBsYXN0UmFuZ2U7XG4gICAgICBpZiAodGhpcy5sYXN0UmFuZ2UgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNhdmVkUmFuZ2UgPSB0aGlzLmxhc3RSYW5nZTtcbiAgICAgIH1cbiAgICAgIGlmICghKDAsIF9kZWVwRXF1YWwyLmRlZmF1bHQpKG9sZFJhbmdlLCB0aGlzLmxhc3RSYW5nZSkpIHtcbiAgICAgICAgdmFyIF9lbWl0dGVyO1xuXG4gICAgICAgIGlmICghdGhpcy5jb21wb3NpbmcgJiYgbmF0aXZlUmFuZ2UgIT0gbnVsbCAmJiBuYXRpdmVSYW5nZS5uYXRpdmUuY29sbGFwc2VkICYmIG5hdGl2ZVJhbmdlLnN0YXJ0Lm5vZGUgIT09IHRoaXMuY3Vyc29yLnRleHROb2RlKSB7XG4gICAgICAgICAgdGhpcy5jdXJzb3IucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdzID0gW19lbWl0dGVyNC5kZWZhdWx0LmV2ZW50cy5TRUxFQ1RJT05fQ0hBTkdFLCAoMCwgX2Nsb25lMi5kZWZhdWx0KSh0aGlzLmxhc3RSYW5nZSksICgwLCBfY2xvbmUyLmRlZmF1bHQpKG9sZFJhbmdlKSwgc291cmNlXTtcbiAgICAgICAgKF9lbWl0dGVyID0gdGhpcy5lbWl0dGVyKS5lbWl0LmFwcGx5KF9lbWl0dGVyLCBbX2VtaXR0ZXI0LmRlZmF1bHQuZXZlbnRzLkVESVRPUl9DSEFOR0VdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIGlmIChzb3VyY2UgIT09IF9lbWl0dGVyNC5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKSB7XG4gICAgICAgICAgdmFyIF9lbWl0dGVyMjtcblxuICAgICAgICAgIChfZW1pdHRlcjIgPSB0aGlzLmVtaXR0ZXIpLmVtaXQuYXBwbHkoX2VtaXR0ZXIyLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTZWxlY3Rpb247XG59KCk7XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgZGVzY2VuZGFudCkge1xuICB0cnkge1xuICAgIC8vIEZpcmVmb3ggaW5zZXJ0cyBpbmFjY2Vzc2libGUgbm9kZXMgYXJvdW5kIHZpZGVvIGVsZW1lbnRzXG4gICAgZGVzY2VuZGFudC5wYXJlbnROb2RlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIElFMTEgaGFzIGJ1ZyB3aXRoIFRleHQgbm9kZXNcbiAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy83ODA4NzQvbm9kZS1jb250YWlucy1pcy1pbmNvcnJlY3RcbiAgaWYgKGRlc2NlbmRhbnQgaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgZGVzY2VuZGFudCA9IGRlc2NlbmRhbnQucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gcGFyZW50LmNvbnRhaW5zKGRlc2NlbmRhbnQpO1xufVxuXG5leHBvcnRzLlJhbmdlID0gUmFuZ2U7XG5leHBvcnRzLmRlZmF1bHQgPSBTZWxlY3Rpb247XG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEJyZWFrID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkRW1iZWQpIHtcbiAgX2luaGVyaXRzKEJyZWFrLCBfUGFyY2htZW50JEVtYmVkKTtcblxuICBmdW5jdGlvbiBCcmVhaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJlYWspO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChCcmVhay5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJyZWFrKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQnJlYWssIFt7XG4gICAga2V5OiAnaW5zZXJ0SW50bycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEludG8ocGFyZW50LCByZWYpIHtcbiAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIF9nZXQoQnJlYWsucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnJlYWsucHJvdG90eXBlKSwgJ2luc2VydEludG8nLCB0aGlzKS5jYWxsKHRoaXMsIHBhcmVudCwgcmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGVuZ3RoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ3ZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCcmVhaztcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5FbWJlZCk7XG5cbkJyZWFrLmJsb3ROYW1lID0gJ2JyZWFrJztcbkJyZWFrLnRhZ05hbWUgPSAnQlInO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCcmVhaztcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGlua2VkX2xpc3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xudmFyIHNoYWRvd18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG52YXIgUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIENvbnRhaW5lckJsb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnRhaW5lckJsb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29udGFpbmVyQmxvdChkb21Ob2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvbU5vZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJ1aWxkKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUob3RoZXIpO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmF0dGFjaC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5hdHRhY2goKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBsaW5rZWRfbGlzdF8xLmRlZmF1bHQoKTtcbiAgICAgICAgLy8gTmVlZCB0byBiZSByZXZlcnNlZCBmb3IgaWYgRE9NIG5vZGVzIGFscmVhZHkgaW4gb3JkZXJcbiAgICAgICAgW10uc2xpY2VcbiAgICAgICAgICAgIC5jYWxsKHRoaXMuZG9tTm9kZS5jaGlsZE5vZGVzKVxuICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gbWFrZUJsb3Qobm9kZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5zZXJ0QmVmb3JlKGNoaWxkLCBfdGhpcy5jaGlsZHJlbi5oZWFkIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFJlZ2lzdHJ5LlBhcmNobWVudEVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUuZGVsZXRlQXQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgbGVuZ3RoID09PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2hBdChpbmRleCwgbGVuZ3RoLCBmdW5jdGlvbiAoY2hpbGQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGlsZC5kZWxldGVBdChvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUuZGVzY2VuZGFudCA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jaGlsZHJlbi5maW5kKGluZGV4KSwgY2hpbGQgPSBfYVswXSwgb2Zmc2V0ID0gX2FbMV07XG4gICAgICAgIGlmICgoY3JpdGVyaWEuYmxvdE5hbWUgPT0gbnVsbCAmJiBjcml0ZXJpYShjaGlsZCkpIHx8XG4gICAgICAgICAgICAoY3JpdGVyaWEuYmxvdE5hbWUgIT0gbnVsbCAmJiBjaGlsZCBpbnN0YW5jZW9mIGNyaXRlcmlhKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtjaGlsZCwgb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIENvbnRhaW5lckJsb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5kZXNjZW5kYW50KGNyaXRlcmlhLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtudWxsLCAtMV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLmRlc2NlbmRhbnRzID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gMDsgfVxuICAgICAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHsgbGVuZ3RoID0gTnVtYmVyLk1BWF9WQUxVRTsgfVxuICAgICAgICB2YXIgZGVzY2VuZGFudHMgPSBbXTtcbiAgICAgICAgdmFyIGxlbmd0aExlZnQgPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaEF0KGluZGV4LCBsZW5ndGgsIGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKChjcml0ZXJpYS5ibG90TmFtZSA9PSBudWxsICYmIGNyaXRlcmlhKGNoaWxkKSkgfHxcbiAgICAgICAgICAgICAgICAoY3JpdGVyaWEuYmxvdE5hbWUgIT0gbnVsbCAmJiBjaGlsZCBpbnN0YW5jZW9mIGNyaXRlcmlhKSkge1xuICAgICAgICAgICAgICAgIGRlc2NlbmRhbnRzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQ29udGFpbmVyQmxvdCkge1xuICAgICAgICAgICAgICAgIGRlc2NlbmRhbnRzID0gZGVzY2VuZGFudHMuY29uY2F0KGNoaWxkLmRlc2NlbmRhbnRzKGNyaXRlcmlhLCBpbmRleCwgbGVuZ3RoTGVmdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuZ3RoTGVmdCAtPSBsZW5ndGg7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVzY2VuZGFudHM7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLmRldGFjaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXRhY2guY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLmZvcm1hdEF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaEF0KGluZGV4LCBsZW5ndGgsIGZ1bmN0aW9uIChjaGlsZCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoaWxkLmZvcm1hdEF0KG9mZnNldCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUuaW5zZXJ0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jaGlsZHJlbi5maW5kKGluZGV4KSwgY2hpbGQgPSBfYVswXSwgb2Zmc2V0ID0gX2FbMV07XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQuaW5zZXJ0QXQob2Zmc2V0LCB2YWx1ZSwgZGVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBibG90ID0gZGVmID09IG51bGwgPyBSZWdpc3RyeS5jcmVhdGUoJ3RleHQnLCB2YWx1ZSkgOiBSZWdpc3RyeS5jcmVhdGUodmFsdWUsIGRlZik7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGJsb3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAoY2hpbGRCbG90LCByZWZCbG90KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRpY3MuYWxsb3dlZENoaWxkcmVuICE9IG51bGwgJiZcbiAgICAgICAgICAgICF0aGlzLnN0YXRpY3MuYWxsb3dlZENoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkQmxvdCBpbnN0YW5jZW9mIGNoaWxkO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWdpc3RyeS5QYXJjaG1lbnRFcnJvcihcIkNhbm5vdCBpbnNlcnQgXCIgKyBjaGlsZEJsb3Quc3RhdGljcy5ibG90TmFtZSArIFwiIGludG8gXCIgKyB0aGlzLnN0YXRpY3MuYmxvdE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkQmxvdC5pbnNlcnRJbnRvKHRoaXMsIHJlZkJsb3QpO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVtbyArIGNoaWxkLmxlbmd0aCgpO1xuICAgICAgICB9LCAwKTtcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLm1vdmVDaGlsZHJlbiA9IGZ1bmN0aW9uICh0YXJnZXRQYXJlbnQsIHJlZk5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdGFyZ2V0UGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgcmVmTm9kZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUub3B0aW1pemUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9wdGltaXplLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGljcy5kZWZhdWx0Q2hpbGQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IFJlZ2lzdHJ5LmNyZWF0ZSh0aGlzLnN0YXRpY3MuZGVmYXVsdENoaWxkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBjaGlsZC5vcHRpbWl6ZShjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoaW5kZXgsIGluY2x1c2l2ZSkge1xuICAgICAgICBpZiAoaW5jbHVzaXZlID09PSB2b2lkIDApIHsgaW5jbHVzaXZlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5jaGlsZHJlbi5maW5kKGluZGV4LCBpbmNsdXNpdmUpLCBjaGlsZCA9IF9hWzBdLCBvZmZzZXQgPSBfYVsxXTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gW1t0aGlzLCBpbmRleF1dO1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBDb250YWluZXJCbG90KSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb24uY29uY2F0KGNoaWxkLnBhdGgob2Zmc2V0LCBpbmNsdXNpdmUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBwb3NpdGlvbi5wdXNoKFtjaGlsZCwgb2Zmc2V0XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5yZW1vdmUoY2hpbGQpO1xuICAgIH07XG4gICAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIENvbnRhaW5lckJsb3QpIHtcbiAgICAgICAgICAgIHRhcmdldC5tb3ZlQ2hpbGRyZW4odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZXBsYWNlLmNhbGwodGhpcywgdGFyZ2V0KTtcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKGluZGV4LCBmb3JjZSkge1xuICAgICAgICBpZiAoZm9yY2UgPT09IHZvaWQgMCkgeyBmb3JjZSA9IGZhbHNlOyB9XG4gICAgICAgIGlmICghZm9yY2UpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5sZW5ndGgoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBhZnRlciA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGFmdGVyLCB0aGlzLm5leHQpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2hBdChpbmRleCwgdGhpcy5sZW5ndGgoKSwgZnVuY3Rpb24gKGNoaWxkLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5zcGxpdChvZmZzZXQsIGZvcmNlKTtcbiAgICAgICAgICAgIGFmdGVyLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhZnRlcjtcbiAgICB9O1xuICAgIENvbnRhaW5lckJsb3QucHJvdG90eXBlLnVud3JhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tb3ZlQ2hpbGRyZW4odGhpcy5wYXJlbnQsIHRoaXMubmV4dCk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfTtcbiAgICBDb250YWluZXJCbG90LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobXV0YXRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhZGRlZE5vZGVzID0gW107XG4gICAgICAgIHZhciByZW1vdmVkTm9kZXMgPSBbXTtcbiAgICAgICAgbXV0YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAobXV0YXRpb24udGFyZ2V0ID09PSBfdGhpcy5kb21Ob2RlICYmIG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgICAgYWRkZWROb2Rlcy5wdXNoLmFwcGx5KGFkZGVkTm9kZXMsIG11dGF0aW9uLmFkZGVkTm9kZXMpO1xuICAgICAgICAgICAgICAgIHJlbW92ZWROb2Rlcy5wdXNoLmFwcGx5KHJlbW92ZWROb2RlcywgbXV0YXRpb24ucmVtb3ZlZE5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW92ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBub2RlIGhhcyBhY3R1YWxseSBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgIC8vIE9uZSBleGNlcHRpb24gaXMgQ2hyb21lIGRvZXMgbm90IGltbWVkaWF0ZWx5IHJlbW92ZSBJRlJBTUVzXG4gICAgICAgICAgICAvLyBmcm9tIERPTSBidXQgTXV0YXRpb25SZWNvcmQgaXMgY29ycmVjdCBpbiBpdHMgcmVwb3J0ZWQgcmVtb3ZhbFxuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIG5vZGUudGFnTmFtZSAhPT0gJ0lGUkFNRScgJiZcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5vZGUpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmxvdCA9IFJlZ2lzdHJ5LmZpbmQobm9kZSk7XG4gICAgICAgICAgICBpZiAoYmxvdCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChibG90LmRvbU5vZGUucGFyZW50Tm9kZSA9PSBudWxsIHx8IGJsb3QuZG9tTm9kZS5wYXJlbnROb2RlID09PSBfdGhpcy5kb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgYmxvdC5kZXRhY2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFkZGVkTm9kZXNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudE5vZGUgPT0gX3RoaXMuZG9tTm9kZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGlmIChhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgcmVmQmxvdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVmQmxvdCA9IFJlZ2lzdHJ5LmZpbmQobm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmxvdCA9IG1ha2VCbG90KG5vZGUpO1xuICAgICAgICAgICAgaWYgKGJsb3QubmV4dCAhPSByZWZCbG90IHx8IGJsb3QubmV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb3QucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvdC5wYXJlbnQucmVtb3ZlQ2hpbGQoX3RoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5pbnNlcnRCZWZvcmUoYmxvdCwgcmVmQmxvdCB8fCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDb250YWluZXJCbG90O1xufShzaGFkb3dfMS5kZWZhdWx0KSk7XG5mdW5jdGlvbiBtYWtlQmxvdChub2RlKSB7XG4gICAgdmFyIGJsb3QgPSBSZWdpc3RyeS5maW5kKG5vZGUpO1xuICAgIGlmIChibG90ID09IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJsb3QgPSBSZWdpc3RyeS5jcmVhdGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGJsb3QgPSBSZWdpc3RyeS5jcmVhdGUoUmVnaXN0cnkuU2NvcGUuSU5MSU5FKTtcbiAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwobm9kZS5jaGlsZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBibG90LmRvbU5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChibG90LmRvbU5vZGUsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvdC5hdHRhY2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmxvdDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENvbnRhaW5lckJsb3Q7XG5cblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXR0cmlidXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG52YXIgc3RvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xudmFyIGNvbnRhaW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG52YXIgUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIEZvcm1hdEJsb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZvcm1hdEJsb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9ybWF0QmxvdChkb21Ob2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvbU5vZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmF0dHJpYnV0ZXMgPSBuZXcgc3RvcmVfMS5kZWZhdWx0KF90aGlzLmRvbU5vZGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZvcm1hdEJsb3QuZm9ybWF0cyA9IGZ1bmN0aW9uIChkb21Ob2RlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy50YWdOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9tTm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEZvcm1hdEJsb3QucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gUmVnaXN0cnkucXVlcnkobmFtZSk7XG4gICAgICAgIGlmIChmb3JtYXQgaW5zdGFuY2VvZiBhdHRyaWJ1dG9yXzEuZGVmYXVsdCkge1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLmF0dHJpYnV0ZShmb3JtYXQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCAhPSBudWxsICYmIChuYW1lICE9PSB0aGlzLnN0YXRpY3MuYmxvdE5hbWUgfHwgdGhpcy5mb3JtYXRzKClbbmFtZV0gIT09IHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVdpdGgobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBGb3JtYXRCbG90LnByb3RvdHlwZS5mb3JtYXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZm9ybWF0cyA9IHRoaXMuYXR0cmlidXRlcy52YWx1ZXMoKTtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuc3RhdGljcy5mb3JtYXRzKHRoaXMuZG9tTm9kZSk7XG4gICAgICAgIGlmIChmb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0c1t0aGlzLnN0YXRpY3MuYmxvdE5hbWVdID0gZm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgIH07XG4gICAgRm9ybWF0QmxvdC5wcm90b3R5cGUucmVwbGFjZVdpdGggPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gX3N1cGVyLnByb3RvdHlwZS5yZXBsYWNlV2l0aC5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLmNvcHkocmVwbGFjZW1lbnQpO1xuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gICAgfTtcbiAgICBGb3JtYXRCbG90LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobXV0YXRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgbXV0YXRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKG11dGF0aW9ucy5zb21lKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG11dGF0aW9uLnRhcmdldCA9PT0gX3RoaXMuZG9tTm9kZSAmJiBtdXRhdGlvbi50eXBlID09PSAnYXR0cmlidXRlcyc7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMuYnVpbGQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRm9ybWF0QmxvdC5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IF9zdXBlci5wcm90b3R5cGUud3JhcC5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgaWYgKHdyYXBwZXIgaW5zdGFuY2VvZiBGb3JtYXRCbG90ICYmIHdyYXBwZXIuc3RhdGljcy5zY29wZSA9PT0gdGhpcy5zdGF0aWNzLnNjb3BlKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMubW92ZSh3cmFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9O1xuICAgIHJldHVybiBGb3JtYXRCbG90O1xufShjb250YWluZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBGb3JtYXRCbG90O1xuXG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNoYWRvd18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG52YXIgUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIExlYWZCbG90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMZWFmQmxvdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMZWFmQmxvdCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBMZWFmQmxvdC52YWx1ZSA9IGZ1bmN0aW9uIChkb21Ob2RlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgTGVhZkJsb3QucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24gKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5kb21Ob2RlID09PSBub2RlIHx8XG4gICAgICAgICAgICB0aGlzLmRvbU5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKG9mZnNldCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgTGVhZkJsb3QucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24gKGluZGV4LCBpbmNsdXNpdmUpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IFtdLmluZGV4T2YuY2FsbCh0aGlzLnBhcmVudC5kb21Ob2RlLmNoaWxkTm9kZXMsIHRoaXMuZG9tTm9kZSk7XG4gICAgICAgIGlmIChpbmRleCA+IDApXG4gICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnBhcmVudC5kb21Ob2RlLCBvZmZzZXRdO1xuICAgIH07XG4gICAgTGVhZkJsb3QucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfYSA9IHt9LCBfYVt0aGlzLnN0YXRpY3MuYmxvdE5hbWVdID0gdGhpcy5zdGF0aWNzLnZhbHVlKHRoaXMuZG9tTm9kZSkgfHwgdHJ1ZSwgX2E7XG4gICAgfTtcbiAgICBMZWFmQmxvdC5zY29wZSA9IFJlZ2lzdHJ5LlNjb3BlLklOTElORV9CTE9UO1xuICAgIHJldHVybiBMZWFmQmxvdDtcbn0oc2hhZG93XzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTGVhZkJsb3Q7XG5cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZXF1YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbnZhciBleHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cbnZhciBsaWIgPSB7XG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBjb21wb3NlOiBmdW5jdGlvbiAoYSwgYiwga2VlcE51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPT0gJ29iamVjdCcpIGEgPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgYiAhPT0gJ29iamVjdCcpIGIgPSB7fTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gZXh0ZW5kKHRydWUsIHt9LCBiKTtcbiAgICAgIGlmICgha2VlcE51bGwpIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLnJlZHVjZShmdW5jdGlvbiAoY29weSwga2V5KSB7XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZXNba2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb3B5W2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9LCB7fSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICBpZiAoYVtrZXldICE9PSB1bmRlZmluZWQgJiYgYltrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSBhW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwID8gYXR0cmlidXRlcyA6IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgZGlmZjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYgKHR5cGVvZiBhICE9PSAnb2JqZWN0JykgYSA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBiICE9PSAnb2JqZWN0JykgYiA9IHt9O1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhhKS5jb25jYXQoT2JqZWN0LmtleXMoYikpLnJlZHVjZShmdW5jdGlvbiAoYXR0cmlidXRlcywga2V5KSB7XG4gICAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgYXR0cmlidXRlc1trZXldID0gYltrZXldID09PSB1bmRlZmluZWQgPyBudWxsIDogYltrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgfSwge30pO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDAgPyBhdHRyaWJ1dGVzIDogdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChhLCBiLCBwcmlvcml0eSkge1xuICAgICAgaWYgKHR5cGVvZiBhICE9PSAnb2JqZWN0JykgcmV0dXJuIGI7XG4gICAgICBpZiAodHlwZW9mIGIgIT09ICdvYmplY3QnKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgaWYgKCFwcmlvcml0eSkgcmV0dXJuIGI7ICAvLyBiIHNpbXBseSBvdmVyd3JpdGVzIHVzIHdpdGhvdXQgcHJpb3JpdHlcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoYikucmVkdWNlKGZ1bmN0aW9uIChhdHRyaWJ1dGVzLCBrZXkpIHtcbiAgICAgICAgaWYgKGFba2V5XSA9PT0gdW5kZWZpbmVkKSBhdHRyaWJ1dGVzW2tleV0gPSBiW2tleV07ICAvLyBudWxsIGlzIGEgdmFsaWQgdmFsdWVcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICB9LCB7fSk7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID4gMCA/IGF0dHJpYnV0ZXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuXG4gIGl0ZXJhdG9yOiBmdW5jdGlvbiAob3BzKSB7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihvcHMpO1xuICB9LFxuXG4gIGxlbmd0aDogZnVuY3Rpb24gKG9wKSB7XG4gICAgaWYgKHR5cGVvZiBvcFsnZGVsZXRlJ10gPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gb3BbJ2RlbGV0ZSddO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBvcC5yZXRhaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb3AuaW5zZXJ0ID09PSAnc3RyaW5nJyA/IG9wLmluc2VydC5sZW5ndGggOiAxO1xuICAgIH1cbiAgfVxufTtcblxuXG5mdW5jdGlvbiBJdGVyYXRvcihvcHMpIHtcbiAgdGhpcy5vcHMgPSBvcHM7XG4gIHRoaXMuaW5kZXggPSAwO1xuICB0aGlzLm9mZnNldCA9IDA7XG59O1xuXG5JdGVyYXRvci5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGVla0xlbmd0aCgpIDwgSW5maW5pdHk7XG59O1xuXG5JdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgaWYgKCFsZW5ndGgpIGxlbmd0aCA9IEluZmluaXR5O1xuICB2YXIgbmV4dE9wID0gdGhpcy5vcHNbdGhpcy5pbmRleF07XG4gIGlmIChuZXh0T3ApIHtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgdmFyIG9wTGVuZ3RoID0gbGliLmxlbmd0aChuZXh0T3ApXG4gICAgaWYgKGxlbmd0aCA+PSBvcExlbmd0aCAtIG9mZnNldCkge1xuICAgICAgbGVuZ3RoID0gb3BMZW5ndGggLSBvZmZzZXQ7XG4gICAgICB0aGlzLmluZGV4ICs9IDE7XG4gICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXh0T3BbJ2RlbGV0ZSddID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHsgJ2RlbGV0ZSc6IGxlbmd0aCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmV0T3AgPSB7fTtcbiAgICAgIGlmIChuZXh0T3AuYXR0cmlidXRlcykge1xuICAgICAgICByZXRPcC5hdHRyaWJ1dGVzID0gbmV4dE9wLmF0dHJpYnV0ZXM7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5leHRPcC5yZXRhaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldE9wLnJldGFpbiA9IGxlbmd0aDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRPcC5pbnNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldE9wLmluc2VydCA9IG5leHRPcC5pbnNlcnQuc3Vic3RyKG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9mZnNldCBzaG91bGQgPT09IDAsIGxlbmd0aCBzaG91bGQgPT09IDFcbiAgICAgICAgcmV0T3AuaW5zZXJ0ID0gbmV4dE9wLmluc2VydDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRPcDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgcmV0YWluOiBJbmZpbml0eSB9O1xuICB9XG59O1xuXG5JdGVyYXRvci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMub3BzW3RoaXMuaW5kZXhdO1xufTtcblxuSXRlcmF0b3IucHJvdG90eXBlLnBlZWtMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm9wc1t0aGlzLmluZGV4XSkge1xuICAgIC8vIFNob3VsZCBuZXZlciByZXR1cm4gMCBpZiBvdXIgaW5kZXggaXMgYmVpbmcgbWFuYWdlZCBjb3JyZWN0bHlcbiAgICByZXR1cm4gbGliLmxlbmd0aCh0aGlzLm9wc1t0aGlzLmluZGV4XSkgLSB0aGlzLm9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gSW5maW5pdHk7XG4gIH1cbn07XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5wZWVrVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMub3BzW3RoaXMuaW5kZXhdKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wc1t0aGlzLmluZGV4XVsnZGVsZXRlJ10gPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJ2RlbGV0ZSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5vcHNbdGhpcy5pbmRleF0ucmV0YWluID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICdyZXRhaW4nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ2luc2VydCc7XG4gICAgfVxuICB9XG4gIHJldHVybiAncmV0YWluJztcbn07XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5yZXN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaGFzTmV4dCgpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IGVsc2UgaWYgKHRoaXMub2Zmc2V0ID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMub3BzLnNsaWNlKHRoaXMuaW5kZXgpO1xuICB9IGVsc2Uge1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0KCk7XG4gICAgdmFyIHJlc3QgPSB0aGlzLm9wcy5zbGljZSh0aGlzLmluZGV4KTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgcmV0dXJuIFtuZXh0XS5jb25jYXQocmVzdCk7XG4gIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBsaWI7XG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgY2xvbmUgPSAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbnN0YW5jZW9mKG9iaiwgdHlwZSkge1xuICByZXR1cm4gdHlwZSAhPSBudWxsICYmIG9iaiBpbnN0YW5jZW9mIHR5cGU7XG59XG5cbnZhciBuYXRpdmVNYXA7XG50cnkge1xuICBuYXRpdmVNYXAgPSBNYXA7XG59IGNhdGNoKF8pIHtcbiAgLy8gbWF5YmUgYSByZWZlcmVuY2UgZXJyb3IgYmVjYXVzZSBubyBgTWFwYC4gR2l2ZSBpdCBhIGR1bW15IHZhbHVlIHRoYXQgbm9cbiAgLy8gdmFsdWUgd2lsbCBldmVyIGJlIGFuIGluc3RhbmNlb2YuXG4gIG5hdGl2ZU1hcCA9IGZ1bmN0aW9uKCkge307XG59XG5cbnZhciBuYXRpdmVTZXQ7XG50cnkge1xuICBuYXRpdmVTZXQgPSBTZXQ7XG59IGNhdGNoKF8pIHtcbiAgbmF0aXZlU2V0ID0gZnVuY3Rpb24oKSB7fTtcbn1cblxudmFyIG5hdGl2ZVByb21pc2U7XG50cnkge1xuICBuYXRpdmVQcm9taXNlID0gUHJvbWlzZTtcbn0gY2F0Y2goXykge1xuICBuYXRpdmVQcm9taXNlID0gZnVuY3Rpb24oKSB7fTtcbn1cblxuLyoqXG4gKiBDbG9uZXMgKGNvcGllcykgYW4gT2JqZWN0IHVzaW5nIGRlZXAgY29weWluZy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHN1cHBvcnRzIGNpcmN1bGFyIHJlZmVyZW5jZXMgYnkgZGVmYXVsdCwgYnV0IGlmIHlvdSBhcmUgY2VydGFpblxuICogdGhlcmUgYXJlIG5vIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4geW91ciBvYmplY3QsIHlvdSBjYW4gc2F2ZSBzb21lIENQVSB0aW1lXG4gKiBieSBjYWxsaW5nIGNsb25lKG9iaiwgZmFsc2UpLlxuICpcbiAqIENhdXRpb246IGlmIGBjaXJjdWxhcmAgaXMgZmFsc2UgYW5kIGBwYXJlbnRgIGNvbnRhaW5zIGNpcmN1bGFyIHJlZmVyZW5jZXMsXG4gKiB5b3VyIHByb2dyYW0gbWF5IGVudGVyIGFuIGluZmluaXRlIGxvb3AgYW5kIGNyYXNoLlxuICpcbiAqIEBwYXJhbSBgcGFyZW50YCAtIHRoZSBvYmplY3QgdG8gYmUgY2xvbmVkXG4gKiBAcGFyYW0gYGNpcmN1bGFyYCAtIHNldCB0byB0cnVlIGlmIHRoZSBvYmplY3QgdG8gYmUgY2xvbmVkIG1heSBjb250YWluXG4gKiAgICBjaXJjdWxhciByZWZlcmVuY2VzLiAob3B0aW9uYWwgLSB0cnVlIGJ5IGRlZmF1bHQpXG4gKiBAcGFyYW0gYGRlcHRoYCAtIHNldCB0byBhIG51bWJlciBpZiB0aGUgb2JqZWN0IGlzIG9ubHkgdG8gYmUgY2xvbmVkIHRvXG4gKiAgICBhIHBhcnRpY3VsYXIgZGVwdGguIChvcHRpb25hbCAtIGRlZmF1bHRzIHRvIEluZmluaXR5KVxuICogQHBhcmFtIGBwcm90b3R5cGVgIC0gc2V0cyB0aGUgcHJvdG90eXBlIHRvIGJlIHVzZWQgd2hlbiBjbG9uaW5nIGFuIG9iamVjdC5cbiAqICAgIChvcHRpb25hbCAtIGRlZmF1bHRzIHRvIHBhcmVudCBwcm90b3R5cGUpLlxuICogQHBhcmFtIGBpbmNsdWRlTm9uRW51bWVyYWJsZWAgLSBzZXQgdG8gdHJ1ZSBpZiB0aGUgbm9uLWVudW1lcmFibGUgcHJvcGVydGllc1xuICogICAgc2hvdWxkIGJlIGNsb25lZCBhcyB3ZWxsLiBOb24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9uIHRoZSBwcm90b3R5cGVcbiAqICAgIGNoYWluIHdpbGwgYmUgaWdub3JlZC4gKG9wdGlvbmFsIC0gZmFsc2UgYnkgZGVmYXVsdClcbiovXG5mdW5jdGlvbiBjbG9uZShwYXJlbnQsIGNpcmN1bGFyLCBkZXB0aCwgcHJvdG90eXBlLCBpbmNsdWRlTm9uRW51bWVyYWJsZSkge1xuICBpZiAodHlwZW9mIGNpcmN1bGFyID09PSAnb2JqZWN0Jykge1xuICAgIGRlcHRoID0gY2lyY3VsYXIuZGVwdGg7XG4gICAgcHJvdG90eXBlID0gY2lyY3VsYXIucHJvdG90eXBlO1xuICAgIGluY2x1ZGVOb25FbnVtZXJhYmxlID0gY2lyY3VsYXIuaW5jbHVkZU5vbkVudW1lcmFibGU7XG4gICAgY2lyY3VsYXIgPSBjaXJjdWxhci5jaXJjdWxhcjtcbiAgfVxuICAvLyBtYWludGFpbiB0d28gYXJyYXlzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzLCB3aGVyZSBjb3JyZXNwb25kaW5nIHBhcmVudHNcbiAgLy8gYW5kIGNoaWxkcmVuIGhhdmUgdGhlIHNhbWUgaW5kZXhcbiAgdmFyIGFsbFBhcmVudHMgPSBbXTtcbiAgdmFyIGFsbENoaWxkcmVuID0gW107XG5cbiAgdmFyIHVzZUJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgIT0gJ3VuZGVmaW5lZCc7XG5cbiAgaWYgKHR5cGVvZiBjaXJjdWxhciA9PSAndW5kZWZpbmVkJylcbiAgICBjaXJjdWxhciA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBkZXB0aCA9PSAndW5kZWZpbmVkJylcbiAgICBkZXB0aCA9IEluZmluaXR5O1xuXG4gIC8vIHJlY3Vyc2UgdGhpcyBmdW5jdGlvbiBzbyB3ZSBkb24ndCByZXNldCBhbGxQYXJlbnRzIGFuZCBhbGxDaGlsZHJlblxuICBmdW5jdGlvbiBfY2xvbmUocGFyZW50LCBkZXB0aCkge1xuICAgIC8vIGNsb25pbmcgbnVsbCBhbHdheXMgcmV0dXJucyBudWxsXG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbClcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgaWYgKGRlcHRoID09PSAwKVxuICAgICAgcmV0dXJuIHBhcmVudDtcblxuICAgIHZhciBjaGlsZDtcbiAgICB2YXIgcHJvdG87XG4gICAgaWYgKHR5cGVvZiBwYXJlbnQgIT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlTWFwKSkge1xuICAgICAgY2hpbGQgPSBuZXcgbmF0aXZlTWFwKCk7XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVNldCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IG5hdGl2ZVNldCgpO1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVQcm9taXNlKSkge1xuICAgICAgY2hpbGQgPSBuZXcgbmF0aXZlUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHBhcmVudC50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmVzb2x2ZShfY2xvbmUodmFsdWUsIGRlcHRoIC0gMSkpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICByZWplY3QoX2Nsb25lKGVyciwgZGVwdGggLSAxKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzQXJyYXkocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBbXTtcbiAgICB9IGVsc2UgaWYgKGNsb25lLl9faXNSZWdFeHAocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBuZXcgUmVnRXhwKHBhcmVudC5zb3VyY2UsIF9fZ2V0UmVnRXhwRmxhZ3MocGFyZW50KSk7XG4gICAgICBpZiAocGFyZW50Lmxhc3RJbmRleCkgY2hpbGQubGFzdEluZGV4ID0gcGFyZW50Lmxhc3RJbmRleDtcbiAgICB9IGVsc2UgaWYgKGNsb25lLl9faXNEYXRlKHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IERhdGUocGFyZW50LmdldFRpbWUoKSk7XG4gICAgfSBlbHNlIGlmICh1c2VCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKHBhcmVudCkpIHtcbiAgICAgIGlmIChCdWZmZXIuYWxsb2NVbnNhZmUpIHtcbiAgICAgICAgLy8gTm9kZS5qcyA+PSA0LjUuMFxuICAgICAgICBjaGlsZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShwYXJlbnQubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE9sZGVyIE5vZGUuanMgdmVyc2lvbnNcbiAgICAgICAgY2hpbGQgPSBuZXcgQnVmZmVyKHBhcmVudC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgcGFyZW50LmNvcHkoY2hpbGQpO1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBFcnJvcikpIHtcbiAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHByb3RvdHlwZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXJlbnQpO1xuICAgICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocHJvdG8pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgICBwcm90byA9IHByb3RvdHlwZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2lyY3VsYXIpIHtcbiAgICAgIHZhciBpbmRleCA9IGFsbFBhcmVudHMuaW5kZXhPZihwYXJlbnQpO1xuXG4gICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGFsbENoaWxkcmVuW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGFsbFBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgYWxsQ2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlTWFwKSkge1xuICAgICAgcGFyZW50LmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICB2YXIga2V5Q2hpbGQgPSBfY2xvbmUoa2V5LCBkZXB0aCAtIDEpO1xuICAgICAgICB2YXIgdmFsdWVDaGlsZCA9IF9jbG9uZSh2YWx1ZSwgZGVwdGggLSAxKTtcbiAgICAgICAgY2hpbGQuc2V0KGtleUNoaWxkLCB2YWx1ZUNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVTZXQpKSB7XG4gICAgICBwYXJlbnQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgZW50cnlDaGlsZCA9IF9jbG9uZSh2YWx1ZSwgZGVwdGggLSAxKTtcbiAgICAgICAgY2hpbGQuYWRkKGVudHJ5Q2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSBpbiBwYXJlbnQpIHtcbiAgICAgIHZhciBhdHRycztcbiAgICAgIGlmIChwcm90bykge1xuICAgICAgICBhdHRycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cnMgJiYgYXR0cnMuc2V0ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjaGlsZFtpXSA9IF9jbG9uZShwYXJlbnRbaV0sIGRlcHRoIC0gMSk7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhwYXJlbnQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIERvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgY2xvbmluZyBhIHN5bWJvbCBiZWNhdXNlIGl0IGlzIGEgcHJpbWl0aXZlLFxuICAgICAgICAvLyBsaWtlIGEgbnVtYmVyIG9yIHN0cmluZy5cbiAgICAgICAgdmFyIHN5bWJvbCA9IHN5bWJvbHNbaV07XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIHN5bWJvbCk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLmVudW1lcmFibGUgJiYgIWluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRbc3ltYm9sXSA9IF9jbG9uZShwYXJlbnRbc3ltYm9sXSwgZGVwdGggLSAxKTtcbiAgICAgICAgaWYgKCFkZXNjcmlwdG9yLmVudW1lcmFibGUpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hpbGQsIHN5bWJvbCwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbmNsdWRlTm9uRW51bWVyYWJsZSkge1xuICAgICAgdmFyIGFsbFByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwYXJlbnQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxQcm9wZXJ0eU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBhbGxQcm9wZXJ0eU5hbWVzW2ldO1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZFtwcm9wZXJ0eU5hbWVdID0gX2Nsb25lKHBhcmVudFtwcm9wZXJ0eU5hbWVdLCBkZXB0aCAtIDEpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hpbGQsIHByb3BlcnR5TmFtZSwge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuXG4gIHJldHVybiBfY2xvbmUocGFyZW50LCBkZXB0aCk7XG59XG5cbi8qKlxuICogU2ltcGxlIGZsYXQgY2xvbmUgdXNpbmcgcHJvdG90eXBlLCBhY2NlcHRzIG9ubHkgb2JqZWN0cywgdXNlZnVsbCBmb3IgcHJvcGVydHlcbiAqIG92ZXJyaWRlIG9uIEZMQVQgY29uZmlndXJhdGlvbiBvYmplY3QgKG5vIG5lc3RlZCBwcm9wcykuXG4gKlxuICogVVNFIFdJVEggQ0FVVElPTiEgVGhpcyBtYXkgbm90IGJlaGF2ZSBhcyB5b3Ugd2lzaCBpZiB5b3UgZG8gbm90IGtub3cgaG93IHRoaXNcbiAqIHdvcmtzLlxuICovXG5jbG9uZS5jbG9uZVByb3RvdHlwZSA9IGZ1bmN0aW9uIGNsb25lUHJvdG90eXBlKHBhcmVudCkge1xuICBpZiAocGFyZW50ID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciBjID0gZnVuY3Rpb24gKCkge307XG4gIGMucHJvdG90eXBlID0gcGFyZW50O1xuICByZXR1cm4gbmV3IGMoKTtcbn07XG5cbi8vIHByaXZhdGUgdXRpbGl0eSBmdW5jdGlvbnNcblxuZnVuY3Rpb24gX19vYmpUb1N0cihvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5jbG9uZS5fX29ialRvU3RyID0gX19vYmpUb1N0cjtcblxuZnVuY3Rpb24gX19pc0RhdGUobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmNsb25lLl9faXNEYXRlID0gX19pc0RhdGU7XG5cbmZ1bmN0aW9uIF9faXNBcnJheShvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cihvKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmNsb25lLl9faXNBcnJheSA9IF9faXNBcnJheTtcblxuZnVuY3Rpb24gX19pc1JlZ0V4cChvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cihvKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5jbG9uZS5fX2lzUmVnRXhwID0gX19pc1JlZ0V4cDtcblxuZnVuY3Rpb24gX19nZXRSZWdFeHBGbGFncyhyZSkge1xuICB2YXIgZmxhZ3MgPSAnJztcbiAgaWYgKHJlLmdsb2JhbCkgZmxhZ3MgKz0gJ2cnO1xuICBpZiAocmUuaWdub3JlQ2FzZSkgZmxhZ3MgKz0gJ2knO1xuICBpZiAocmUubXVsdGlsaW5lKSBmbGFncyArPSAnbSc7XG4gIHJldHVybiBmbGFncztcbn1cbmNsb25lLl9fZ2V0UmVnRXhwRmxhZ3MgPSBfX2dldFJlZ0V4cEZsYWdzO1xuXG5yZXR1cm4gY2xvbmU7XG59KSgpO1xuXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfZW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBfZW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbWl0dGVyKTtcblxudmFyIF9ibG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfYmxvY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmxvY2spO1xuXG52YXIgX2JyZWFrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBfYnJlYWsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJlYWspO1xuXG52YXIgX2NvZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIF9jb2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvZGUpO1xuXG52YXIgX2NvbnRhaW5lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG52YXIgX2NvbnRhaW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250YWluZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIGlzTGluZShibG90KSB7XG4gIHJldHVybiBibG90IGluc3RhbmNlb2YgX2Jsb2NrMi5kZWZhdWx0IHx8IGJsb3QgaW5zdGFuY2VvZiBfYmxvY2suQmxvY2tFbWJlZDtcbn1cblxudmFyIFNjcm9sbCA9IGZ1bmN0aW9uIChfUGFyY2htZW50JFNjcm9sbCkge1xuICBfaW5oZXJpdHMoU2Nyb2xsLCBfUGFyY2htZW50JFNjcm9sbCk7XG5cbiAgZnVuY3Rpb24gU2Nyb2xsKGRvbU5vZGUsIGNvbmZpZykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY3JvbGwpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFNjcm9sbC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcm9sbCkpLmNhbGwodGhpcywgZG9tTm9kZSkpO1xuXG4gICAgX3RoaXMuZW1pdHRlciA9IGNvbmZpZy5lbWl0dGVyO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy53aGl0ZWxpc3QpKSB7XG4gICAgICBfdGhpcy53aGl0ZWxpc3QgPSBjb25maWcud2hpdGVsaXN0LnJlZHVjZShmdW5jdGlvbiAod2hpdGVsaXN0LCBmb3JtYXQpIHtcbiAgICAgICAgd2hpdGVsaXN0W2Zvcm1hdF0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gd2hpdGVsaXN0O1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvLyBTb21lIHJlYXNvbiBmaXhlcyBjb21wb3NpdGlvbiBpc3N1ZXMgd2l0aCBjaGFyYWN0ZXIgbGFuZ3VhZ2VzIGluIFdpbmRvd3MvQ2hyb21lLCBTYWZhcmlcbiAgICBfdGhpcy5kb21Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVJbnNlcnRlZCcsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICBfdGhpcy5vcHRpbWl6ZSgpO1xuICAgIF90aGlzLmVuYWJsZSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTY3JvbGwsIFt7XG4gICAga2V5OiAnYmF0Y2hTdGFydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhdGNoU3RhcnQoKSB7XG4gICAgICB0aGlzLmJhdGNoID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdiYXRjaEVuZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhdGNoRW5kKCkge1xuICAgICAgdGhpcy5iYXRjaCA9IGZhbHNlO1xuICAgICAgdGhpcy5vcHRpbWl6ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZUF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQXQoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgdmFyIF9saW5lID0gdGhpcy5saW5lKGluZGV4KSxcbiAgICAgICAgICBfbGluZTIgPSBfc2xpY2VkVG9BcnJheShfbGluZSwgMiksXG4gICAgICAgICAgZmlyc3QgPSBfbGluZTJbMF0sXG4gICAgICAgICAgb2Zmc2V0ID0gX2xpbmUyWzFdO1xuXG4gICAgICB2YXIgX2xpbmUzID0gdGhpcy5saW5lKGluZGV4ICsgbGVuZ3RoKSxcbiAgICAgICAgICBfbGluZTQgPSBfc2xpY2VkVG9BcnJheShfbGluZTMsIDEpLFxuICAgICAgICAgIGxhc3QgPSBfbGluZTRbMF07XG5cbiAgICAgIF9nZXQoU2Nyb2xsLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcm9sbC5wcm90b3R5cGUpLCAnZGVsZXRlQXQnLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgaWYgKGxhc3QgIT0gbnVsbCAmJiBmaXJzdCAhPT0gbGFzdCAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIF9ibG9jay5CbG9ja0VtYmVkIHx8IGxhc3QgaW5zdGFuY2VvZiBfYmxvY2suQmxvY2tFbWJlZCkge1xuICAgICAgICAgIHRoaXMub3B0aW1pemUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0IGluc3RhbmNlb2YgX2NvZGUyLmRlZmF1bHQpIHtcbiAgICAgICAgICB2YXIgbmV3bGluZUluZGV4ID0gZmlyc3QubmV3bGluZUluZGV4KGZpcnN0Lmxlbmd0aCgpLCB0cnVlKTtcbiAgICAgICAgICBpZiAobmV3bGluZUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGZpcnN0ID0gZmlyc3Quc3BsaXQobmV3bGluZUluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZiAoZmlyc3QgPT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgdGhpcy5vcHRpbWl6ZSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxhc3QgaW5zdGFuY2VvZiBfY29kZTIuZGVmYXVsdCkge1xuICAgICAgICAgIHZhciBfbmV3bGluZUluZGV4ID0gbGFzdC5uZXdsaW5lSW5kZXgoMCk7XG4gICAgICAgICAgaWYgKF9uZXdsaW5lSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgbGFzdC5zcGxpdChfbmV3bGluZUluZGV4ICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZWYgPSBsYXN0LmNoaWxkcmVuLmhlYWQgaW5zdGFuY2VvZiBfYnJlYWsyLmRlZmF1bHQgPyBudWxsIDogbGFzdC5jaGlsZHJlbi5oZWFkO1xuICAgICAgICBmaXJzdC5tb3ZlQ2hpbGRyZW4obGFzdCwgcmVmKTtcbiAgICAgICAgZmlyc3QucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wdGltaXplKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgdmFyIGVuYWJsZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG5cbiAgICAgIHRoaXMuZG9tTm9kZS5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIGVuYWJsZWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdEF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgZm9ybWF0LCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMud2hpdGVsaXN0ICE9IG51bGwgJiYgIXRoaXMud2hpdGVsaXN0W2Zvcm1hdF0pIHJldHVybjtcbiAgICAgIF9nZXQoU2Nyb2xsLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcm9sbC5wcm90b3R5cGUpLCAnZm9ybWF0QXQnLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgsIGZvcm1hdCwgdmFsdWUpO1xuICAgICAgdGhpcy5vcHRpbWl6ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydEF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QXQoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICAgIGlmIChkZWYgIT0gbnVsbCAmJiB0aGlzLndoaXRlbGlzdCAhPSBudWxsICYmICF0aGlzLndoaXRlbGlzdFt2YWx1ZV0pIHJldHVybjtcbiAgICAgIGlmIChpbmRleCA+PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgIGlmIChkZWYgPT0gbnVsbCB8fCBfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KHZhbHVlLCBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLKSA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGJsb3QgPSBfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZSh0aGlzLnN0YXRpY3MuZGVmYXVsdENoaWxkKTtcbiAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGJsb3QpO1xuICAgICAgICAgIGlmIChkZWYgPT0gbnVsbCAmJiB2YWx1ZS5lbmRzV2l0aCgnXFxuJykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBibG90Lmluc2VydEF0KDAsIHZhbHVlLCBkZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbWJlZCA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKHZhbHVlLCBkZWYpO1xuICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZW1iZWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0KFNjcm9sbC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTY3JvbGwucHJvdG90eXBlKSwgJ2luc2VydEF0JywgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgdmFsdWUsIGRlZik7XG4gICAgICB9XG4gICAgICB0aGlzLm9wdGltaXplKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0QmVmb3JlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKGJsb3QsIHJlZikge1xuICAgICAgaWYgKGJsb3Quc3RhdGljcy5zY29wZSA9PT0gX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5JTkxJTkVfQkxPVCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKHRoaXMuc3RhdGljcy5kZWZhdWx0Q2hpbGQpO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGJsb3QpO1xuICAgICAgICBibG90ID0gd3JhcHBlcjtcbiAgICAgIH1cbiAgICAgIF9nZXQoU2Nyb2xsLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcm9sbC5wcm90b3R5cGUpLCAnaW5zZXJ0QmVmb3JlJywgdGhpcykuY2FsbCh0aGlzLCBibG90LCByZWYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xlYWYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZWFmKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoKGluZGV4KS5wb3AoKSB8fCBbbnVsbCwgLTFdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xpbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5lKGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPT09IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZShpbmRleCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZGVzY2VuZGFudChpc0xpbmUsIGluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsaW5lcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmVzKCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgdmFyIGdldExpbmVzID0gZnVuY3Rpb24gZ2V0TGluZXMoYmxvdCwgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgICB2YXIgbGluZXMgPSBbXSxcbiAgICAgICAgICAgIGxlbmd0aExlZnQgPSBsZW5ndGg7XG4gICAgICAgIGJsb3QuY2hpbGRyZW4uZm9yRWFjaEF0KGluZGV4LCBsZW5ndGgsIGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgICAgIGlmIChpc0xpbmUoY2hpbGQpKSB7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgX3BhcmNobWVudDIuZGVmYXVsdC5Db250YWluZXIpIHtcbiAgICAgICAgICAgIGxpbmVzID0gbGluZXMuY29uY2F0KGdldExpbmVzKGNoaWxkLCBpbmRleCwgbGVuZ3RoTGVmdCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGhMZWZ0IC09IGxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICAgIH07XG4gICAgICByZXR1cm4gZ2V0TGluZXModGhpcywgaW5kZXgsIGxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb3B0aW1pemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpbWl6ZSgpIHtcbiAgICAgIHZhciBtdXRhdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBpZiAodGhpcy5iYXRjaCA9PT0gdHJ1ZSkgcmV0dXJuO1xuICAgICAgX2dldChTY3JvbGwucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2Nyb2xsLnByb3RvdHlwZSksICdvcHRpbWl6ZScsIHRoaXMpLmNhbGwodGhpcywgbXV0YXRpb25zLCBjb250ZXh0KTtcbiAgICAgIGlmIChtdXRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChfZW1pdHRlcjIuZGVmYXVsdC5ldmVudHMuU0NST0xMX09QVElNSVpFLCBtdXRhdGlvbnMsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BhdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoKGluZGV4KSB7XG4gICAgICByZXR1cm4gX2dldChTY3JvbGwucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2Nyb2xsLnByb3RvdHlwZSksICdwYXRoJywgdGhpcykuY2FsbCh0aGlzLCBpbmRleCkuc2xpY2UoMSk7IC8vIEV4Y2x1ZGUgc2VsZlxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShtdXRhdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmJhdGNoID09PSB0cnVlKSByZXR1cm47XG4gICAgICB2YXIgc291cmNlID0gX2VtaXR0ZXIyLmRlZmF1bHQuc291cmNlcy5VU0VSO1xuICAgICAgaWYgKHR5cGVvZiBtdXRhdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNvdXJjZSA9IG11dGF0aW9ucztcbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShtdXRhdGlvbnMpKSB7XG4gICAgICAgIG11dGF0aW9ucyA9IHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChtdXRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChfZW1pdHRlcjIuZGVmYXVsdC5ldmVudHMuU0NST0xMX0JFRk9SRV9VUERBVEUsIHNvdXJjZSwgbXV0YXRpb25zKTtcbiAgICAgIH1cbiAgICAgIF9nZXQoU2Nyb2xsLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcm9sbC5wcm90b3R5cGUpLCAndXBkYXRlJywgdGhpcykuY2FsbCh0aGlzLCBtdXRhdGlvbnMuY29uY2F0KFtdKSk7IC8vIHBhc3MgY29weVxuICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KF9lbWl0dGVyMi5kZWZhdWx0LmV2ZW50cy5TQ1JPTExfVVBEQVRFLCBzb3VyY2UsIG11dGF0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNjcm9sbDtcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5TY3JvbGwpO1xuXG5TY3JvbGwuYmxvdE5hbWUgPSAnc2Nyb2xsJztcblNjcm9sbC5jbGFzc05hbWUgPSAncWwtZWRpdG9yJztcblNjcm9sbC50YWdOYW1lID0gJ0RJVic7XG5TY3JvbGwuZGVmYXVsdENoaWxkID0gJ2Jsb2NrJztcblNjcm9sbC5hbGxvd2VkQ2hpbGRyZW4gPSBbX2Jsb2NrMi5kZWZhdWx0LCBfYmxvY2suQmxvY2tFbWJlZCwgX2NvbnRhaW5lcjIuZGVmYXVsdF07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNjcm9sbDtcblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5TSE9SVEtFWSA9IGV4cG9ydHMuZGVmYXVsdCA9IHVuZGVmaW5lZDtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfY2xvbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblxudmFyIF9jbG9uZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9uZSk7XG5cbnZhciBfZGVlcEVxdWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBfZGVlcEVxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZXBFcXVhbCk7XG5cbnZhciBfZXh0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9leHRlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXh0ZW5kKTtcblxudmFyIF9xdWlsbERlbHRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9xdWlsbERlbHRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsRGVsdGEpO1xuXG52YXIgX29wID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBfb3AyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb3ApO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfcXVpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX3F1aWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsKTtcblxudmFyIF9sb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIF9sb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nZ2VyKTtcblxudmFyIF9tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX21vZHVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb2R1bGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBkZWJ1ZyA9ICgwLCBfbG9nZ2VyMi5kZWZhdWx0KSgncXVpbGw6a2V5Ym9hcmQnKTtcblxudmFyIFNIT1JUS0VZID0gL01hYy9pLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSA/ICdtZXRhS2V5JyA6ICdjdHJsS2V5JztcblxudmFyIEtleWJvYXJkID0gZnVuY3Rpb24gKF9Nb2R1bGUpIHtcbiAgX2luaGVyaXRzKEtleWJvYXJkLCBfTW9kdWxlKTtcblxuICBfY3JlYXRlQ2xhc3MoS2V5Ym9hcmQsIG51bGwsIFt7XG4gICAga2V5OiAnbWF0Y2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaChldnQsIGJpbmRpbmcpIHtcbiAgICAgIGJpbmRpbmcgPSBub3JtYWxpemUoYmluZGluZyk7XG4gICAgICBpZiAoWydhbHRLZXknLCAnY3RybEtleScsICdtZXRhS2V5JywgJ3NoaWZ0S2V5J10uc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWJpbmRpbmdba2V5XSAhPT0gZXZ0W2tleV0gJiYgYmluZGluZ1trZXldICE9PSBudWxsO1xuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpbmRpbmcua2V5ID09PSAoZXZ0LndoaWNoIHx8IGV2dC5rZXlDb2RlKTtcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBLZXlib2FyZChxdWlsbCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBLZXlib2FyZCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoS2V5Ym9hcmQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihLZXlib2FyZCkpLmNhbGwodGhpcywgcXVpbGwsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmJpbmRpbmdzID0ge307XG4gICAgT2JqZWN0LmtleXMoX3RoaXMub3B0aW9ucy5iaW5kaW5ncykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKG5hbWUgPT09ICdsaXN0IGF1dG9maWxsJyAmJiBxdWlsbC5zY3JvbGwud2hpdGVsaXN0ICE9IG51bGwgJiYgIXF1aWxsLnNjcm9sbC53aGl0ZWxpc3RbJ2xpc3QnXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoX3RoaXMub3B0aW9ucy5iaW5kaW5nc1tuYW1lXSkge1xuICAgICAgICBfdGhpcy5hZGRCaW5kaW5nKF90aGlzLm9wdGlvbnMuYmluZGluZ3NbbmFtZV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF90aGlzLmFkZEJpbmRpbmcoeyBrZXk6IEtleWJvYXJkLmtleXMuRU5URVIsIHNoaWZ0S2V5OiBudWxsIH0sIGhhbmRsZUVudGVyKTtcbiAgICBfdGhpcy5hZGRCaW5kaW5nKHsga2V5OiBLZXlib2FyZC5rZXlzLkVOVEVSLCBtZXRhS2V5OiBudWxsLCBjdHJsS2V5OiBudWxsLCBhbHRLZXk6IG51bGwgfSwgZnVuY3Rpb24gKCkge30pO1xuICAgIGlmICgvRmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIC8vIE5lZWQgdG8gaGFuZGxlIGRlbGV0ZSBhbmQgYmFja3NwYWNlIGZvciBGaXJlZm94IGluIHRoZSBnZW5lcmFsIGNhc2UgIzExNzFcbiAgICAgIF90aGlzLmFkZEJpbmRpbmcoeyBrZXk6IEtleWJvYXJkLmtleXMuQkFDS1NQQUNFIH0sIHsgY29sbGFwc2VkOiB0cnVlIH0sIGhhbmRsZUJhY2tzcGFjZSk7XG4gICAgICBfdGhpcy5hZGRCaW5kaW5nKHsga2V5OiBLZXlib2FyZC5rZXlzLkRFTEVURSB9LCB7IGNvbGxhcHNlZDogdHJ1ZSB9LCBoYW5kbGVEZWxldGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5hZGRCaW5kaW5nKHsga2V5OiBLZXlib2FyZC5rZXlzLkJBQ0tTUEFDRSB9LCB7IGNvbGxhcHNlZDogdHJ1ZSwgcHJlZml4OiAvXi4/JC8gfSwgaGFuZGxlQmFja3NwYWNlKTtcbiAgICAgIF90aGlzLmFkZEJpbmRpbmcoeyBrZXk6IEtleWJvYXJkLmtleXMuREVMRVRFIH0sIHsgY29sbGFwc2VkOiB0cnVlLCBzdWZmaXg6IC9eLj8kLyB9LCBoYW5kbGVEZWxldGUpO1xuICAgIH1cbiAgICBfdGhpcy5hZGRCaW5kaW5nKHsga2V5OiBLZXlib2FyZC5rZXlzLkJBQ0tTUEFDRSB9LCB7IGNvbGxhcHNlZDogZmFsc2UgfSwgaGFuZGxlRGVsZXRlUmFuZ2UpO1xuICAgIF90aGlzLmFkZEJpbmRpbmcoeyBrZXk6IEtleWJvYXJkLmtleXMuREVMRVRFIH0sIHsgY29sbGFwc2VkOiBmYWxzZSB9LCBoYW5kbGVEZWxldGVSYW5nZSk7XG4gICAgX3RoaXMuYWRkQmluZGluZyh7IGtleTogS2V5Ym9hcmQua2V5cy5CQUNLU1BBQ0UsIGFsdEtleTogbnVsbCwgY3RybEtleTogbnVsbCwgbWV0YUtleTogbnVsbCwgc2hpZnRLZXk6IG51bGwgfSwgeyBjb2xsYXBzZWQ6IHRydWUsIG9mZnNldDogMCB9LCBoYW5kbGVCYWNrc3BhY2UpO1xuICAgIF90aGlzLmxpc3RlbigpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhLZXlib2FyZCwgW3tcbiAgICBrZXk6ICdhZGRCaW5kaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQmluZGluZyhrZXkpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBoYW5kbGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgdmFyIGJpbmRpbmcgPSBub3JtYWxpemUoa2V5KTtcbiAgICAgIGlmIChiaW5kaW5nID09IG51bGwgfHwgYmluZGluZy5rZXkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGVidWcud2FybignQXR0ZW1wdGVkIHRvIGFkZCBpbnZhbGlkIGtleWJvYXJkIGJpbmRpbmcnLCBiaW5kaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb250ZXh0ID0geyBoYW5kbGVyOiBjb250ZXh0IH07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaGFuZGxlciA9IHsgaGFuZGxlcjogaGFuZGxlciB9O1xuICAgICAgfVxuICAgICAgYmluZGluZyA9ICgwLCBfZXh0ZW5kMi5kZWZhdWx0KShiaW5kaW5nLCBjb250ZXh0LCBoYW5kbGVyKTtcbiAgICAgIHRoaXMuYmluZGluZ3NbYmluZGluZy5rZXldID0gdGhpcy5iaW5kaW5nc1tiaW5kaW5nLmtleV0gfHwgW107XG4gICAgICB0aGlzLmJpbmRpbmdzW2JpbmRpbmcua2V5XS5wdXNoKGJpbmRpbmcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xpc3RlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RlbigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLnF1aWxsLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgaWYgKGV2dC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICAgIHZhciB3aGljaCA9IGV2dC53aGljaCB8fCBldnQua2V5Q29kZTtcbiAgICAgICAgdmFyIGJpbmRpbmdzID0gKF90aGlzMi5iaW5kaW5nc1t3aGljaF0gfHwgW10pLmZpbHRlcihmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgICAgIHJldHVybiBLZXlib2FyZC5tYXRjaChldnQsIGJpbmRpbmcpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGJpbmRpbmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICB2YXIgcmFuZ2UgPSBfdGhpczIucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmIChyYW5nZSA9PSBudWxsIHx8ICFfdGhpczIucXVpbGwuaGFzRm9jdXMoKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBfcXVpbGwkZ2V0TGluZSA9IF90aGlzMi5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4KSxcbiAgICAgICAgICAgIF9xdWlsbCRnZXRMaW5lMiA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRnZXRMaW5lLCAyKSxcbiAgICAgICAgICAgIGxpbmUgPSBfcXVpbGwkZ2V0TGluZTJbMF0sXG4gICAgICAgICAgICBvZmZzZXQgPSBfcXVpbGwkZ2V0TGluZTJbMV07XG5cbiAgICAgICAgdmFyIF9xdWlsbCRnZXRMZWFmID0gX3RoaXMyLnF1aWxsLmdldExlYWYocmFuZ2UuaW5kZXgpLFxuICAgICAgICAgICAgX3F1aWxsJGdldExlYWYyID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExlYWYsIDIpLFxuICAgICAgICAgICAgbGVhZlN0YXJ0ID0gX3F1aWxsJGdldExlYWYyWzBdLFxuICAgICAgICAgICAgb2Zmc2V0U3RhcnQgPSBfcXVpbGwkZ2V0TGVhZjJbMV07XG5cbiAgICAgICAgdmFyIF9yZWYgPSByYW5nZS5sZW5ndGggPT09IDAgPyBbbGVhZlN0YXJ0LCBvZmZzZXRTdGFydF0gOiBfdGhpczIucXVpbGwuZ2V0TGVhZihyYW5nZS5pbmRleCArIHJhbmdlLmxlbmd0aCksXG4gICAgICAgICAgICBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgbGVhZkVuZCA9IF9yZWYyWzBdLFxuICAgICAgICAgICAgb2Zmc2V0RW5kID0gX3JlZjJbMV07XG5cbiAgICAgICAgdmFyIHByZWZpeFRleHQgPSBsZWFmU3RhcnQgaW5zdGFuY2VvZiBfcGFyY2htZW50Mi5kZWZhdWx0LlRleHQgPyBsZWFmU3RhcnQudmFsdWUoKS5zbGljZSgwLCBvZmZzZXRTdGFydCkgOiAnJztcbiAgICAgICAgdmFyIHN1ZmZpeFRleHQgPSBsZWFmRW5kIGluc3RhbmNlb2YgX3BhcmNobWVudDIuZGVmYXVsdC5UZXh0ID8gbGVhZkVuZC52YWx1ZSgpLnNsaWNlKG9mZnNldEVuZCkgOiAnJztcbiAgICAgICAgdmFyIGN1ckNvbnRleHQgPSB7XG4gICAgICAgICAgY29sbGFwc2VkOiByYW5nZS5sZW5ndGggPT09IDAsXG4gICAgICAgICAgZW1wdHk6IHJhbmdlLmxlbmd0aCA9PT0gMCAmJiBsaW5lLmxlbmd0aCgpIDw9IDEsXG4gICAgICAgICAgZm9ybWF0OiBfdGhpczIucXVpbGwuZ2V0Rm9ybWF0KHJhbmdlKSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICBwcmVmaXg6IHByZWZpeFRleHQsXG4gICAgICAgICAgc3VmZml4OiBzdWZmaXhUZXh0XG4gICAgICAgIH07XG4gICAgICAgIHZhciBwcmV2ZW50ZWQgPSBiaW5kaW5ncy5zb21lKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgaWYgKGJpbmRpbmcuY29sbGFwc2VkICE9IG51bGwgJiYgYmluZGluZy5jb2xsYXBzZWQgIT09IGN1ckNvbnRleHQuY29sbGFwc2VkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgaWYgKGJpbmRpbmcuZW1wdHkgIT0gbnVsbCAmJiBiaW5kaW5nLmVtcHR5ICE9PSBjdXJDb250ZXh0LmVtcHR5KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgaWYgKGJpbmRpbmcub2Zmc2V0ICE9IG51bGwgJiYgYmluZGluZy5vZmZzZXQgIT09IGN1ckNvbnRleHQub2Zmc2V0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZy5mb3JtYXQpKSB7XG4gICAgICAgICAgICAvLyBhbnkgZm9ybWF0IGlzIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChiaW5kaW5nLmZvcm1hdC5ldmVyeShmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gY3VyQ29udGV4dC5mb3JtYXRbbmFtZV0gPT0gbnVsbDtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2YoYmluZGluZy5mb3JtYXQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gYWxsIGZvcm1hdHMgbXVzdCBtYXRjaFxuICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhiaW5kaW5nLmZvcm1hdCkuZXZlcnkoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuZm9ybWF0W25hbWVdID09PSB0cnVlKSByZXR1cm4gY3VyQ29udGV4dC5mb3JtYXRbbmFtZV0gIT0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuZm9ybWF0W25hbWVdID09PSBmYWxzZSkgcmV0dXJuIGN1ckNvbnRleHQuZm9ybWF0W25hbWVdID09IG51bGw7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgX2RlZXBFcXVhbDIuZGVmYXVsdCkoYmluZGluZy5mb3JtYXRbbmFtZV0sIGN1ckNvbnRleHQuZm9ybWF0W25hbWVdKTtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJpbmRpbmcucHJlZml4ICE9IG51bGwgJiYgIWJpbmRpbmcucHJlZml4LnRlc3QoY3VyQ29udGV4dC5wcmVmaXgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgaWYgKGJpbmRpbmcuc3VmZml4ICE9IG51bGwgJiYgIWJpbmRpbmcuc3VmZml4LnRlc3QoY3VyQ29udGV4dC5zdWZmaXgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGJpbmRpbmcuaGFuZGxlci5jYWxsKF90aGlzMiwgcmFuZ2UsIGN1ckNvbnRleHQpICE9PSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByZXZlbnRlZCkge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gS2V5Ym9hcmQ7XG59KF9tb2R1bGUyLmRlZmF1bHQpO1xuXG5LZXlib2FyZC5rZXlzID0ge1xuICBCQUNLU1BBQ0U6IDgsXG4gIFRBQjogOSxcbiAgRU5URVI6IDEzLFxuICBFU0NBUEU6IDI3LFxuICBMRUZUOiAzNyxcbiAgVVA6IDM4LFxuICBSSUdIVDogMzksXG4gIERPV046IDQwLFxuICBERUxFVEU6IDQ2XG59O1xuXG5LZXlib2FyZC5ERUZBVUxUUyA9IHtcbiAgYmluZGluZ3M6IHtcbiAgICAnYm9sZCc6IG1ha2VGb3JtYXRIYW5kbGVyKCdib2xkJyksXG4gICAgJ2l0YWxpYyc6IG1ha2VGb3JtYXRIYW5kbGVyKCdpdGFsaWMnKSxcbiAgICAndW5kZXJsaW5lJzogbWFrZUZvcm1hdEhhbmRsZXIoJ3VuZGVybGluZScpLFxuICAgICdpbmRlbnQnOiB7XG4gICAgICAvLyBoaWdobGlnaHQgdGFiIG9yIHRhYiBhdCBiZWdpbm5pbmcgb2YgbGlzdCwgaW5kZW50IG9yIGJsb2NrcXVvdGVcbiAgICAgIGtleTogS2V5Ym9hcmQua2V5cy5UQUIsXG4gICAgICBmb3JtYXQ6IFsnYmxvY2txdW90ZScsICdpbmRlbnQnLCAnbGlzdCddLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dC5jb2xsYXBzZWQgJiYgY29udGV4dC5vZmZzZXQgIT09IDApIHJldHVybiB0cnVlO1xuICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnaW5kZW50JywgJysxJywgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9XG4gICAgfSxcbiAgICAnb3V0ZGVudCc6IHtcbiAgICAgIGtleTogS2V5Ym9hcmQua2V5cy5UQUIsXG4gICAgICBzaGlmdEtleTogdHJ1ZSxcbiAgICAgIGZvcm1hdDogWydibG9ja3F1b3RlJywgJ2luZGVudCcsICdsaXN0J10sXG4gICAgICAvLyBoaWdobGlnaHQgdGFiIG9yIHRhYiBhdCBiZWdpbm5pbmcgb2YgbGlzdCwgaW5kZW50IG9yIGJsb2NrcXVvdGVcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY29sbGFwc2VkICYmIGNvbnRleHQub2Zmc2V0ICE9PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2luZGVudCcsICctMScsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ291dGRlbnQgYmFja3NwYWNlJzoge1xuICAgICAga2V5OiBLZXlib2FyZC5rZXlzLkJBQ0tTUEFDRSxcbiAgICAgIGNvbGxhcHNlZDogdHJ1ZSxcbiAgICAgIHNoaWZ0S2V5OiBudWxsLFxuICAgICAgbWV0YUtleTogbnVsbCxcbiAgICAgIGN0cmxLZXk6IG51bGwsXG4gICAgICBhbHRLZXk6IG51bGwsXG4gICAgICBmb3JtYXQ6IFsnaW5kZW50JywgJ2xpc3QnXSxcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuZm9ybWF0LmluZGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2luZGVudCcsICctMScsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQuZm9ybWF0Lmxpc3QgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdsaXN0JywgZmFsc2UsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnaW5kZW50IGNvZGUtYmxvY2snOiBtYWtlQ29kZUJsb2NrSGFuZGxlcih0cnVlKSxcbiAgICAnb3V0ZGVudCBjb2RlLWJsb2NrJzogbWFrZUNvZGVCbG9ja0hhbmRsZXIoZmFsc2UpLFxuICAgICdyZW1vdmUgdGFiJzoge1xuICAgICAga2V5OiBLZXlib2FyZC5rZXlzLlRBQixcbiAgICAgIHNoaWZ0S2V5OiB0cnVlLFxuICAgICAgY29sbGFwc2VkOiB0cnVlLFxuICAgICAgcHJlZml4OiAvXFx0JC8sXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlKSB7XG4gICAgICAgIHRoaXMucXVpbGwuZGVsZXRlVGV4dChyYW5nZS5pbmRleCAtIDEsIDEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3RhYic6IHtcbiAgICAgIGtleTogS2V5Ym9hcmQua2V5cy5UQUIsXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlKSB7XG4gICAgICAgIHRoaXMucXVpbGwuaGlzdG9yeS5jdXRvZmYoKTtcbiAgICAgICAgdmFyIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKHJhbmdlLmluZGV4KS5kZWxldGUocmFuZ2UubGVuZ3RoKS5pbnNlcnQoJ1xcdCcpO1xuICAgICAgICB0aGlzLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKGRlbHRhLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgdGhpcy5xdWlsbC5oaXN0b3J5LmN1dG9mZigpO1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCArIDEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnbGlzdCBlbXB0eSBlbnRlcic6IHtcbiAgICAgIGtleTogS2V5Ym9hcmQua2V5cy5FTlRFUixcbiAgICAgIGNvbGxhcHNlZDogdHJ1ZSxcbiAgICAgIGZvcm1hdDogWydsaXN0J10sXG4gICAgICBlbXB0eTogdHJ1ZSxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2xpc3QnLCBmYWxzZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIGlmIChjb250ZXh0LmZvcm1hdC5pbmRlbnQpIHtcbiAgICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnaW5kZW50JywgZmFsc2UsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnY2hlY2tsaXN0IGVudGVyJzoge1xuICAgICAga2V5OiBLZXlib2FyZC5rZXlzLkVOVEVSLFxuICAgICAgY29sbGFwc2VkOiB0cnVlLFxuICAgICAgZm9ybWF0OiB7IGxpc3Q6ICdjaGVja2VkJyB9LFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSkge1xuICAgICAgICB2YXIgX3F1aWxsJGdldExpbmUzID0gdGhpcy5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4KSxcbiAgICAgICAgICAgIF9xdWlsbCRnZXRMaW5lNCA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRnZXRMaW5lMywgMiksXG4gICAgICAgICAgICBsaW5lID0gX3F1aWxsJGdldExpbmU0WzBdLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX3F1aWxsJGdldExpbmU0WzFdO1xuXG4gICAgICAgIHZhciBmb3JtYXRzID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKHt9LCBsaW5lLmZvcm1hdHMoKSwgeyBsaXN0OiAnY2hlY2tlZCcgfSk7XG4gICAgICAgIHZhciBkZWx0YSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihyYW5nZS5pbmRleCkuaW5zZXJ0KCdcXG4nLCBmb3JtYXRzKS5yZXRhaW4obGluZS5sZW5ndGgoKSAtIG9mZnNldCAtIDEpLnJldGFpbigxLCB7IGxpc3Q6ICd1bmNoZWNrZWQnIH0pO1xuICAgICAgICB0aGlzLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKGRlbHRhLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXggKyAxLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICAgICAgICB0aGlzLnF1aWxsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnaGVhZGVyIGVudGVyJzoge1xuICAgICAga2V5OiBLZXlib2FyZC5rZXlzLkVOVEVSLFxuICAgICAgY29sbGFwc2VkOiB0cnVlLFxuICAgICAgZm9ybWF0OiBbJ2hlYWRlciddLFxuICAgICAgc3VmZml4OiAvXiQvLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3F1aWxsJGdldExpbmU1ID0gdGhpcy5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4KSxcbiAgICAgICAgICAgIF9xdWlsbCRnZXRMaW5lNiA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRnZXRMaW5lNSwgMiksXG4gICAgICAgICAgICBsaW5lID0gX3F1aWxsJGdldExpbmU2WzBdLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX3F1aWxsJGdldExpbmU2WzFdO1xuXG4gICAgICAgIHZhciBkZWx0YSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihyYW5nZS5pbmRleCkuaW5zZXJ0KCdcXG4nLCBjb250ZXh0LmZvcm1hdCkucmV0YWluKGxpbmUubGVuZ3RoKCkgLSBvZmZzZXQgLSAxKS5yZXRhaW4oMSwgeyBoZWFkZXI6IG51bGwgfSk7XG4gICAgICAgIHRoaXMucXVpbGwudXBkYXRlQ29udGVudHMoZGVsdGEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCArIDEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICAgIHRoaXMucXVpbGwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdsaXN0IGF1dG9maWxsJzoge1xuICAgICAga2V5OiAnICcsXG4gICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICBmb3JtYXQ6IHsgbGlzdDogZmFsc2UgfSxcbiAgICAgIHByZWZpeDogL15cXHMqPyhcXGQrXFwufC18XFwqfFxcWyA/XFxdfFxcW3hcXF0pJC8sXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBjb250ZXh0LnByZWZpeC5sZW5ndGg7XG5cbiAgICAgICAgdmFyIF9xdWlsbCRnZXRMaW5lNyA9IHRoaXMucXVpbGwuZ2V0TGluZShyYW5nZS5pbmRleCksXG4gICAgICAgICAgICBfcXVpbGwkZ2V0TGluZTggPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkZ2V0TGluZTcsIDIpLFxuICAgICAgICAgICAgbGluZSA9IF9xdWlsbCRnZXRMaW5lOFswXSxcbiAgICAgICAgICAgIG9mZnNldCA9IF9xdWlsbCRnZXRMaW5lOFsxXTtcblxuICAgICAgICBpZiAob2Zmc2V0ID4gbGVuZ3RoKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgICAgICBzd2l0Y2ggKGNvbnRleHQucHJlZml4LnRyaW0oKSkge1xuICAgICAgICAgIGNhc2UgJ1tdJzpjYXNlICdbIF0nOlxuICAgICAgICAgICAgdmFsdWUgPSAndW5jaGVja2VkJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1t4XSc6XG4gICAgICAgICAgICB2YWx1ZSA9ICdjaGVja2VkJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJy0nOmNhc2UgJyonOlxuICAgICAgICAgICAgdmFsdWUgPSAnYnVsbGV0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YWx1ZSA9ICdvcmRlcmVkJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnF1aWxsLmluc2VydFRleHQocmFuZ2UuaW5kZXgsICcgJywgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIHRoaXMucXVpbGwuaGlzdG9yeS5jdXRvZmYoKTtcbiAgICAgICAgdmFyIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKHJhbmdlLmluZGV4IC0gb2Zmc2V0KS5kZWxldGUobGVuZ3RoICsgMSkucmV0YWluKGxpbmUubGVuZ3RoKCkgLSAyIC0gb2Zmc2V0KS5yZXRhaW4oMSwgeyBsaXN0OiB2YWx1ZSB9KTtcbiAgICAgICAgdGhpcy5xdWlsbC51cGRhdGVDb250ZW50cyhkZWx0YSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIHRoaXMucXVpbGwuaGlzdG9yeS5jdXRvZmYoKTtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXggLSBsZW5ndGgsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnY29kZSBleGl0Jzoge1xuICAgICAga2V5OiBLZXlib2FyZC5rZXlzLkVOVEVSLFxuICAgICAgY29sbGFwc2VkOiB0cnVlLFxuICAgICAgZm9ybWF0OiBbJ2NvZGUtYmxvY2snXSxcbiAgICAgIHByZWZpeDogL1xcblxcbiQvLFxuICAgICAgc3VmZml4OiAvXlxccyskLyxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UpIHtcbiAgICAgICAgdmFyIF9xdWlsbCRnZXRMaW5lOSA9IHRoaXMucXVpbGwuZ2V0TGluZShyYW5nZS5pbmRleCksXG4gICAgICAgICAgICBfcXVpbGwkZ2V0TGluZTEwID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJGdldExpbmU5LCAyKSxcbiAgICAgICAgICAgIGxpbmUgPSBfcXVpbGwkZ2V0TGluZTEwWzBdLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX3F1aWxsJGdldExpbmUxMFsxXTtcblxuICAgICAgICB2YXIgZGVsdGEgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4ocmFuZ2UuaW5kZXggKyBsaW5lLmxlbmd0aCgpIC0gb2Zmc2V0IC0gMikucmV0YWluKDEsIHsgJ2NvZGUtYmxvY2snOiBudWxsIH0pLmRlbGV0ZSgxKTtcbiAgICAgICAgdGhpcy5xdWlsbC51cGRhdGVDb250ZW50cyhkZWx0YSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9XG4gICAgfSxcbiAgICAnZW1iZWQgbGVmdCc6IG1ha2VFbWJlZEFycm93SGFuZGxlcihLZXlib2FyZC5rZXlzLkxFRlQsIGZhbHNlKSxcbiAgICAnZW1iZWQgbGVmdCBzaGlmdCc6IG1ha2VFbWJlZEFycm93SGFuZGxlcihLZXlib2FyZC5rZXlzLkxFRlQsIHRydWUpLFxuICAgICdlbWJlZCByaWdodCc6IG1ha2VFbWJlZEFycm93SGFuZGxlcihLZXlib2FyZC5rZXlzLlJJR0hULCBmYWxzZSksXG4gICAgJ2VtYmVkIHJpZ2h0IHNoaWZ0JzogbWFrZUVtYmVkQXJyb3dIYW5kbGVyKEtleWJvYXJkLmtleXMuUklHSFQsIHRydWUpXG4gIH1cbn07XG5cbmZ1bmN0aW9uIG1ha2VFbWJlZEFycm93SGFuZGxlcihrZXksIHNoaWZ0S2V5KSB7XG4gIHZhciBfcmVmMztcblxuICB2YXIgd2hlcmUgPSBrZXkgPT09IEtleWJvYXJkLmtleXMuTEVGVCA/ICdwcmVmaXgnIDogJ3N1ZmZpeCc7XG4gIHJldHVybiBfcmVmMyA9IHtcbiAgICBrZXk6IGtleSxcbiAgICBzaGlmdEtleTogc2hpZnRLZXksXG4gICAgYWx0S2V5OiBudWxsXG4gIH0sIF9kZWZpbmVQcm9wZXJ0eShfcmVmMywgd2hlcmUsIC9eJC8pLCBfZGVmaW5lUHJvcGVydHkoX3JlZjMsICdoYW5kbGVyJywgZnVuY3Rpb24gaGFuZGxlcihyYW5nZSkge1xuICAgIHZhciBpbmRleCA9IHJhbmdlLmluZGV4O1xuICAgIGlmIChrZXkgPT09IEtleWJvYXJkLmtleXMuUklHSFQpIHtcbiAgICAgIGluZGV4ICs9IHJhbmdlLmxlbmd0aCArIDE7XG4gICAgfVxuXG4gICAgdmFyIF9xdWlsbCRnZXRMZWFmMyA9IHRoaXMucXVpbGwuZ2V0TGVhZihpbmRleCksXG4gICAgICAgIF9xdWlsbCRnZXRMZWFmNCA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRnZXRMZWFmMywgMSksXG4gICAgICAgIGxlYWYgPSBfcXVpbGwkZ2V0TGVhZjRbMF07XG5cbiAgICBpZiAoIShsZWFmIGluc3RhbmNlb2YgX3BhcmNobWVudDIuZGVmYXVsdC5FbWJlZCkpIHJldHVybiB0cnVlO1xuICAgIGlmIChrZXkgPT09IEtleWJvYXJkLmtleXMuTEVGVCkge1xuICAgICAgaWYgKHNoaWZ0S2V5KSB7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4IC0gMSwgcmFuZ2UubGVuZ3RoICsgMSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCAtIDEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2hpZnRLZXkpIHtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXgsIHJhbmdlLmxlbmd0aCArIDEsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXggKyByYW5nZS5sZW5ndGggKyAxLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KSwgX3JlZjM7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUJhY2tzcGFjZShyYW5nZSwgY29udGV4dCkge1xuICBpZiAocmFuZ2UuaW5kZXggPT09IDAgfHwgdGhpcy5xdWlsbC5nZXRMZW5ndGgoKSA8PSAxKSByZXR1cm47XG5cbiAgdmFyIF9xdWlsbCRnZXRMaW5lMTEgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXgpLFxuICAgICAgX3F1aWxsJGdldExpbmUxMiA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRnZXRMaW5lMTEsIDEpLFxuICAgICAgbGluZSA9IF9xdWlsbCRnZXRMaW5lMTJbMF07XG5cbiAgdmFyIGZvcm1hdHMgPSB7fTtcbiAgaWYgKGNvbnRleHQub2Zmc2V0ID09PSAwKSB7XG4gICAgdmFyIF9xdWlsbCRnZXRMaW5lMTMgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXggLSAxKSxcbiAgICAgICAgX3F1aWxsJGdldExpbmUxNCA9IF9zbGljZWRUb0FycmF5KF9xdWlsbCRnZXRMaW5lMTMsIDEpLFxuICAgICAgICBwcmV2ID0gX3F1aWxsJGdldExpbmUxNFswXTtcblxuICAgIGlmIChwcmV2ICE9IG51bGwgJiYgcHJldi5sZW5ndGgoKSA+IDEpIHtcbiAgICAgIHZhciBjdXJGb3JtYXRzID0gbGluZS5mb3JtYXRzKCk7XG4gICAgICB2YXIgcHJldkZvcm1hdHMgPSB0aGlzLnF1aWxsLmdldEZvcm1hdChyYW5nZS5pbmRleCAtIDEsIDEpO1xuICAgICAgZm9ybWF0cyA9IF9vcDIuZGVmYXVsdC5hdHRyaWJ1dGVzLmRpZmYoY3VyRm9ybWF0cywgcHJldkZvcm1hdHMpIHx8IHt9O1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgYXN0cmFsIHN5bWJvbHNcbiAgdmFyIGxlbmd0aCA9IC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdJC8udGVzdChjb250ZXh0LnByZWZpeCkgPyAyIDogMTtcbiAgdGhpcy5xdWlsbC5kZWxldGVUZXh0KHJhbmdlLmluZGV4IC0gbGVuZ3RoLCBsZW5ndGgsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICBpZiAoT2JqZWN0LmtleXMoZm9ybWF0cykubGVuZ3RoID4gMCkge1xuICAgIHRoaXMucXVpbGwuZm9ybWF0TGluZShyYW5nZS5pbmRleCAtIGxlbmd0aCwgbGVuZ3RoLCBmb3JtYXRzLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgfVxuICB0aGlzLnF1aWxsLmZvY3VzKCk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZURlbGV0ZShyYW5nZSwgY29udGV4dCkge1xuICAvLyBDaGVjayBmb3IgYXN0cmFsIHN5bWJvbHNcbiAgdmFyIGxlbmd0aCA9IC9eW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS8udGVzdChjb250ZXh0LnN1ZmZpeCkgPyAyIDogMTtcbiAgaWYgKHJhbmdlLmluZGV4ID49IHRoaXMucXVpbGwuZ2V0TGVuZ3RoKCkgLSBsZW5ndGgpIHJldHVybjtcbiAgdmFyIGZvcm1hdHMgPSB7fSxcbiAgICAgIG5leHRMZW5ndGggPSAwO1xuXG4gIHZhciBfcXVpbGwkZ2V0TGluZTE1ID0gdGhpcy5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4KSxcbiAgICAgIF9xdWlsbCRnZXRMaW5lMTYgPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkZ2V0TGluZTE1LCAxKSxcbiAgICAgIGxpbmUgPSBfcXVpbGwkZ2V0TGluZTE2WzBdO1xuXG4gIGlmIChjb250ZXh0Lm9mZnNldCA+PSBsaW5lLmxlbmd0aCgpIC0gMSkge1xuICAgIHZhciBfcXVpbGwkZ2V0TGluZTE3ID0gdGhpcy5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4ICsgMSksXG4gICAgICAgIF9xdWlsbCRnZXRMaW5lMTggPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkZ2V0TGluZTE3LCAxKSxcbiAgICAgICAgbmV4dCA9IF9xdWlsbCRnZXRMaW5lMThbMF07XG5cbiAgICBpZiAobmV4dCkge1xuICAgICAgdmFyIGN1ckZvcm1hdHMgPSBsaW5lLmZvcm1hdHMoKTtcbiAgICAgIHZhciBuZXh0Rm9ybWF0cyA9IHRoaXMucXVpbGwuZ2V0Rm9ybWF0KHJhbmdlLmluZGV4LCAxKTtcbiAgICAgIGZvcm1hdHMgPSBfb3AyLmRlZmF1bHQuYXR0cmlidXRlcy5kaWZmKGN1ckZvcm1hdHMsIG5leHRGb3JtYXRzKSB8fCB7fTtcbiAgICAgIG5leHRMZW5ndGggPSBuZXh0Lmxlbmd0aCgpO1xuICAgIH1cbiAgfVxuICB0aGlzLnF1aWxsLmRlbGV0ZVRleHQocmFuZ2UuaW5kZXgsIGxlbmd0aCwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gIGlmIChPYmplY3Qua2V5cyhmb3JtYXRzKS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5xdWlsbC5mb3JtYXRMaW5lKHJhbmdlLmluZGV4ICsgbmV4dExlbmd0aCAtIDEsIGxlbmd0aCwgZm9ybWF0cywgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRGVsZXRlUmFuZ2UocmFuZ2UpIHtcbiAgdmFyIGxpbmVzID0gdGhpcy5xdWlsbC5nZXRMaW5lcyhyYW5nZSk7XG4gIHZhciBmb3JtYXRzID0ge307XG4gIGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGZpcnN0Rm9ybWF0cyA9IGxpbmVzWzBdLmZvcm1hdHMoKTtcbiAgICB2YXIgbGFzdEZvcm1hdHMgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5mb3JtYXRzKCk7XG4gICAgZm9ybWF0cyA9IF9vcDIuZGVmYXVsdC5hdHRyaWJ1dGVzLmRpZmYobGFzdEZvcm1hdHMsIGZpcnN0Rm9ybWF0cykgfHwge307XG4gIH1cbiAgdGhpcy5xdWlsbC5kZWxldGVUZXh0KHJhbmdlLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgaWYgKE9iamVjdC5rZXlzKGZvcm1hdHMpLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLnF1aWxsLmZvcm1hdExpbmUocmFuZ2UuaW5kZXgsIDEsIGZvcm1hdHMsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICB9XG4gIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4LCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICB0aGlzLnF1aWxsLmZvY3VzKCk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVudGVyKHJhbmdlLCBjb250ZXh0KSB7XG4gIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gIGlmIChyYW5nZS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5xdWlsbC5zY3JvbGwuZGVsZXRlQXQocmFuZ2UuaW5kZXgsIHJhbmdlLmxlbmd0aCk7IC8vIFNvIHdlIGRvIG5vdCB0cmlnZ2VyIHRleHQtY2hhbmdlXG4gIH1cbiAgdmFyIGxpbmVGb3JtYXRzID0gT2JqZWN0LmtleXMoY29udGV4dC5mb3JtYXQpLnJlZHVjZShmdW5jdGlvbiAobGluZUZvcm1hdHMsIGZvcm1hdCkge1xuICAgIGlmIChfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KGZvcm1hdCwgX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5CTE9DSykgJiYgIUFycmF5LmlzQXJyYXkoY29udGV4dC5mb3JtYXRbZm9ybWF0XSkpIHtcbiAgICAgIGxpbmVGb3JtYXRzW2Zvcm1hdF0gPSBjb250ZXh0LmZvcm1hdFtmb3JtYXRdO1xuICAgIH1cbiAgICByZXR1cm4gbGluZUZvcm1hdHM7XG4gIH0sIHt9KTtcbiAgdGhpcy5xdWlsbC5pbnNlcnRUZXh0KHJhbmdlLmluZGV4LCAnXFxuJywgbGluZUZvcm1hdHMsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAvLyBFYXJsaWVyIHNjcm9sbC5kZWxldGVBdCBtaWdodCBoYXZlIG1lc3NlZCB1cCBvdXIgc2VsZWN0aW9uLFxuICAvLyBzbyBpbnNlcnRUZXh0J3MgYnVpbHQgaW4gc2VsZWN0aW9uIHByZXNlcnZhdGlvbiBpcyBub3QgcmVsaWFibGVcbiAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXggKyAxLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICB0aGlzLnF1aWxsLmZvY3VzKCk7XG4gIE9iamVjdC5rZXlzKGNvbnRleHQuZm9ybWF0KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKGxpbmVGb3JtYXRzW25hbWVdICE9IG51bGwpIHJldHVybjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZXh0LmZvcm1hdFtuYW1lXSkpIHJldHVybjtcbiAgICBpZiAobmFtZSA9PT0gJ2xpbmsnKSByZXR1cm47XG4gICAgX3RoaXMzLnF1aWxsLmZvcm1hdChuYW1lLCBjb250ZXh0LmZvcm1hdFtuYW1lXSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtYWtlQ29kZUJsb2NrSGFuZGxlcihpbmRlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IEtleWJvYXJkLmtleXMuVEFCLFxuICAgIHNoaWZ0S2V5OiAhaW5kZW50LFxuICAgIGZvcm1hdDogeyAnY29kZS1ibG9jayc6IHRydWUgfSxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlKSB7XG4gICAgICB2YXIgQ29kZUJsb2NrID0gX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeSgnY29kZS1ibG9jaycpO1xuICAgICAgdmFyIGluZGV4ID0gcmFuZ2UuaW5kZXgsXG4gICAgICAgICAgbGVuZ3RoID0gcmFuZ2UubGVuZ3RoO1xuXG4gICAgICB2YXIgX3F1aWxsJHNjcm9sbCRkZXNjZW5kID0gdGhpcy5xdWlsbC5zY3JvbGwuZGVzY2VuZGFudChDb2RlQmxvY2ssIGluZGV4KSxcbiAgICAgICAgICBfcXVpbGwkc2Nyb2xsJGRlc2NlbmQyID0gX3NsaWNlZFRvQXJyYXkoX3F1aWxsJHNjcm9sbCRkZXNjZW5kLCAyKSxcbiAgICAgICAgICBibG9jayA9IF9xdWlsbCRzY3JvbGwkZGVzY2VuZDJbMF0sXG4gICAgICAgICAgb2Zmc2V0ID0gX3F1aWxsJHNjcm9sbCRkZXNjZW5kMlsxXTtcblxuICAgICAgaWYgKGJsb2NrID09IG51bGwpIHJldHVybjtcbiAgICAgIHZhciBzY3JvbGxJbmRleCA9IHRoaXMucXVpbGwuZ2V0SW5kZXgoYmxvY2spO1xuICAgICAgdmFyIHN0YXJ0ID0gYmxvY2submV3bGluZUluZGV4KG9mZnNldCwgdHJ1ZSkgKyAxO1xuICAgICAgdmFyIGVuZCA9IGJsb2NrLm5ld2xpbmVJbmRleChzY3JvbGxJbmRleCArIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICB2YXIgbGluZXMgPSBibG9jay5kb21Ob2RlLnRleHRDb250ZW50LnNsaWNlKHN0YXJ0LCBlbmQpLnNwbGl0KCdcXG4nKTtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lLCBpKSB7XG4gICAgICAgIGlmIChpbmRlbnQpIHtcbiAgICAgICAgICBibG9jay5pbnNlcnRBdChzdGFydCArIG9mZnNldCwgQ29kZUJsb2NrLlRBQik7XG4gICAgICAgICAgb2Zmc2V0ICs9IENvZGVCbG9jay5UQUIubGVuZ3RoO1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBpbmRleCArPSBDb2RlQmxvY2suVEFCLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoICs9IENvZGVCbG9jay5UQUIubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoQ29kZUJsb2NrLlRBQikpIHtcbiAgICAgICAgICBibG9jay5kZWxldGVBdChzdGFydCArIG9mZnNldCwgQ29kZUJsb2NrLlRBQi5sZW5ndGgpO1xuICAgICAgICAgIG9mZnNldCAtPSBDb2RlQmxvY2suVEFCLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgaW5kZXggLT0gQ29kZUJsb2NrLlRBQi5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlbmd0aCAtPSBDb2RlQmxvY2suVEFCLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5xdWlsbC51cGRhdGUoX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihpbmRleCwgbGVuZ3RoLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZUZvcm1hdEhhbmRsZXIoZm9ybWF0KSB7XG4gIHJldHVybiB7XG4gICAga2V5OiBmb3JtYXRbMF0udG9VcHBlckNhc2UoKSxcbiAgICBzaG9ydEtleTogdHJ1ZSxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICB0aGlzLnF1aWxsLmZvcm1hdChmb3JtYXQsICFjb250ZXh0LmZvcm1hdFtmb3JtYXRdLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShiaW5kaW5nKSB7XG4gIGlmICh0eXBlb2YgYmluZGluZyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGJpbmRpbmcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZSh7IGtleTogYmluZGluZyB9KTtcbiAgfVxuICBpZiAoKHR5cGVvZiBiaW5kaW5nID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihiaW5kaW5nKSkgPT09ICdvYmplY3QnKSB7XG4gICAgYmluZGluZyA9ICgwLCBfY2xvbmUyLmRlZmF1bHQpKGJpbmRpbmcsIGZhbHNlKTtcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmcua2V5ID09PSAnc3RyaW5nJykge1xuICAgIGlmIChLZXlib2FyZC5rZXlzW2JpbmRpbmcua2V5LnRvVXBwZXJDYXNlKCldICE9IG51bGwpIHtcbiAgICAgIGJpbmRpbmcua2V5ID0gS2V5Ym9hcmQua2V5c1tiaW5kaW5nLmtleS50b1VwcGVyQ2FzZSgpXTtcbiAgICB9IGVsc2UgaWYgKGJpbmRpbmcua2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgYmluZGluZy5rZXkgPSBiaW5kaW5nLmtleS50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAoYmluZGluZy5zaG9ydEtleSkge1xuICAgIGJpbmRpbmdbU0hPUlRLRVldID0gYmluZGluZy5zaG9ydEtleTtcbiAgICBkZWxldGUgYmluZGluZy5zaG9ydEtleTtcbiAgfVxuICByZXR1cm4gYmluZGluZztcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gS2V5Ym9hcmQ7XG5leHBvcnRzLlNIT1JUS0VZID0gU0hPUlRLRVk7XG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF90ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RleHQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDdXJzb3IgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRFbWJlZCkge1xuICBfaW5oZXJpdHMoQ3Vyc29yLCBfUGFyY2htZW50JEVtYmVkKTtcblxuICBfY3JlYXRlQ2xhc3MoQ3Vyc29yLCBudWxsLCBbe1xuICAgIGtleTogJ3ZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIEN1cnNvcihkb21Ob2RlLCBzZWxlY3Rpb24pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3Vyc29yKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDdXJzb3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDdXJzb3IpKS5jYWxsKHRoaXMsIGRvbU5vZGUpKTtcblxuICAgIF90aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICBfdGhpcy50ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKEN1cnNvci5DT05URU5UUyk7XG4gICAgX3RoaXMuZG9tTm9kZS5hcHBlbmRDaGlsZChfdGhpcy50ZXh0Tm9kZSk7XG4gICAgX3RoaXMuX2xlbmd0aCA9IDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEN1cnNvciwgW3tcbiAgICBrZXk6ICdkZXRhY2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgICAvLyBzdXBlci5kZXRhY2goKSB3aWxsIGFsc28gY2xlYXIgZG9tTm9kZS5fX2Jsb3RcbiAgICAgIGlmICh0aGlzLnBhcmVudCAhPSBudWxsKSB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoQ3Vyc29yLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEN1cnNvci5wcm90b3R5cGUpLCAnZm9ybWF0JywgdGhpcykuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcyxcbiAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICB3aGlsZSAodGFyZ2V0ICE9IG51bGwgJiYgdGFyZ2V0LnN0YXRpY3Muc2NvcGUgIT09IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0tfQkxPVCkge1xuICAgICAgICBpbmRleCArPSB0YXJnZXQub2Zmc2V0KHRhcmdldC5wYXJlbnQpO1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IEN1cnNvci5DT05URU5UUy5sZW5ndGg7XG4gICAgICAgIHRhcmdldC5vcHRpbWl6ZSgpO1xuICAgICAgICB0YXJnZXQuZm9ybWF0QXQoaW5kZXgsIEN1cnNvci5DT05URU5UUy5sZW5ndGgsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbmRleCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZGV4KG5vZGUsIG9mZnNldCkge1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGV4dE5vZGUpIHJldHVybiAwO1xuICAgICAgcmV0dXJuIF9nZXQoQ3Vyc29yLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEN1cnNvci5wcm90b3R5cGUpLCAnaW5kZXgnLCB0aGlzKS5jYWxsKHRoaXMsIG5vZGUsIG9mZnNldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGVuZ3RoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLnRleHROb2RlLCB0aGlzLnRleHROb2RlLmRhdGEubGVuZ3RoXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICBfZ2V0KEN1cnNvci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDdXJzb3IucHJvdG90eXBlKSwgJ3JlbW92ZScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVzdG9yZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3RvcmUoKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb24uY29tcG9zaW5nIHx8IHRoaXMucGFyZW50ID09IG51bGwpIHJldHVybjtcbiAgICAgIHZhciB0ZXh0Tm9kZSA9IHRoaXMudGV4dE5vZGU7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnNlbGVjdGlvbi5nZXROYXRpdmVSYW5nZSgpO1xuICAgICAgdmFyIHJlc3RvcmVUZXh0ID0gdm9pZCAwLFxuICAgICAgICAgIHN0YXJ0ID0gdm9pZCAwLFxuICAgICAgICAgIGVuZCA9IHZvaWQgMDtcbiAgICAgIGlmIChyYW5nZSAhPSBudWxsICYmIHJhbmdlLnN0YXJ0Lm5vZGUgPT09IHRleHROb2RlICYmIHJhbmdlLmVuZC5ub2RlID09PSB0ZXh0Tm9kZSkge1xuICAgICAgICB2YXIgX3JlZiA9IFt0ZXh0Tm9kZSwgcmFuZ2Uuc3RhcnQub2Zmc2V0LCByYW5nZS5lbmQub2Zmc2V0XTtcbiAgICAgICAgcmVzdG9yZVRleHQgPSBfcmVmWzBdO1xuICAgICAgICBzdGFydCA9IF9yZWZbMV07XG4gICAgICAgIGVuZCA9IF9yZWZbMl07XG4gICAgICB9XG4gICAgICAvLyBMaW5rIGZvcm1hdCB3aWxsIGluc2VydCB0ZXh0IG91dHNpZGUgb2YgYW5jaG9yIHRhZ1xuICAgICAgd2hpbGUgKHRoaXMuZG9tTm9kZS5sYXN0Q2hpbGQgIT0gbnVsbCAmJiB0aGlzLmRvbU5vZGUubGFzdENoaWxkICE9PSB0aGlzLnRleHROb2RlKSB7XG4gICAgICAgIHRoaXMuZG9tTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmRvbU5vZGUubGFzdENoaWxkLCB0aGlzLmRvbU5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dE5vZGUuZGF0YSAhPT0gQ3Vyc29yLkNPTlRFTlRTKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy50ZXh0Tm9kZS5kYXRhLnNwbGl0KEN1cnNvci5DT05URU5UUykuam9pbignJyk7XG4gICAgICAgIGlmICh0aGlzLm5leHQgaW5zdGFuY2VvZiBfdGV4dDIuZGVmYXVsdCkge1xuICAgICAgICAgIHJlc3RvcmVUZXh0ID0gdGhpcy5uZXh0LmRvbU5vZGU7XG4gICAgICAgICAgdGhpcy5uZXh0Lmluc2VydEF0KDAsIHRleHQpO1xuICAgICAgICAgIHRoaXMudGV4dE5vZGUuZGF0YSA9IEN1cnNvci5DT05URU5UUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRleHROb2RlLmRhdGEgPSB0ZXh0O1xuICAgICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZSh0aGlzLnRleHROb2RlKSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy50ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKEN1cnNvci5DT05URU5UUyk7XG4gICAgICAgICAgdGhpcy5kb21Ob2RlLmFwcGVuZENoaWxkKHRoaXMudGV4dE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIF9tYXAgPSBbc3RhcnQsIGVuZF0ubWFwKGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4ocmVzdG9yZVRleHQuZGF0YS5sZW5ndGgsIG9mZnNldCAtIDEpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIF9tYXAyID0gX3NsaWNlZFRvQXJyYXkoX21hcCwgMik7XG5cbiAgICAgICAgc3RhcnQgPSBfbWFwMlswXTtcbiAgICAgICAgZW5kID0gX21hcDJbMV07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGFydE5vZGU6IHJlc3RvcmVUZXh0LFxuICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydCxcbiAgICAgICAgICBlbmROb2RlOiByZXN0b3JlVGV4dCxcbiAgICAgICAgICBlbmRPZmZzZXQ6IGVuZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAobXV0YXRpb25zLnNvbWUoZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbi50eXBlID09PSAnY2hhcmFjdGVyRGF0YScgJiYgbXV0YXRpb24udGFyZ2V0ID09PSBfdGhpczIudGV4dE5vZGU7XG4gICAgICB9KSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnJlc3RvcmUoKTtcbiAgICAgICAgaWYgKHJhbmdlKSBjb250ZXh0LnJhbmdlID0gcmFuZ2U7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3Vyc29yO1xufShfcGFyY2htZW50Mi5kZWZhdWx0LkVtYmVkKTtcblxuQ3Vyc29yLmJsb3ROYW1lID0gJ2N1cnNvcic7XG5DdXJzb3IuY2xhc3NOYW1lID0gJ3FsLWN1cnNvcic7XG5DdXJzb3IudGFnTmFtZSA9ICdzcGFuJztcbkN1cnNvci5DT05URU5UUyA9ICdcXHVGRUZGJzsgLy8gWmVybyB3aWR0aCBubyBicmVhayBzcGFjZVxuXG5cbmV4cG9ydHMuZGVmYXVsdCA9IEN1cnNvcjtcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfYmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Jsb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jsb2NrKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ29udGFpbmVyID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkQ29udGFpbmVyKSB7XG4gIF9pbmhlcml0cyhDb250YWluZXIsIF9QYXJjaG1lbnQkQ29udGFpbmVyKTtcblxuICBmdW5jdGlvbiBDb250YWluZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRhaW5lcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvbnRhaW5lci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbnRhaW5lcikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIENvbnRhaW5lcjtcbn0oX3BhcmNobWVudDIuZGVmYXVsdC5Db250YWluZXIpO1xuXG5Db250YWluZXIuYWxsb3dlZENoaWxkcmVuID0gW19ibG9jazIuZGVmYXVsdCwgX2Jsb2NrLkJsb2NrRW1iZWQsIENvbnRhaW5lcl07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENvbnRhaW5lcjtcblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Db2xvclN0eWxlID0gZXhwb3J0cy5Db2xvckNsYXNzID0gZXhwb3J0cy5Db2xvckF0dHJpYnV0b3IgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDb2xvckF0dHJpYnV0b3IgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRBdHRyaWJ1dG9yKSB7XG4gIF9pbmhlcml0cyhDb2xvckF0dHJpYnV0b3IsIF9QYXJjaG1lbnQkQXR0cmlidXRvcik7XG5cbiAgZnVuY3Rpb24gQ29sb3JBdHRyaWJ1dG9yKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvckF0dHJpYnV0b3IpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb2xvckF0dHJpYnV0b3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2xvckF0dHJpYnV0b3IpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb2xvckF0dHJpYnV0b3IsIFt7XG4gICAga2V5OiAndmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShkb21Ob2RlKSB7XG4gICAgICB2YXIgdmFsdWUgPSBfZ2V0KENvbG9yQXR0cmlidXRvci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2xvckF0dHJpYnV0b3IucHJvdG90eXBlKSwgJ3ZhbHVlJywgdGhpcykuY2FsbCh0aGlzLCBkb21Ob2RlKTtcbiAgICAgIGlmICghdmFsdWUuc3RhcnRzV2l0aCgncmdiKCcpKSByZXR1cm4gdmFsdWU7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL15bXlxcZF0rLywgJycpLnJlcGxhY2UoL1teXFxkXSskLywgJycpO1xuICAgICAgcmV0dXJuICcjJyArIHZhbHVlLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuICgnMDAnICsgcGFyc2VJbnQoY29tcG9uZW50KS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb2xvckF0dHJpYnV0b3I7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5TdHlsZSk7XG5cbnZhciBDb2xvckNsYXNzID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5DbGFzcygnY29sb3InLCAncWwtY29sb3InLCB7XG4gIHNjb3BlOiBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLklOTElORVxufSk7XG52YXIgQ29sb3JTdHlsZSA9IG5ldyBDb2xvckF0dHJpYnV0b3IoJ2NvbG9yJywgJ2NvbG9yJywge1xuICBzY29wZTogX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5JTkxJTkVcbn0pO1xuXG5leHBvcnRzLkNvbG9yQXR0cmlidXRvciA9IENvbG9yQXR0cmlidXRvcjtcbmV4cG9ydHMuQ29sb3JDbGFzcyA9IENvbG9yQ2xhc3M7XG5leHBvcnRzLkNvbG9yU3R5bGUgPSBDb2xvclN0eWxlO1xuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNhbml0aXplID0gZXhwb3J0cy5kZWZhdWx0ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfaW5saW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9pbmxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5saW5lKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgTGluayA9IGZ1bmN0aW9uIChfSW5saW5lKSB7XG4gIF9pbmhlcml0cyhMaW5rLCBfSW5saW5lKTtcblxuICBmdW5jdGlvbiBMaW5rKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5rKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTGluay5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpbmspKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaW5rLCBbe1xuICAgIGtleTogJ2Zvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKG5hbWUgIT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSB8fCAhdmFsdWUpIHJldHVybiBfZ2V0KExpbmsucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGluay5wcm90b3R5cGUpLCAnZm9ybWF0JywgdGhpcykuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0b3Iuc2FuaXRpemUodmFsdWUpO1xuICAgICAgdGhpcy5kb21Ob2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIHZhbHVlKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgdmFyIG5vZGUgPSBfZ2V0KExpbmsuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaW5rKSwgJ2NyZWF0ZScsIHRoaXMpLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgdmFsdWUgPSB0aGlzLnNhbml0aXplKHZhbHVlKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgdmFsdWUpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdub29wZW5lciBub3JlZmVycmVyJyk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgndGFyZ2V0JywgJ19ibGFuaycpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2FuaXRpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYW5pdGl6ZSh1cmwpIHtcbiAgICAgIHJldHVybiBfc2FuaXRpemUodXJsLCB0aGlzLlBST1RPQ09MX1dISVRFTElTVCkgPyB1cmwgOiB0aGlzLlNBTklUSVpFRF9VUkw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpbms7XG59KF9pbmxpbmUyLmRlZmF1bHQpO1xuXG5MaW5rLmJsb3ROYW1lID0gJ2xpbmsnO1xuTGluay50YWdOYW1lID0gJ0EnO1xuTGluay5TQU5JVElaRURfVVJMID0gJ2Fib3V0OmJsYW5rJztcbkxpbmsuUFJPVE9DT0xfV0hJVEVMSVNUID0gWydodHRwJywgJ2h0dHBzJywgJ21haWx0bycsICd0ZWwnXTtcblxuZnVuY3Rpb24gX3Nhbml0aXplKHVybCwgcHJvdG9jb2xzKSB7XG4gIHZhciBhbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIGFuY2hvci5ocmVmID0gdXJsO1xuICB2YXIgcHJvdG9jb2wgPSBhbmNob3IuaHJlZi5zbGljZSgwLCBhbmNob3IuaHJlZi5pbmRleE9mKCc6JykpO1xuICByZXR1cm4gcHJvdG9jb2xzLmluZGV4T2YocHJvdG9jb2wpID4gLTE7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IExpbms7XG5leHBvcnRzLnNhbml0aXplID0gX3Nhbml0aXplO1xuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9rZXlib2FyZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG52YXIgX2tleWJvYXJkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleWJvYXJkKTtcblxudmFyIF9kcm9wZG93biA9IF9fd2VicGFja19yZXF1aXJlX18oMTA3KTtcblxudmFyIF9kcm9wZG93bjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kcm9wZG93bik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBvcHRpb25zQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIHRvZ2dsZUFyaWFBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlKSB7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgIShlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpID09PSAndHJ1ZScpKTtcbn1cblxudmFyIFBpY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGlja2VyKHNlbGVjdCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGlja2VyKTtcblxuICAgIHRoaXMuc2VsZWN0ID0gc2VsZWN0O1xuICAgIHRoaXMuY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHRoaXMuYnVpbGRQaWNrZXIoKTtcbiAgICB0aGlzLnNlbGVjdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc2VsZWN0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuY29udGFpbmVyLCB0aGlzLnNlbGVjdCk7XG5cbiAgICB0aGlzLmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnRvZ2dsZVBpY2tlcigpO1xuICAgIH0pO1xuICAgIHRoaXMubGFiZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgIC8vIEFsbG93cyB0aGUgXCJFbnRlclwiIGtleSB0byBvcGVuIHRoZSBwaWNrZXJcbiAgICAgICAgY2FzZSBfa2V5Ym9hcmQyLmRlZmF1bHQua2V5cy5FTlRFUjpcbiAgICAgICAgICBfdGhpcy50b2dnbGVQaWNrZXIoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBBbGxvd3MgdGhlIFwiRXNjYXBlXCIga2V5IHRvIGNsb3NlIHRoZSBwaWNrZXJcbiAgICAgICAgY2FzZSBfa2V5Ym9hcmQyLmRlZmF1bHQua2V5cy5FU0NBUEU6XG4gICAgICAgICAgX3RoaXMuZXNjYXBlKCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQaWNrZXIsIFt7XG4gICAga2V5OiAndG9nZ2xlUGlja2VyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlUGlja2VyKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnRvZ2dsZSgncWwtZXhwYW5kZWQnKTtcbiAgICAgIC8vIFRvZ2dsZSBhcmlhLWV4cGFuZGVkIGFuZCBhcmlhLWhpZGRlbiB0byBtYWtlIHRoZSBwaWNrZXIgYWNjZXNzaWJsZVxuICAgICAgdG9nZ2xlQXJpYUF0dHJpYnV0ZSh0aGlzLmxhYmVsLCAnYXJpYS1leHBhbmRlZCcpO1xuICAgICAgdG9nZ2xlQXJpYUF0dHJpYnV0ZSh0aGlzLm9wdGlvbnMsICdhcmlhLWhpZGRlbicpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J1aWxkSXRlbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkSXRlbShvcHRpb24pIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIGl0ZW0udGFiSW5kZXggPSAnMCc7XG4gICAgICBpdGVtLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcblxuICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdxbC1waWNrZXItaXRlbScpO1xuICAgICAgaWYgKG9wdGlvbi5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnLCBvcHRpb24uZ2V0QXR0cmlidXRlKCd2YWx1ZScpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb24udGV4dENvbnRlbnQpIHtcbiAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGFiZWwnLCBvcHRpb24udGV4dENvbnRlbnQpO1xuICAgICAgfVxuICAgICAgaXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnNlbGVjdEl0ZW0oaXRlbSwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAvLyBBbGxvd3MgdGhlIFwiRW50ZXJcIiBrZXkgdG8gc2VsZWN0IGFuIGl0ZW1cbiAgICAgICAgICBjYXNlIF9rZXlib2FyZDIuZGVmYXVsdC5rZXlzLkVOVEVSOlxuICAgICAgICAgICAgX3RoaXMyLnNlbGVjdEl0ZW0oaXRlbSwgdHJ1ZSk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBBbGxvd3MgdGhlIFwiRXNjYXBlXCIga2V5IHRvIGNsb3NlIHRoZSBwaWNrZXJcbiAgICAgICAgICBjYXNlIF9rZXlib2FyZDIuZGVmYXVsdC5rZXlzLkVTQ0FQRTpcbiAgICAgICAgICAgIF90aGlzMi5lc2NhcGUoKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYnVpbGRMYWJlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkTGFiZWwoKSB7XG4gICAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdxbC1waWNrZXItbGFiZWwnKTtcbiAgICAgIGxhYmVsLmlubmVySFRNTCA9IF9kcm9wZG93bjIuZGVmYXVsdDtcbiAgICAgIGxhYmVsLnRhYkluZGV4ID0gJzAnO1xuICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xuICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICByZXR1cm4gbGFiZWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYnVpbGRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRPcHRpb25zKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBvcHRpb25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgb3B0aW9ucy5jbGFzc0xpc3QuYWRkKCdxbC1waWNrZXItb3B0aW9ucycpO1xuXG4gICAgICAvLyBEb24ndCB3YW50IHNjcmVlbiByZWFkZXJzIHRvIHJlYWQgdGhpcyB1bnRpbCBvcHRpb25zIGFyZSB2aXNpYmxlXG4gICAgICBvcHRpb25zLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgb3B0aW9ucy50YWJJbmRleCA9ICctMSc7XG5cbiAgICAgIC8vIE5lZWQgYSB1bmlxdWUgaWQgZm9yIGFyaWEtY29udHJvbHNcbiAgICAgIG9wdGlvbnMuaWQgPSAncWwtcGlja2VyLW9wdGlvbnMtJyArIG9wdGlvbnNDb3VudGVyO1xuICAgICAgb3B0aW9uc0NvdW50ZXIgKz0gMTtcbiAgICAgIHRoaXMubGFiZWwuc2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJywgb3B0aW9ucy5pZCk7XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAgIFtdLnNsaWNlLmNhbGwodGhpcy5zZWxlY3Qub3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIHZhciBpdGVtID0gX3RoaXMzLmJ1aWxkSXRlbShvcHRpb24pO1xuICAgICAgICBvcHRpb25zLmFwcGVuZENoaWxkKGl0ZW0pO1xuICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgX3RoaXMzLnNlbGVjdEl0ZW0oaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQob3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYnVpbGRQaWNrZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZFBpY2tlcigpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBbXS5zbGljZS5jYWxsKHRoaXMuc2VsZWN0LmF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgX3RoaXM0LmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoaXRlbS5uYW1lLCBpdGVtLnZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCgncWwtcGlja2VyJyk7XG4gICAgICB0aGlzLmxhYmVsID0gdGhpcy5idWlsZExhYmVsKCk7XG4gICAgICB0aGlzLmJ1aWxkT3B0aW9ucygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VzY2FwZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVzY2FwZSgpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAvLyBDbG9zZSBtZW51IGFuZCByZXR1cm4gZm9jdXMgdG8gdHJpZ2dlciBsYWJlbFxuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgLy8gTmVlZCBzZXRUaW1lb3V0IGZvciBhY2Nlc3NpYmlsaXR5IHRvIGVuc3VyZSB0aGF0IHRoZSBicm93c2VyIGV4ZWN1dGVzXG4gICAgICAvLyBmb2N1cyBvbiB0aGUgbmV4dCBwcm9jZXNzIHRocmVhZCBhbmQgYWZ0ZXIgYW55IERPTSBjb250ZW50IGNoYW5nZXNcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM1LmxhYmVsLmZvY3VzKCk7XG4gICAgICB9LCAxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjbG9zZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgncWwtZXhwYW5kZWQnKTtcbiAgICAgIHRoaXMubGFiZWwuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgICB0aGlzLm9wdGlvbnMuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2VsZWN0SXRlbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdEl0ZW0oaXRlbSkge1xuICAgICAgdmFyIHRyaWdnZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcucWwtc2VsZWN0ZWQnKTtcbiAgICAgIGlmIChpdGVtID09PSBzZWxlY3RlZCkgcmV0dXJuO1xuICAgICAgaWYgKHNlbGVjdGVkICE9IG51bGwpIHtcbiAgICAgICAgc2VsZWN0ZWQuY2xhc3NMaXN0LnJlbW92ZSgncWwtc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtID09IG51bGwpIHJldHVybjtcbiAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZCgncWwtc2VsZWN0ZWQnKTtcbiAgICAgIHRoaXMuc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBbXS5pbmRleE9mLmNhbGwoaXRlbS5wYXJlbnROb2RlLmNoaWxkcmVuLCBpdGVtKTtcbiAgICAgIGlmIChpdGVtLmhhc0F0dHJpYnV0ZSgnZGF0YS12YWx1ZScpKSB7XG4gICAgICAgIHRoaXMubGFiZWwuc2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJywgaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhYmVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0uaGFzQXR0cmlidXRlKCdkYXRhLWxhYmVsJykpIHtcbiAgICAgICAgdGhpcy5sYWJlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGFiZWwnLCBpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1sYWJlbCcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFiZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWxhYmVsJyk7XG4gICAgICB9XG4gICAgICBpZiAodHJpZ2dlcikge1xuICAgICAgICBpZiAodHlwZW9mIEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3QuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScpKTtcbiAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIEV2ZW50ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihFdmVudCkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIC8vIElFMTFcbiAgICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgICBldmVudC5pbml0RXZlbnQoJ2NoYW5nZScsIHRydWUsIHRydWUpO1xuICAgICAgICAgIHRoaXMuc2VsZWN0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICB2YXIgb3B0aW9uID0gdm9pZCAwO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0LnNlbGVjdGVkSW5kZXggPiAtMSkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5xbC1waWNrZXItb3B0aW9ucycpLmNoaWxkcmVuW3RoaXMuc2VsZWN0LnNlbGVjdGVkSW5kZXhdO1xuICAgICAgICBvcHRpb24gPSB0aGlzLnNlbGVjdC5vcHRpb25zW3RoaXMuc2VsZWN0LnNlbGVjdGVkSW5kZXhdO1xuICAgICAgICB0aGlzLnNlbGVjdEl0ZW0oaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdEl0ZW0obnVsbCk7XG4gICAgICB9XG4gICAgICB2YXIgaXNBY3RpdmUgPSBvcHRpb24gIT0gbnVsbCAmJiBvcHRpb24gIT09IHRoaXMuc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJ29wdGlvbltzZWxlY3RlZF0nKTtcbiAgICAgIHRoaXMubGFiZWwuY2xhc3NMaXN0LnRvZ2dsZSgncWwtYWN0aXZlJywgaXNBY3RpdmUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQaWNrZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFBpY2tlcjtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfcXVpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX3F1aWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsKTtcblxudmFyIF9ibG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfYmxvY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmxvY2spO1xuXG52YXIgX2JyZWFrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBfYnJlYWsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJlYWspO1xuXG52YXIgX2NvbnRhaW5lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG52YXIgX2NvbnRhaW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250YWluZXIpO1xuXG52YXIgX2N1cnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG52YXIgX2N1cnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jdXJzb3IpO1xuXG52YXIgX2VtYmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cbnZhciBfZW1iZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZW1iZWQpO1xuXG52YXIgX2lubGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfaW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lubGluZSk7XG5cbnZhciBfc2Nyb2xsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbnZhciBfc2Nyb2xsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Njcm9sbCk7XG5cbnZhciBfdGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZXh0KTtcblxudmFyIF9jbGlwYm9hcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KTtcblxudmFyIF9jbGlwYm9hcmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xpcGJvYXJkKTtcblxudmFyIF9oaXN0b3J5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG5cbnZhciBfaGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oaXN0b3J5KTtcblxudmFyIF9rZXlib2FyZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG52YXIgX2tleWJvYXJkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleWJvYXJkKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuX3F1aWxsMi5kZWZhdWx0LnJlZ2lzdGVyKHtcbiAgJ2Jsb3RzL2Jsb2NrJzogX2Jsb2NrMi5kZWZhdWx0LFxuICAnYmxvdHMvYmxvY2svZW1iZWQnOiBfYmxvY2suQmxvY2tFbWJlZCxcbiAgJ2Jsb3RzL2JyZWFrJzogX2JyZWFrMi5kZWZhdWx0LFxuICAnYmxvdHMvY29udGFpbmVyJzogX2NvbnRhaW5lcjIuZGVmYXVsdCxcbiAgJ2Jsb3RzL2N1cnNvcic6IF9jdXJzb3IyLmRlZmF1bHQsXG4gICdibG90cy9lbWJlZCc6IF9lbWJlZDIuZGVmYXVsdCxcbiAgJ2Jsb3RzL2lubGluZSc6IF9pbmxpbmUyLmRlZmF1bHQsXG4gICdibG90cy9zY3JvbGwnOiBfc2Nyb2xsMi5kZWZhdWx0LFxuICAnYmxvdHMvdGV4dCc6IF90ZXh0Mi5kZWZhdWx0LFxuXG4gICdtb2R1bGVzL2NsaXBib2FyZCc6IF9jbGlwYm9hcmQyLmRlZmF1bHQsXG4gICdtb2R1bGVzL2hpc3RvcnknOiBfaGlzdG9yeTIuZGVmYXVsdCxcbiAgJ21vZHVsZXMva2V5Ym9hcmQnOiBfa2V5Ym9hcmQyLmRlZmF1bHRcbn0pO1xuXG5fcGFyY2htZW50Mi5kZWZhdWx0LnJlZ2lzdGVyKF9ibG9jazIuZGVmYXVsdCwgX2JyZWFrMi5kZWZhdWx0LCBfY3Vyc29yMi5kZWZhdWx0LCBfaW5saW5lMi5kZWZhdWx0LCBfc2Nyb2xsMi5kZWZhdWx0LCBfdGV4dDIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9xdWlsbDIuZGVmYXVsdDtcblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBTaGFkb3dCbG90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNoYWRvd0Jsb3QoZG9tTm9kZSkge1xuICAgICAgICB0aGlzLmRvbU5vZGUgPSBkb21Ob2RlO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0gPSB7IGJsb3Q6IHRoaXMgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNoYWRvd0Jsb3QucHJvdG90eXBlLCBcInN0YXRpY3NcIiwge1xuICAgICAgICAvLyBIYWNrIGZvciBhY2Nlc3NpbmcgaW5oZXJpdGVkIHN0YXRpYyBtZXRob2RzXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFNoYWRvd0Jsb3QuY3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnRhZ05hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZ2lzdHJ5LlBhcmNobWVudEVycm9yKCdCbG90IGRlZmluaXRpb24gbWlzc2luZyB0YWdOYW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudGFnTmFtZSkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZUludCh2YWx1ZSkudG9TdHJpbmcoKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLnRhZ05hbWVbdmFsdWUgLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnRhZ05hbWUuaW5kZXhPZih2YWx1ZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnTmFtZVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLnRhZ05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsID0gdGhpcy5wYXJlbnQuc2Nyb2xsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRvbU5vZGUgPSB0aGlzLmRvbU5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIFJlZ2lzdHJ5LmNyZWF0ZShkb21Ob2RlKTtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBkZWxldGUgdGhpcy5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXTtcbiAgICB9O1xuICAgIFNoYWRvd0Jsb3QucHJvdG90eXBlLmRlbGV0ZUF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGJsb3QgPSB0aGlzLmlzb2xhdGUoaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgIGJsb3QucmVtb3ZlKCk7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5mb3JtYXRBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgYmxvdCA9IHRoaXMuaXNvbGF0ZShpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgaWYgKFJlZ2lzdHJ5LnF1ZXJ5KG5hbWUsIFJlZ2lzdHJ5LlNjb3BlLkJMT1QpICE9IG51bGwgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGJsb3Qud3JhcChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUmVnaXN0cnkucXVlcnkobmFtZSwgUmVnaXN0cnkuU2NvcGUuQVRUUklCVVRFKSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gUmVnaXN0cnkuY3JlYXRlKHRoaXMuc3RhdGljcy5zY29wZSk7XG4gICAgICAgICAgICBibG90LndyYXAocGFyZW50KTtcbiAgICAgICAgICAgIHBhcmVudC5mb3JtYXQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5pbnNlcnRBdCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUsIGRlZikge1xuICAgICAgICB2YXIgYmxvdCA9IGRlZiA9PSBudWxsID8gUmVnaXN0cnkuY3JlYXRlKCd0ZXh0JywgdmFsdWUpIDogUmVnaXN0cnkuY3JlYXRlKHZhbHVlLCBkZWYpO1xuICAgICAgICB2YXIgcmVmID0gdGhpcy5zcGxpdChpbmRleCk7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShibG90LCByZWYpO1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUuaW5zZXJ0SW50byA9IGZ1bmN0aW9uIChwYXJlbnRCbG90LCByZWZCbG90KSB7XG4gICAgICAgIGlmIChyZWZCbG90ID09PSB2b2lkIDApIHsgcmVmQmxvdCA9IG51bGw7IH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmRG9tTm9kZSA9IG51bGw7XG4gICAgICAgIHBhcmVudEJsb3QuY2hpbGRyZW4uaW5zZXJ0QmVmb3JlKHRoaXMsIHJlZkJsb3QpO1xuICAgICAgICBpZiAocmVmQmxvdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZWZEb21Ob2RlID0gcmVmQmxvdC5kb21Ob2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRvbU5vZGUucGFyZW50Tm9kZSAhPSBwYXJlbnRCbG90LmRvbU5vZGUgfHxcbiAgICAgICAgICAgIHRoaXMuZG9tTm9kZS5uZXh0U2libGluZyAhPSByZWZEb21Ob2RlKSB7XG4gICAgICAgICAgICBwYXJlbnRCbG90LmRvbU5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuZG9tTm9kZSwgcmVmRG9tTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRCbG90O1xuICAgICAgICB0aGlzLmF0dGFjaCgpO1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUuaXNvbGF0ZSA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnNwbGl0KGluZGV4KTtcbiAgICAgICAgdGFyZ2V0LnNwbGl0KGxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgaWYgKHJvb3QgPT09IHZvaWQgMCkgeyByb290ID0gdGhpcy5wYXJlbnQ7IH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50ID09IG51bGwgfHwgdGhpcyA9PSByb290KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZHJlbi5vZmZzZXQodGhpcykgKyB0aGlzLnBhcmVudC5vZmZzZXQocm9vdCk7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5vcHRpbWl6ZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIC8vIFRPRE8gY2xlYW4gdXAgb25jZSB3ZSB1c2UgV2Vha01hcFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICh0aGlzLmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldLm11dGF0aW9ucztcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb21Ob2RlLnBhcmVudE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kb21Ob2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb21Ob2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldC5wYXJlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGFyZ2V0LnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgdGFyZ2V0Lm5leHQpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlKCk7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS5yZXBsYWNlV2l0aCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgPyBSZWdpc3RyeS5jcmVhdGUobmFtZSwgdmFsdWUpIDogbmFtZTtcbiAgICAgICAgcmVwbGFjZW1lbnQucmVwbGFjZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50O1xuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoaW5kZXgsIGZvcmNlKSB7XG4gICAgICAgIHJldHVybiBpbmRleCA9PT0gMCA/IHRoaXMgOiB0aGlzLm5leHQ7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobXV0YXRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gZG8gYnkgZGVmYXVsdFxuICAgIH07XG4gICAgU2hhZG93QmxvdC5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyA/IFJlZ2lzdHJ5LmNyZWF0ZShuYW1lLCB2YWx1ZSkgOiBuYW1lO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIHRoaXMubmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfTtcbiAgICBTaGFkb3dCbG90LmJsb3ROYW1lID0gJ2Fic3RyYWN0JztcbiAgICByZXR1cm4gU2hhZG93QmxvdDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTaGFkb3dCbG90O1xuXG5cbi8qKiovIH0pLFxuLyogMzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhdHRyaWJ1dG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBjbGFzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG52YXIgc3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIFJlZ2lzdHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBBdHRyaWJ1dG9yU3RvcmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXR0cmlidXRvclN0b3JlKGRvbU5vZGUpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgIHRoaXMuZG9tTm9kZSA9IGRvbU5vZGU7XG4gICAgICAgIHRoaXMuYnVpbGQoKTtcbiAgICB9XG4gICAgQXR0cmlidXRvclN0b3JlLnByb3RvdHlwZS5hdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgICAvLyB2ZXJiXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5hZGQodGhpcy5kb21Ob2RlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlLnZhbHVlKHRoaXMuZG9tTm9kZSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlLmF0dHJOYW1lXSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlLmF0dHJOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGUucmVtb3ZlKHRoaXMuZG9tTm9kZSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZS5hdHRyTmFtZV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF0dHJpYnV0b3JTdG9yZS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGF0dHJpYnV0b3JfMS5kZWZhdWx0LmtleXModGhpcy5kb21Ob2RlKTtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBjbGFzc18xLmRlZmF1bHQua2V5cyh0aGlzLmRvbU5vZGUpO1xuICAgICAgICB2YXIgc3R5bGVzID0gc3R5bGVfMS5kZWZhdWx0LmtleXModGhpcy5kb21Ob2RlKTtcbiAgICAgICAgYXR0cmlidXRlc1xuICAgICAgICAgICAgLmNvbmNhdChjbGFzc2VzKVxuICAgICAgICAgICAgLmNvbmNhdChzdHlsZXMpXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSBSZWdpc3RyeS5xdWVyeShuYW1lLCBSZWdpc3RyeS5TY29wZS5BVFRSSUJVVEUpO1xuICAgICAgICAgICAgaWYgKGF0dHIgaW5zdGFuY2VvZiBhdHRyaWJ1dG9yXzEuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJpYnV0ZXNbYXR0ci5hdHRyTmFtZV0gPSBhdHRyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEF0dHJpYnV0b3JTdG9yZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5hdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF90aGlzLmF0dHJpYnV0ZXNba2V5XS52YWx1ZShfdGhpcy5kb21Ob2RlKTtcbiAgICAgICAgICAgIHRhcmdldC5mb3JtYXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXR0cmlidXRvclN0b3JlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvcHkodGFyZ2V0KTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5hdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIF90aGlzLmF0dHJpYnV0ZXNba2V5XS5yZW1vdmUoX3RoaXMuZG9tTm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICB9O1xuICAgIEF0dHJpYnV0b3JTdG9yZS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5hdHRyaWJ1dGVzKS5yZWR1Y2UoZnVuY3Rpb24gKGF0dHJpYnV0ZXMsIG5hbWUpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSBfdGhpcy5hdHRyaWJ1dGVzW25hbWVdLnZhbHVlKF90aGlzLmRvbU5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIHJldHVybiBBdHRyaWJ1dG9yU3RvcmU7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXR0cmlidXRvclN0b3JlO1xuXG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGF0dHJpYnV0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuZnVuY3Rpb24gbWF0Y2gobm9kZSwgcHJlZml4KSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xuICAgIHJldHVybiBjbGFzc05hbWUuc3BsaXQoL1xccysvKS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUuaW5kZXhPZihwcmVmaXggKyBcIi1cIikgPT09IDA7XG4gICAgfSk7XG59XG52YXIgQ2xhc3NBdHRyaWJ1dG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDbGFzc0F0dHJpYnV0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2xhc3NBdHRyaWJ1dG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENsYXNzQXR0cmlidXRvci5rZXlzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIChub2RlLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lXG4gICAgICAgICAgICAgICAgLnNwbGl0KCctJylcbiAgICAgICAgICAgICAgICAuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAgICAgLmpvaW4oJy0nKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDbGFzc0F0dHJpYnV0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY2FuQWRkKG5vZGUsIHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW1vdmUobm9kZSk7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCh0aGlzLmtleU5hbWUgKyBcIi1cIiArIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBDbGFzc0F0dHJpYnV0b3IucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gbWF0Y2gobm9kZSwgdGhpcy5rZXlOYW1lKTtcbiAgICAgICAgbWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9kZS5jbGFzc0xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2xhc3NBdHRyaWJ1dG9yLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBtYXRjaChub2RlLCB0aGlzLmtleU5hbWUpWzBdIHx8ICcnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQuc2xpY2UodGhpcy5rZXlOYW1lLmxlbmd0aCArIDEpOyAvLyArMSBmb3IgaHlwaGVuXG4gICAgICAgIHJldHVybiB0aGlzLmNhbkFkZChub2RlLCB2YWx1ZSkgPyB2YWx1ZSA6ICcnO1xuICAgIH07XG4gICAgcmV0dXJuIENsYXNzQXR0cmlidXRvcjtcbn0oYXR0cmlidXRvcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENsYXNzQXR0cmlidXRvcjtcblxuXG4vKioqLyB9KSxcbi8qIDMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhdHRyaWJ1dG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbmZ1bmN0aW9uIGNhbWVsaXplKG5hbWUpIHtcbiAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCctJyk7XG4gICAgdmFyIHJlc3QgPSBwYXJ0c1xuICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICByZXR1cm4gcGFydFswXS50b1VwcGVyQ2FzZSgpICsgcGFydC5zbGljZSgxKTtcbiAgICB9KVxuICAgICAgICAuam9pbignJyk7XG4gICAgcmV0dXJuIHBhcnRzWzBdICsgcmVzdDtcbn1cbnZhciBTdHlsZUF0dHJpYnV0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0eWxlQXR0cmlidXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHlsZUF0dHJpYnV0b3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgU3R5bGVBdHRyaWJ1dG9yLmtleXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gKG5vZGUuZ2V0QXR0cmlidXRlKCdzdHlsZScpIHx8ICcnKS5zcGxpdCgnOycpLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgcmV0dXJuIGFyclswXS50cmltKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3R5bGVBdHRyaWJ1dG9yLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobm9kZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbkFkZChub2RlLCB2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbm9kZS5zdHlsZVtjYW1lbGl6ZSh0aGlzLmtleU5hbWUpXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFN0eWxlQXR0cmlidXRvci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBub2RlLnN0eWxlW2NhbWVsaXplKHRoaXMua2V5TmFtZSldID0gJyc7XG4gICAgICAgIGlmICghbm9kZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHlsZUF0dHJpYnV0b3IucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLnN0eWxlW2NhbWVsaXplKHRoaXMua2V5TmFtZSldO1xuICAgICAgICByZXR1cm4gdGhpcy5jYW5BZGQobm9kZSwgdmFsdWUpID8gdmFsdWUgOiAnJztcbiAgICB9O1xuICAgIHJldHVybiBTdHlsZUF0dHJpYnV0b3I7XG59KGF0dHJpYnV0b3JfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdHlsZUF0dHJpYnV0b3I7XG5cblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgVGhlbWUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRoZW1lKHF1aWxsLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRoZW1lKTtcblxuICAgIHRoaXMucXVpbGwgPSBxdWlsbDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMubW9kdWxlcyA9IHt9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRoZW1lLCBbe1xuICAgIGtleTogJ2luaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgT2JqZWN0LmtleXModGhpcy5vcHRpb25zLm1vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKF90aGlzLm1vZHVsZXNbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzLmFkZE1vZHVsZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWRkTW9kdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTW9kdWxlKG5hbWUpIHtcbiAgICAgIHZhciBtb2R1bGVDbGFzcyA9IHRoaXMucXVpbGwuY29uc3RydWN0b3IuaW1wb3J0KCdtb2R1bGVzLycgKyBuYW1lKTtcbiAgICAgIHRoaXMubW9kdWxlc1tuYW1lXSA9IG5ldyBtb2R1bGVDbGFzcyh0aGlzLnF1aWxsLCB0aGlzLm9wdGlvbnMubW9kdWxlc1tuYW1lXSB8fCB7fSk7XG4gICAgICByZXR1cm4gdGhpcy5tb2R1bGVzW25hbWVdO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUaGVtZTtcbn0oKTtcblxuVGhlbWUuREVGQVVMVFMgPSB7XG4gIG1vZHVsZXM6IHt9XG59O1xuVGhlbWUudGhlbWVzID0ge1xuICAnZGVmYXVsdCc6IFRoZW1lXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUaGVtZTtcblxuLyoqKi8gfSksXG4vKiAzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF90ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF90ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RleHQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBHVUFSRF9URVhUID0gJ1xcdUZFRkYnO1xuXG52YXIgRW1iZWQgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRFbWJlZCkge1xuICBfaW5oZXJpdHMoRW1iZWQsIF9QYXJjaG1lbnQkRW1iZWQpO1xuXG4gIGZ1bmN0aW9uIEVtYmVkKG5vZGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW1iZWQpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEVtYmVkLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRW1iZWQpKS5jYWxsKHRoaXMsIG5vZGUpKTtcblxuICAgIF90aGlzLmNvbnRlbnROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIF90aGlzLmNvbnRlbnROb2RlLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgZmFsc2UpO1xuICAgIFtdLnNsaWNlLmNhbGwoX3RoaXMuZG9tTm9kZS5jaGlsZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgIF90aGlzLmNvbnRlbnROb2RlLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG4gICAgfSk7XG4gICAgX3RoaXMubGVmdEd1YXJkID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoR1VBUkRfVEVYVCk7XG4gICAgX3RoaXMucmlnaHRHdWFyZCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKEdVQVJEX1RFWFQpO1xuICAgIF90aGlzLmRvbU5vZGUuYXBwZW5kQ2hpbGQoX3RoaXMubGVmdEd1YXJkKTtcbiAgICBfdGhpcy5kb21Ob2RlLmFwcGVuZENoaWxkKF90aGlzLmNvbnRlbnROb2RlKTtcbiAgICBfdGhpcy5kb21Ob2RlLmFwcGVuZENoaWxkKF90aGlzLnJpZ2h0R3VhcmQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFbWJlZCwgW3tcbiAgICBrZXk6ICdpbmRleCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZGV4KG5vZGUsIG9mZnNldCkge1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMubGVmdEd1YXJkKSByZXR1cm4gMDtcbiAgICAgIGlmIChub2RlID09PSB0aGlzLnJpZ2h0R3VhcmQpIHJldHVybiAxO1xuICAgICAgcmV0dXJuIF9nZXQoRW1iZWQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRW1iZWQucHJvdG90eXBlKSwgJ2luZGV4JywgdGhpcykuY2FsbCh0aGlzLCBub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc3RvcmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXN0b3JlKG5vZGUpIHtcbiAgICAgIHZhciByYW5nZSA9IHZvaWQgMCxcbiAgICAgICAgICB0ZXh0Tm9kZSA9IHZvaWQgMDtcbiAgICAgIHZhciB0ZXh0ID0gbm9kZS5kYXRhLnNwbGl0KEdVQVJEX1RFWFQpLmpvaW4oJycpO1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMubGVmdEd1YXJkKSB7XG4gICAgICAgIGlmICh0aGlzLnByZXYgaW5zdGFuY2VvZiBfdGV4dDIuZGVmYXVsdCkge1xuICAgICAgICAgIHZhciBwcmV2TGVuZ3RoID0gdGhpcy5wcmV2Lmxlbmd0aCgpO1xuICAgICAgICAgIHRoaXMucHJldi5pbnNlcnRBdChwcmV2TGVuZ3RoLCB0ZXh0KTtcbiAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0Tm9kZTogdGhpcy5wcmV2LmRvbU5vZGUsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogcHJldkxlbmd0aCArIHRleHQubGVuZ3RoXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZSh0ZXh0Tm9kZSksIHRoaXMpO1xuICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnROb2RlOiB0ZXh0Tm9kZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiB0ZXh0Lmxlbmd0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gdGhpcy5yaWdodEd1YXJkKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQgaW5zdGFuY2VvZiBfdGV4dDIuZGVmYXVsdCkge1xuICAgICAgICAgIHRoaXMubmV4dC5pbnNlcnRBdCgwLCB0ZXh0KTtcbiAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0Tm9kZTogdGhpcy5uZXh0LmRvbU5vZGUsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogdGV4dC5sZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKHRleHROb2RlKSwgdGhpcy5uZXh0KTtcbiAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0Tm9kZTogdGV4dE5vZGUsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogdGV4dC5sZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLmRhdGEgPSBHVUFSRF9URVhUO1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBtdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJyAmJiAobXV0YXRpb24udGFyZ2V0ID09PSBfdGhpczIubGVmdEd1YXJkIHx8IG11dGF0aW9uLnRhcmdldCA9PT0gX3RoaXMyLnJpZ2h0R3VhcmQpKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gX3RoaXMyLnJlc3RvcmUobXV0YXRpb24udGFyZ2V0KTtcbiAgICAgICAgICBpZiAocmFuZ2UpIGNvbnRleHQucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVtYmVkO1xufShfcGFyY2htZW50Mi5kZWZhdWx0LkVtYmVkKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRW1iZWQ7XG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQWxpZ25TdHlsZSA9IGV4cG9ydHMuQWxpZ25DbGFzcyA9IGV4cG9ydHMuQWxpZ25BdHRyaWJ1dGUgPSB1bmRlZmluZWQ7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNvbmZpZyA9IHtcbiAgc2NvcGU6IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0ssXG4gIHdoaXRlbGlzdDogWydyaWdodCcsICdjZW50ZXInLCAnanVzdGlmeSddXG59O1xuXG52YXIgQWxpZ25BdHRyaWJ1dGUgPSBuZXcgX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLkF0dHJpYnV0ZSgnYWxpZ24nLCAnYWxpZ24nLCBjb25maWcpO1xudmFyIEFsaWduQ2xhc3MgPSBuZXcgX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLkNsYXNzKCdhbGlnbicsICdxbC1hbGlnbicsIGNvbmZpZyk7XG52YXIgQWxpZ25TdHlsZSA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuU3R5bGUoJ2FsaWduJywgJ3RleHQtYWxpZ24nLCBjb25maWcpO1xuXG5leHBvcnRzLkFsaWduQXR0cmlidXRlID0gQWxpZ25BdHRyaWJ1dGU7XG5leHBvcnRzLkFsaWduQ2xhc3MgPSBBbGlnbkNsYXNzO1xuZXhwb3J0cy5BbGlnblN0eWxlID0gQWxpZ25TdHlsZTtcblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5CYWNrZ3JvdW5kU3R5bGUgPSBleHBvcnRzLkJhY2tncm91bmRDbGFzcyA9IHVuZGVmaW5lZDtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG52YXIgX2NvbG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBCYWNrZ3JvdW5kQ2xhc3MgPSBuZXcgX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLkNsYXNzKCdiYWNrZ3JvdW5kJywgJ3FsLWJnJywge1xuICBzY29wZTogX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5JTkxJTkVcbn0pO1xudmFyIEJhY2tncm91bmRTdHlsZSA9IG5ldyBfY29sb3IuQ29sb3JBdHRyaWJ1dG9yKCdiYWNrZ3JvdW5kJywgJ2JhY2tncm91bmQtY29sb3InLCB7XG4gIHNjb3BlOiBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLklOTElORVxufSk7XG5cbmV4cG9ydHMuQmFja2dyb3VuZENsYXNzID0gQmFja2dyb3VuZENsYXNzO1xuZXhwb3J0cy5CYWNrZ3JvdW5kU3R5bGUgPSBCYWNrZ3JvdW5kU3R5bGU7XG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRGlyZWN0aW9uU3R5bGUgPSBleHBvcnRzLkRpcmVjdGlvbkNsYXNzID0gZXhwb3J0cy5EaXJlY3Rpb25BdHRyaWJ1dGUgPSB1bmRlZmluZWQ7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNvbmZpZyA9IHtcbiAgc2NvcGU6IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0ssXG4gIHdoaXRlbGlzdDogWydydGwnXVxufTtcblxudmFyIERpcmVjdGlvbkF0dHJpYnV0ZSA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQXR0cmlidXRlKCdkaXJlY3Rpb24nLCAnZGlyJywgY29uZmlnKTtcbnZhciBEaXJlY3Rpb25DbGFzcyA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQ2xhc3MoJ2RpcmVjdGlvbicsICdxbC1kaXJlY3Rpb24nLCBjb25maWcpO1xudmFyIERpcmVjdGlvblN0eWxlID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5TdHlsZSgnZGlyZWN0aW9uJywgJ2RpcmVjdGlvbicsIGNvbmZpZyk7XG5cbmV4cG9ydHMuRGlyZWN0aW9uQXR0cmlidXRlID0gRGlyZWN0aW9uQXR0cmlidXRlO1xuZXhwb3J0cy5EaXJlY3Rpb25DbGFzcyA9IERpcmVjdGlvbkNsYXNzO1xuZXhwb3J0cy5EaXJlY3Rpb25TdHlsZSA9IERpcmVjdGlvblN0eWxlO1xuXG4vKioqLyB9KSxcbi8qIDM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkZvbnRDbGFzcyA9IGV4cG9ydHMuRm9udFN0eWxlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgY29uZmlnID0ge1xuICBzY29wZTogX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5JTkxJTkUsXG4gIHdoaXRlbGlzdDogWydzZXJpZicsICdtb25vc3BhY2UnXVxufTtcblxudmFyIEZvbnRDbGFzcyA9IG5ldyBfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuQ2xhc3MoJ2ZvbnQnLCAncWwtZm9udCcsIGNvbmZpZyk7XG5cbnZhciBGb250U3R5bGVBdHRyaWJ1dG9yID0gZnVuY3Rpb24gKF9QYXJjaG1lbnQkQXR0cmlidXRvcikge1xuICBfaW5oZXJpdHMoRm9udFN0eWxlQXR0cmlidXRvciwgX1BhcmNobWVudCRBdHRyaWJ1dG9yKTtcblxuICBmdW5jdGlvbiBGb250U3R5bGVBdHRyaWJ1dG9yKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb250U3R5bGVBdHRyaWJ1dG9yKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRm9udFN0eWxlQXR0cmlidXRvci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZvbnRTdHlsZUF0dHJpYnV0b3IpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGb250U3R5bGVBdHRyaWJ1dG9yLCBbe1xuICAgIGtleTogJ3ZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobm9kZSkge1xuICAgICAgcmV0dXJuIF9nZXQoRm9udFN0eWxlQXR0cmlidXRvci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGb250U3R5bGVBdHRyaWJ1dG9yLnByb3RvdHlwZSksICd2YWx1ZScsIHRoaXMpLmNhbGwodGhpcywgbm9kZSkucmVwbGFjZSgvW1wiJ10vZywgJycpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb250U3R5bGVBdHRyaWJ1dG9yO1xufShfcGFyY2htZW50Mi5kZWZhdWx0LkF0dHJpYnV0b3IuU3R5bGUpO1xuXG52YXIgRm9udFN0eWxlID0gbmV3IEZvbnRTdHlsZUF0dHJpYnV0b3IoJ2ZvbnQnLCAnZm9udC1mYW1pbHknLCBjb25maWcpO1xuXG5leHBvcnRzLkZvbnRTdHlsZSA9IEZvbnRTdHlsZTtcbmV4cG9ydHMuRm9udENsYXNzID0gRm9udENsYXNzO1xuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlNpemVTdHlsZSA9IGV4cG9ydHMuU2l6ZUNsYXNzID0gdW5kZWZpbmVkO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBTaXplQ2xhc3MgPSBuZXcgX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLkNsYXNzKCdzaXplJywgJ3FsLXNpemUnLCB7XG4gIHNjb3BlOiBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLklOTElORSxcbiAgd2hpdGVsaXN0OiBbJ3NtYWxsJywgJ2xhcmdlJywgJ2h1Z2UnXVxufSk7XG52YXIgU2l6ZVN0eWxlID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5TdHlsZSgnc2l6ZScsICdmb250LXNpemUnLCB7XG4gIHNjb3BlOiBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLklOTElORSxcbiAgd2hpdGVsaXN0OiBbJzEwcHgnLCAnMThweCcsICczMnB4J11cbn0pO1xuXG5leHBvcnRzLlNpemVDbGFzcyA9IFNpemVDbGFzcztcbmV4cG9ydHMuU2l6ZVN0eWxlID0gU2l6ZVN0eWxlO1xuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAnYWxpZ24nOiB7XG4gICAgJyc6IF9fd2VicGFja19yZXF1aXJlX18oNzYpLFxuICAgICdjZW50ZXInOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3KSxcbiAgICAncmlnaHQnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4KSxcbiAgICAnanVzdGlmeSc6IF9fd2VicGFja19yZXF1aXJlX18oNzkpXG4gIH0sXG4gICdiYWNrZ3JvdW5kJzogX193ZWJwYWNrX3JlcXVpcmVfXyg4MCksXG4gICdibG9ja3F1b3RlJzogX193ZWJwYWNrX3JlcXVpcmVfXyg4MSksXG4gICdib2xkJzogX193ZWJwYWNrX3JlcXVpcmVfXyg4MiksXG4gICdjbGVhbic6IF9fd2VicGFja19yZXF1aXJlX18oODMpLFxuICAnY29kZSc6IF9fd2VicGFja19yZXF1aXJlX18oNTgpLFxuICAnY29kZS1ibG9jayc6IF9fd2VicGFja19yZXF1aXJlX18oNTgpLFxuICAnY29sb3InOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0KSxcbiAgJ2RpcmVjdGlvbic6IHtcbiAgICAnJzogX193ZWJwYWNrX3JlcXVpcmVfXyg4NSksXG4gICAgJ3J0bCc6IF9fd2VicGFja19yZXF1aXJlX18oODYpXG4gIH0sXG4gICdmbG9hdCc6IHtcbiAgICAnY2VudGVyJzogX193ZWJwYWNrX3JlcXVpcmVfXyg4NyksXG4gICAgJ2Z1bGwnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4KSxcbiAgICAnbGVmdCc6IF9fd2VicGFja19yZXF1aXJlX18oODkpLFxuICAgICdyaWdodCc6IF9fd2VicGFja19yZXF1aXJlX18oOTApXG4gIH0sXG4gICdmb3JtdWxhJzogX193ZWJwYWNrX3JlcXVpcmVfXyg5MSksXG4gICdoZWFkZXInOiB7XG4gICAgJzEnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyKSxcbiAgICAnMic6IF9fd2VicGFja19yZXF1aXJlX18oOTMpXG4gIH0sXG4gICdpdGFsaWMnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0KSxcbiAgJ2ltYWdlJzogX193ZWJwYWNrX3JlcXVpcmVfXyg5NSksXG4gICdpbmRlbnQnOiB7XG4gICAgJysxJzogX193ZWJwYWNrX3JlcXVpcmVfXyg5NiksXG4gICAgJy0xJzogX193ZWJwYWNrX3JlcXVpcmVfXyg5NylcbiAgfSxcbiAgJ2xpbmsnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4KSxcbiAgJ2xpc3QnOiB7XG4gICAgJ29yZGVyZWQnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KSxcbiAgICAnYnVsbGV0JzogX193ZWJwYWNrX3JlcXVpcmVfXygxMDApLFxuICAgICdjaGVjayc6IF9fd2VicGFja19yZXF1aXJlX18oMTAxKVxuICB9LFxuICAnc2NyaXB0Jzoge1xuICAgICdzdWInOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMiksXG4gICAgJ3N1cGVyJzogX193ZWJwYWNrX3JlcXVpcmVfXygxMDMpXG4gIH0sXG4gICdzdHJpa2UnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNCksXG4gICd1bmRlcmxpbmUnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNSksXG4gICd2aWRlbyc6IF9fd2VicGFja19yZXF1aXJlX18oMTA2KVxufTtcblxuLyoqKi8gfSksXG4vKiA0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRMYXN0Q2hhbmdlSW5kZXggPSBleHBvcnRzLmRlZmF1bHQgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9xdWlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfcXVpbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGwpO1xuXG52YXIgX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfbW9kdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEhpc3RvcnkgPSBmdW5jdGlvbiAoX01vZHVsZSkge1xuICBfaW5oZXJpdHMoSGlzdG9yeSwgX01vZHVsZSk7XG5cbiAgZnVuY3Rpb24gSGlzdG9yeShxdWlsbCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIaXN0b3J5KTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChIaXN0b3J5Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSGlzdG9yeSkpLmNhbGwodGhpcywgcXVpbGwsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmxhc3RSZWNvcmRlZCA9IDA7XG4gICAgX3RoaXMuaWdub3JlQ2hhbmdlID0gZmFsc2U7XG4gICAgX3RoaXMuY2xlYXIoKTtcbiAgICBfdGhpcy5xdWlsbC5vbihfcXVpbGwyLmRlZmF1bHQuZXZlbnRzLkVESVRPUl9DSEFOR0UsIGZ1bmN0aW9uIChldmVudE5hbWUsIGRlbHRhLCBvbGREZWx0YSwgc291cmNlKSB7XG4gICAgICBpZiAoZXZlbnROYW1lICE9PSBfcXVpbGwyLmRlZmF1bHQuZXZlbnRzLlRFWFRfQ0hBTkdFIHx8IF90aGlzLmlnbm9yZUNoYW5nZSkgcmV0dXJuO1xuICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLnVzZXJPbmx5IHx8IHNvdXJjZSA9PT0gX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUikge1xuICAgICAgICBfdGhpcy5yZWNvcmQoZGVsdGEsIG9sZERlbHRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnRyYW5zZm9ybShkZWx0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3RoaXMucXVpbGwua2V5Ym9hcmQuYWRkQmluZGluZyh7IGtleTogJ1onLCBzaG9ydEtleTogdHJ1ZSB9LCBfdGhpcy51bmRvLmJpbmQoX3RoaXMpKTtcbiAgICBfdGhpcy5xdWlsbC5rZXlib2FyZC5hZGRCaW5kaW5nKHsga2V5OiAnWicsIHNob3J0S2V5OiB0cnVlLCBzaGlmdEtleTogdHJ1ZSB9LCBfdGhpcy5yZWRvLmJpbmQoX3RoaXMpKTtcbiAgICBpZiAoL1dpbi9pLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSkge1xuICAgICAgX3RoaXMucXVpbGwua2V5Ym9hcmQuYWRkQmluZGluZyh7IGtleTogJ1knLCBzaG9ydEtleTogdHJ1ZSB9LCBfdGhpcy5yZWRvLmJpbmQoX3RoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEhpc3RvcnksIFt7XG4gICAga2V5OiAnY2hhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hhbmdlKHNvdXJjZSwgZGVzdCkge1xuICAgICAgaWYgKHRoaXMuc3RhY2tbc291cmNlXS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIHZhciBkZWx0YSA9IHRoaXMuc3RhY2tbc291cmNlXS5wb3AoKTtcbiAgICAgIHRoaXMuc3RhY2tbZGVzdF0ucHVzaChkZWx0YSk7XG4gICAgICB0aGlzLmxhc3RSZWNvcmRlZCA9IDA7XG4gICAgICB0aGlzLmlnbm9yZUNoYW5nZSA9IHRydWU7XG4gICAgICB0aGlzLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKGRlbHRhW3NvdXJjZV0sIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgdGhpcy5pZ25vcmVDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIHZhciBpbmRleCA9IGdldExhc3RDaGFuZ2VJbmRleChkZWx0YVtzb3VyY2VdKTtcbiAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKGluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjbGVhcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5zdGFjayA9IHsgdW5kbzogW10sIHJlZG86IFtdIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3V0b2ZmJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3V0b2ZmKCkge1xuICAgICAgdGhpcy5sYXN0UmVjb3JkZWQgPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlY29yZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29yZChjaGFuZ2VEZWx0YSwgb2xkRGVsdGEpIHtcbiAgICAgIGlmIChjaGFuZ2VEZWx0YS5vcHMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB0aGlzLnN0YWNrLnJlZG8gPSBbXTtcbiAgICAgIHZhciB1bmRvRGVsdGEgPSB0aGlzLnF1aWxsLmdldENvbnRlbnRzKCkuZGlmZihvbGREZWx0YSk7XG4gICAgICB2YXIgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgIGlmICh0aGlzLmxhc3RSZWNvcmRlZCArIHRoaXMub3B0aW9ucy5kZWxheSA+IHRpbWVzdGFtcCAmJiB0aGlzLnN0YWNrLnVuZG8ubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgZGVsdGEgPSB0aGlzLnN0YWNrLnVuZG8ucG9wKCk7XG4gICAgICAgIHVuZG9EZWx0YSA9IHVuZG9EZWx0YS5jb21wb3NlKGRlbHRhLnVuZG8pO1xuICAgICAgICBjaGFuZ2VEZWx0YSA9IGRlbHRhLnJlZG8uY29tcG9zZShjaGFuZ2VEZWx0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3RSZWNvcmRlZCA9IHRpbWVzdGFtcDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhY2sudW5kby5wdXNoKHtcbiAgICAgICAgcmVkbzogY2hhbmdlRGVsdGEsXG4gICAgICAgIHVuZG86IHVuZG9EZWx0YVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5zdGFjay51bmRvLmxlbmd0aCA+IHRoaXMub3B0aW9ucy5tYXhTdGFjaykge1xuICAgICAgICB0aGlzLnN0YWNrLnVuZG8uc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZWRvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVkbygpIHtcbiAgICAgIHRoaXMuY2hhbmdlKCdyZWRvJywgJ3VuZG8nKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0cmFuc2Zvcm0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm0oZGVsdGEpIHtcbiAgICAgIHRoaXMuc3RhY2sudW5kby5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgY2hhbmdlLnVuZG8gPSBkZWx0YS50cmFuc2Zvcm0oY2hhbmdlLnVuZG8sIHRydWUpO1xuICAgICAgICBjaGFuZ2UucmVkbyA9IGRlbHRhLnRyYW5zZm9ybShjaGFuZ2UucmVkbywgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc3RhY2sucmVkby5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgY2hhbmdlLnVuZG8gPSBkZWx0YS50cmFuc2Zvcm0oY2hhbmdlLnVuZG8sIHRydWUpO1xuICAgICAgICBjaGFuZ2UucmVkbyA9IGRlbHRhLnRyYW5zZm9ybShjaGFuZ2UucmVkbywgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bmRvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5kbygpIHtcbiAgICAgIHRoaXMuY2hhbmdlKCd1bmRvJywgJ3JlZG8nKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSGlzdG9yeTtcbn0oX21vZHVsZTIuZGVmYXVsdCk7XG5cbkhpc3RvcnkuREVGQVVMVFMgPSB7XG4gIGRlbGF5OiAxMDAwLFxuICBtYXhTdGFjazogMTAwLFxuICB1c2VyT25seTogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIGVuZHNXaXRoTmV3bGluZUNoYW5nZShkZWx0YSkge1xuICB2YXIgbGFzdE9wID0gZGVsdGEub3BzW2RlbHRhLm9wcy5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3RPcCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChsYXN0T3AuaW5zZXJ0ICE9IG51bGwpIHtcbiAgICByZXR1cm4gdHlwZW9mIGxhc3RPcC5pbnNlcnQgPT09ICdzdHJpbmcnICYmIGxhc3RPcC5pbnNlcnQuZW5kc1dpdGgoJ1xcbicpO1xuICB9XG4gIGlmIChsYXN0T3AuYXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGxhc3RPcC5hdHRyaWJ1dGVzKS5zb21lKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICByZXR1cm4gX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShhdHRyLCBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLKSAhPSBudWxsO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0TGFzdENoYW5nZUluZGV4KGRlbHRhKSB7XG4gIHZhciBkZWxldGVMZW5ndGggPSBkZWx0YS5yZWR1Y2UoZnVuY3Rpb24gKGxlbmd0aCwgb3ApIHtcbiAgICBsZW5ndGggKz0gb3AuZGVsZXRlIHx8IDA7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfSwgMCk7XG4gIHZhciBjaGFuZ2VJbmRleCA9IGRlbHRhLmxlbmd0aCgpIC0gZGVsZXRlTGVuZ3RoO1xuICBpZiAoZW5kc1dpdGhOZXdsaW5lQ2hhbmdlKGRlbHRhKSkge1xuICAgIGNoYW5nZUluZGV4IC09IDE7XG4gIH1cbiAgcmV0dXJuIGNoYW5nZUluZGV4O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBIaXN0b3J5O1xuZXhwb3J0cy5nZXRMYXN0Q2hhbmdlSW5kZXggPSBnZXRMYXN0Q2hhbmdlSW5kZXg7XG5cbi8qKiovIH0pLFxuLyogNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuQmFzZVRvb2x0aXAgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9leHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2V4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmQpO1xuXG52YXIgX3F1aWxsRGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX3F1aWxsRGVsdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGxEZWx0YSk7XG5cbnZhciBfZW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBfZW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbWl0dGVyKTtcblxudmFyIF9rZXlib2FyZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG52YXIgX2tleWJvYXJkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleWJvYXJkKTtcblxudmFyIF90aGVtZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuXG52YXIgX3RoZW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RoZW1lKTtcblxudmFyIF9jb2xvclBpY2tlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xuXG52YXIgX2NvbG9yUGlja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbG9yUGlja2VyKTtcblxudmFyIF9pY29uUGlja2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XG5cbnZhciBfaWNvblBpY2tlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pY29uUGlja2VyKTtcblxudmFyIF9waWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxudmFyIF9waWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGlja2VyKTtcblxudmFyIF90b29sdGlwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XG5cbnZhciBfdG9vbHRpcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b29sdGlwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQUxJR05TID0gW2ZhbHNlLCAnY2VudGVyJywgJ3JpZ2h0JywgJ2p1c3RpZnknXTtcblxudmFyIENPTE9SUyA9IFtcIiMwMDAwMDBcIiwgXCIjZTYwMDAwXCIsIFwiI2ZmOTkwMFwiLCBcIiNmZmZmMDBcIiwgXCIjMDA4YTAwXCIsIFwiIzAwNjZjY1wiLCBcIiM5OTMzZmZcIiwgXCIjZmZmZmZmXCIsIFwiI2ZhY2NjY1wiLCBcIiNmZmViY2NcIiwgXCIjZmZmZmNjXCIsIFwiI2NjZThjY1wiLCBcIiNjY2UwZjVcIiwgXCIjZWJkNmZmXCIsIFwiI2JiYmJiYlwiLCBcIiNmMDY2NjZcIiwgXCIjZmZjMjY2XCIsIFwiI2ZmZmY2NlwiLCBcIiM2NmI5NjZcIiwgXCIjNjZhM2UwXCIsIFwiI2MyODVmZlwiLCBcIiM4ODg4ODhcIiwgXCIjYTEwMDAwXCIsIFwiI2IyNmIwMFwiLCBcIiNiMmIyMDBcIiwgXCIjMDA2MTAwXCIsIFwiIzAwNDdiMlwiLCBcIiM2YjI0YjJcIiwgXCIjNDQ0NDQ0XCIsIFwiIzVjMDAwMFwiLCBcIiM2NjNkMDBcIiwgXCIjNjY2NjAwXCIsIFwiIzAwMzcwMFwiLCBcIiMwMDI5NjZcIiwgXCIjM2QxNDY2XCJdO1xuXG52YXIgRk9OVFMgPSBbZmFsc2UsICdzZXJpZicsICdtb25vc3BhY2UnXTtcblxudmFyIEhFQURFUlMgPSBbJzEnLCAnMicsICczJywgZmFsc2VdO1xuXG52YXIgU0laRVMgPSBbJ3NtYWxsJywgZmFsc2UsICdsYXJnZScsICdodWdlJ107XG5cbnZhciBCYXNlVGhlbWUgPSBmdW5jdGlvbiAoX1RoZW1lKSB7XG4gIF9pbmhlcml0cyhCYXNlVGhlbWUsIF9UaGVtZSk7XG5cbiAgZnVuY3Rpb24gQmFzZVRoZW1lKHF1aWxsLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VUaGVtZSk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQmFzZVRoZW1lLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmFzZVRoZW1lKSkuY2FsbCh0aGlzLCBxdWlsbCwgb3B0aW9ucykpO1xuXG4gICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoZSkge1xuICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHF1aWxsLnJvb3QpKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLnRvb2x0aXAgIT0gbnVsbCAmJiAhX3RoaXMudG9vbHRpcC5yb290LmNvbnRhaW5zKGUudGFyZ2V0KSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBfdGhpcy50b29sdGlwLnRleHRib3ggJiYgIV90aGlzLnF1aWxsLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgX3RoaXMudG9vbHRpcC5oaWRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoX3RoaXMucGlja2VycyAhPSBudWxsKSB7XG4gICAgICAgIF90aGlzLnBpY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAocGlja2VyKSB7XG4gICAgICAgICAgaWYgKCFwaWNrZXIuY29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgcGlja2VyLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHF1aWxsLmVtaXR0ZXIubGlzdGVuRE9NKCdjbGljaycsIGRvY3VtZW50LmJvZHksIGxpc3RlbmVyKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFzZVRoZW1lLCBbe1xuICAgIGtleTogJ2FkZE1vZHVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE1vZHVsZShuYW1lKSB7XG4gICAgICB2YXIgbW9kdWxlID0gX2dldChCYXNlVGhlbWUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmFzZVRoZW1lLnByb3RvdHlwZSksICdhZGRNb2R1bGUnLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgaWYgKG5hbWUgPT09ICd0b29sYmFyJykge1xuICAgICAgICB0aGlzLmV4dGVuZFRvb2xiYXIobW9kdWxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYnVpbGRCdXR0b25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRCdXR0b25zKGJ1dHRvbnMsIGljb25zKSB7XG4gICAgICBidXR0b25zLmZvckVhY2goZnVuY3Rpb24gKGJ1dHRvbikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gYnV0dG9uLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJztcbiAgICAgICAgY2xhc3NOYW1lLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIGlmICghbmFtZS5zdGFydHNXaXRoKCdxbC0nKSkgcmV0dXJuO1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKCdxbC0nLmxlbmd0aCk7XG4gICAgICAgICAgaWYgKGljb25zW25hbWVdID09IG51bGwpIHJldHVybjtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ2RpcmVjdGlvbicpIHtcbiAgICAgICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSBpY29uc1tuYW1lXVsnJ10gKyBpY29uc1tuYW1lXVsncnRsJ107XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaWNvbnNbbmFtZV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gaWNvbnNbbmFtZV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGJ1dHRvbi52YWx1ZSB8fCAnJztcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIGljb25zW25hbWVdW3ZhbHVlXSkge1xuICAgICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gaWNvbnNbbmFtZV1bdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdidWlsZFBpY2tlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZFBpY2tlcnMoc2VsZWN0cywgaWNvbnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLnBpY2tlcnMgPSBzZWxlY3RzLm1hcChmdW5jdGlvbiAoc2VsZWN0KSB7XG4gICAgICAgIGlmIChzZWxlY3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1hbGlnbicpKSB7XG4gICAgICAgICAgaWYgKHNlbGVjdC5xdWVyeVNlbGVjdG9yKCdvcHRpb24nKSA9PSBudWxsKSB7XG4gICAgICAgICAgICBmaWxsU2VsZWN0KHNlbGVjdCwgQUxJR05TKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBfaWNvblBpY2tlcjIuZGVmYXVsdChzZWxlY3QsIGljb25zLmFsaWduKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1iYWNrZ3JvdW5kJykgfHwgc2VsZWN0LmNsYXNzTGlzdC5jb250YWlucygncWwtY29sb3InKSkge1xuICAgICAgICAgIHZhciBmb3JtYXQgPSBzZWxlY3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1iYWNrZ3JvdW5kJykgPyAnYmFja2dyb3VuZCcgOiAnY29sb3InO1xuICAgICAgICAgIGlmIChzZWxlY3QucXVlcnlTZWxlY3Rvcignb3B0aW9uJykgPT0gbnVsbCkge1xuICAgICAgICAgICAgZmlsbFNlbGVjdChzZWxlY3QsIENPTE9SUywgZm9ybWF0ID09PSAnYmFja2dyb3VuZCcgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IF9jb2xvclBpY2tlcjIuZGVmYXVsdChzZWxlY3QsIGljb25zW2Zvcm1hdF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzZWxlY3QucXVlcnlTZWxlY3Rvcignb3B0aW9uJykgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdC5jbGFzc0xpc3QuY29udGFpbnMoJ3FsLWZvbnQnKSkge1xuICAgICAgICAgICAgICBmaWxsU2VsZWN0KHNlbGVjdCwgRk9OVFMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3QuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1oZWFkZXInKSkge1xuICAgICAgICAgICAgICBmaWxsU2VsZWN0KHNlbGVjdCwgSEVBREVSUyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdC5jbGFzc0xpc3QuY29udGFpbnMoJ3FsLXNpemUnKSkge1xuICAgICAgICAgICAgICBmaWxsU2VsZWN0KHNlbGVjdCwgU0laRVMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IF9waWNrZXIyLmRlZmF1bHQoc2VsZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICBfdGhpczIucGlja2Vycy5mb3JFYWNoKGZ1bmN0aW9uIChwaWNrZXIpIHtcbiAgICAgICAgICBwaWNrZXIudXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRoaXMucXVpbGwub24oX2VtaXR0ZXIyLmRlZmF1bHQuZXZlbnRzLkVESVRPUl9DSEFOR0UsIHVwZGF0ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VUaGVtZTtcbn0oX3RoZW1lMi5kZWZhdWx0KTtcblxuQmFzZVRoZW1lLkRFRkFVTFRTID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKHRydWUsIHt9LCBfdGhlbWUyLmRlZmF1bHQuREVGQVVMVFMsIHtcbiAgbW9kdWxlczoge1xuICAgIHRvb2xiYXI6IHtcbiAgICAgIGhhbmRsZXJzOiB7XG4gICAgICAgIGZvcm11bGE6IGZ1bmN0aW9uIGZvcm11bGEoKSB7XG4gICAgICAgICAgdGhpcy5xdWlsbC50aGVtZS50b29sdGlwLmVkaXQoJ2Zvcm11bGEnKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2U6IGZ1bmN0aW9uIGltYWdlKCkge1xuICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICAgdmFyIGZpbGVJbnB1dCA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0LnFsLWltYWdlW3R5cGU9ZmlsZV0nKTtcbiAgICAgICAgICBpZiAoZmlsZUlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZpbGVJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICBmaWxlSW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2ZpbGUnKTtcbiAgICAgICAgICAgIGZpbGVJbnB1dC5zZXRBdHRyaWJ1dGUoJ2FjY2VwdCcsICdpbWFnZS9wbmcsIGltYWdlL2dpZiwgaW1hZ2UvanBlZywgaW1hZ2UvYm1wLCBpbWFnZS94LWljb24nKTtcbiAgICAgICAgICAgIGZpbGVJbnB1dC5jbGFzc0xpc3QuYWRkKCdxbC1pbWFnZScpO1xuICAgICAgICAgICAgZmlsZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGZpbGVJbnB1dC5maWxlcyAhPSBudWxsICYmIGZpbGVJbnB1dC5maWxlc1swXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBfdGhpczMucXVpbGwuZ2V0U2VsZWN0aW9uKHRydWUpO1xuICAgICAgICAgICAgICAgICAgX3RoaXMzLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihyYW5nZS5pbmRleCkuZGVsZXRlKHJhbmdlLmxlbmd0aCkuaW5zZXJ0KHsgaW1hZ2U6IGUudGFyZ2V0LnJlc3VsdCB9KSwgX2VtaXR0ZXIyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgICAgICAgICAgIF90aGlzMy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXggKyAxLCBfZW1pdHRlcjIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICAgICAgICAgICAgICBmaWxlSW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZUlucHV0LmZpbGVzWzBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxlSW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaWxlSW5wdXQuY2xpY2soKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmlkZW86IGZ1bmN0aW9uIHZpZGVvKCkge1xuICAgICAgICAgIHRoaXMucXVpbGwudGhlbWUudG9vbHRpcC5lZGl0KCd2aWRlbycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxudmFyIEJhc2VUb29sdGlwID0gZnVuY3Rpb24gKF9Ub29sdGlwKSB7XG4gIF9pbmhlcml0cyhCYXNlVG9vbHRpcCwgX1Rvb2x0aXApO1xuXG4gIGZ1bmN0aW9uIEJhc2VUb29sdGlwKHF1aWxsLCBib3VuZHNDb250YWluZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZVRvb2x0aXApO1xuXG4gICAgdmFyIF90aGlzNCA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChCYXNlVG9vbHRpcC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJhc2VUb29sdGlwKSkuY2FsbCh0aGlzLCBxdWlsbCwgYm91bmRzQ29udGFpbmVyKSk7XG5cbiAgICBfdGhpczQudGV4dGJveCA9IF90aGlzNC5yb290LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9XCJ0ZXh0XCJdJyk7XG4gICAgX3RoaXM0Lmxpc3RlbigpO1xuICAgIHJldHVybiBfdGhpczQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFzZVRvb2x0aXAsIFt7XG4gICAga2V5OiAnbGlzdGVuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHRoaXMudGV4dGJveC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChfa2V5Ym9hcmQyLmRlZmF1bHQubWF0Y2goZXZlbnQsICdlbnRlcicpKSB7XG4gICAgICAgICAgX3RoaXM1LnNhdmUoKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKF9rZXlib2FyZDIuZGVmYXVsdC5tYXRjaChldmVudCwgJ2VzY2FwZScpKSB7XG4gICAgICAgICAgX3RoaXM1LmNhbmNlbCgpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbmNlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VkaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlZGl0KCkge1xuICAgICAgdmFyIG1vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdsaW5rJztcbiAgICAgIHZhciBwcmV2aWV3ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgICB0aGlzLnJvb3QuY2xhc3NMaXN0LnJlbW92ZSgncWwtaGlkZGVuJyk7XG4gICAgICB0aGlzLnJvb3QuY2xhc3NMaXN0LmFkZCgncWwtZWRpdGluZycpO1xuICAgICAgaWYgKHByZXZpZXcgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnRleHRib3gudmFsdWUgPSBwcmV2aWV3O1xuICAgICAgfSBlbHNlIGlmIChtb2RlICE9PSB0aGlzLnJvb3QuZ2V0QXR0cmlidXRlKCdkYXRhLW1vZGUnKSkge1xuICAgICAgICB0aGlzLnRleHRib3gudmFsdWUgPSAnJztcbiAgICAgIH1cbiAgICAgIHRoaXMucG9zaXRpb24odGhpcy5xdWlsbC5nZXRCb3VuZHModGhpcy5xdWlsbC5zZWxlY3Rpb24uc2F2ZWRSYW5nZSkpO1xuICAgICAgdGhpcy50ZXh0Ym94LnNlbGVjdCgpO1xuICAgICAgdGhpcy50ZXh0Ym94LnNldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInLCB0aGlzLnRleHRib3guZ2V0QXR0cmlidXRlKCdkYXRhLScgKyBtb2RlKSB8fCAnJyk7XG4gICAgICB0aGlzLnJvb3Quc2V0QXR0cmlidXRlKCdkYXRhLW1vZGUnLCBtb2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXN0b3JlRm9jdXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXN0b3JlRm9jdXMoKSB7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5xdWlsbC5zY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wO1xuICAgICAgdGhpcy5xdWlsbC5mb2N1cygpO1xuICAgICAgdGhpcy5xdWlsbC5zY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NhdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy50ZXh0Ym94LnZhbHVlO1xuICAgICAgc3dpdGNoICh0aGlzLnJvb3QuZ2V0QXR0cmlidXRlKCdkYXRhLW1vZGUnKSkge1xuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5xdWlsbC5yb290LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmtSYW5nZSkge1xuICAgICAgICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdFRleHQodGhpcy5saW5rUmFuZ2UsICdsaW5rJywgdmFsdWUsIF9lbWl0dGVyMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpbmtSYW5nZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMucmVzdG9yZUZvY3VzKCk7XG4gICAgICAgICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdsaW5rJywgdmFsdWUsIF9lbWl0dGVyMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnF1aWxsLnJvb3Quc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFsdWUgPSBleHRyYWN0VmlkZW9VcmwodmFsdWUpO1xuICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2UgJ2Zvcm11bGEnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIGJyZWFrO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5xdWlsbC5nZXRTZWxlY3Rpb24odHJ1ZSk7XG4gICAgICAgICAgICBpZiAocmFuZ2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSByYW5nZS5pbmRleCArIHJhbmdlLmxlbmd0aDtcbiAgICAgICAgICAgICAgdGhpcy5xdWlsbC5pbnNlcnRFbWJlZChpbmRleCwgdGhpcy5yb290LmdldEF0dHJpYnV0ZSgnZGF0YS1tb2RlJyksIHZhbHVlLCBfZW1pdHRlcjIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5yb290LmdldEF0dHJpYnV0ZSgnZGF0YS1tb2RlJykgPT09ICdmb3JtdWxhJykge1xuICAgICAgICAgICAgICAgIHRoaXMucXVpbGwuaW5zZXJ0VGV4dChpbmRleCArIDEsICcgJywgX2VtaXR0ZXIyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihpbmRleCArIDIsIF9lbWl0dGVyMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgICB0aGlzLnRleHRib3gudmFsdWUgPSAnJztcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlVG9vbHRpcDtcbn0oX3Rvb2x0aXAyLmRlZmF1bHQpO1xuXG5mdW5jdGlvbiBleHRyYWN0VmlkZW9VcmwodXJsKSB7XG4gIHZhciBtYXRjaCA9IHVybC5tYXRjaCgvXig/OihodHRwcz8pOlxcL1xcLyk/KD86KD86d3d3fG0pXFwuKT95b3V0dWJlXFwuY29tXFwvd2F0Y2guKnY9KFthLXpBLVowLTlfLV0rKS8pIHx8IHVybC5tYXRjaCgvXig/OihodHRwcz8pOlxcL1xcLyk/KD86KD86d3d3fG0pXFwuKT95b3V0dVxcLmJlXFwvKFthLXpBLVowLTlfLV0rKS8pO1xuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4gKG1hdGNoWzFdIHx8ICdodHRwcycpICsgJzovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC8nICsgbWF0Y2hbMl0gKyAnP3Nob3dpbmZvPTAnO1xuICB9XG4gIGlmIChtYXRjaCA9IHVybC5tYXRjaCgvXig/OihodHRwcz8pOlxcL1xcLyk/KD86d3d3XFwuKT92aW1lb1xcLmNvbVxcLyhcXGQrKS8pKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgIHJldHVybiAobWF0Y2hbMV0gfHwgJ2h0dHBzJykgKyAnOi8vcGxheWVyLnZpbWVvLmNvbS92aWRlby8nICsgbWF0Y2hbMl0gKyAnLyc7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cblxuZnVuY3Rpb24gZmlsbFNlbGVjdChzZWxlY3QsIHZhbHVlcykge1xuICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgaWYgKHZhbHVlID09PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJ3NlbGVjdGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsdWUpO1xuICAgIH1cbiAgICBzZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuQmFzZVRvb2x0aXAgPSBCYXNlVG9vbHRpcDtcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2VUaGVtZTtcblxuLyoqKi8gfSksXG4vKiA0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExpbmtlZExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlua2VkTGlzdCgpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbm9kZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShub2Rlc1swXSwgbnVsbCk7XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZC5hcHBseSh0aGlzLCBub2Rlcy5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGN1ciwgbmV4dCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgd2hpbGUgKChjdXIgPSBuZXh0KCkpKSB7XG4gICAgICAgICAgICBpZiAoY3VyID09PSBub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChub2RlLCByZWZOb2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbm9kZS5uZXh0ID0gcmVmTm9kZTtcbiAgICAgICAgaWYgKHJlZk5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZS5wcmV2ID0gcmVmTm9kZS5wcmV2O1xuICAgICAgICAgICAgaWYgKHJlZk5vZGUucHJldiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVmTm9kZS5wcmV2Lm5leHQgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmTm9kZS5wcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIGlmIChyZWZOb2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudGFpbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwubmV4dCA9IG5vZGU7XG4gICAgICAgICAgICBub2RlLnByZXYgPSB0aGlzLnRhaWw7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gMTtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMCwgY3VyID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZSAoY3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdXIgPT09IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCArPSBjdXIubGVuZ3RoKCk7XG4gICAgICAgICAgICBjdXIgPSBjdXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbnMobm9kZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChub2RlLnByZXYgIT0gbnVsbClcbiAgICAgICAgICAgIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICBpZiAobm9kZS5uZXh0ICE9IG51bGwpXG4gICAgICAgICAgICBub2RlLm5leHQucHJldiA9IG5vZGUucHJldjtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZClcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5vZGUubmV4dDtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFpbClcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5vZGUucHJldjtcbiAgICAgICAgdGhpcy5sZW5ndGggLT0gMTtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gKGN1ck5vZGUpIHtcbiAgICAgICAgaWYgKGN1ck5vZGUgPT09IHZvaWQgMCkgeyBjdXJOb2RlID0gdGhpcy5oZWFkOyB9XG4gICAgICAgIC8vIFRPRE8gdXNlIHlpZWxkIHdoZW4gd2UgY2FuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gY3VyTm9kZTtcbiAgICAgICAgICAgIGlmIChjdXJOb2RlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgY3VyTm9kZSA9IGN1ck5vZGUubmV4dDtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGluZGV4LCBpbmNsdXNpdmUpIHtcbiAgICAgICAgaWYgKGluY2x1c2l2ZSA9PT0gdm9pZCAwKSB7IGluY2x1c2l2ZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBjdXIsIG5leHQgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgICAgIHdoaWxlICgoY3VyID0gbmV4dCgpKSkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGN1ci5sZW5ndGgoKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIChpbmNsdXNpdmUgJiYgaW5kZXggPT09IGxlbmd0aCAmJiAoY3VyLm5leHQgPT0gbnVsbCB8fCBjdXIubmV4dC5sZW5ndGgoKSAhPT0gMCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjdXIsIGluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4IC09IGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW251bGwsIDBdO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgY3VyLCBuZXh0ID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICB3aGlsZSAoKGN1ciA9IG5leHQoKSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGN1cik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmZvckVhY2hBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAobGVuZ3RoIDw9IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZmluZChpbmRleCksIHN0YXJ0Tm9kZSA9IF9hWzBdLCBvZmZzZXQgPSBfYVsxXTtcbiAgICAgICAgdmFyIGN1ciwgY3VySW5kZXggPSBpbmRleCAtIG9mZnNldCwgbmV4dCA9IHRoaXMuaXRlcmF0b3Ioc3RhcnROb2RlKTtcbiAgICAgICAgd2hpbGUgKChjdXIgPSBuZXh0KCkpICYmIGN1ckluZGV4IDwgaW5kZXggKyBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjdXJMZW5ndGggPSBjdXIubGVuZ3RoKCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiBjdXJJbmRleCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGN1ciwgaW5kZXggLSBjdXJJbmRleCwgTWF0aC5taW4obGVuZ3RoLCBjdXJJbmRleCArIGN1ckxlbmd0aCAtIGluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjdXIsIDAsIE1hdGgubWluKGN1ckxlbmd0aCwgaW5kZXggKyBsZW5ndGggLSBjdXJJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VySW5kZXggKz0gY3VyTGVuZ3RoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBjdXIpIHtcbiAgICAgICAgICAgIG1lbW8ucHVzaChjYWxsYmFjayhjdXIpKTtcbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9LCBbXSk7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG1lbW8pIHtcbiAgICAgICAgdmFyIGN1ciwgbmV4dCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgd2hpbGUgKChjdXIgPSBuZXh0KCkpKSB7XG4gICAgICAgICAgICBtZW1vID0gY2FsbGJhY2sobWVtbywgY3VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICAgIHJldHVybiBMaW5rZWRMaXN0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IExpbmtlZExpc3Q7XG5cblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udGFpbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbnZhciBSZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgT0JTRVJWRVJfQ09ORklHID0ge1xuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWUsXG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWUsXG59O1xudmFyIE1BWF9PUFRJTUlaRV9JVEVSQVRJT05TID0gMTAwO1xudmFyIFNjcm9sbEJsb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjcm9sbEJsb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2Nyb2xsQmxvdChub2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5vZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNjcm9sbCA9IF90aGlzO1xuICAgICAgICBfdGhpcy5vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZShtdXRhdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMub2JzZXJ2ZXIub2JzZXJ2ZShfdGhpcy5kb21Ob2RlLCBPQlNFUlZFUl9DT05GSUcpO1xuICAgICAgICBfdGhpcy5hdHRhY2goKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTY3JvbGxCbG90LnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGV0YWNoLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH07XG4gICAgU2Nyb2xsQmxvdC5wcm90b3R5cGUuZGVsZXRlQXQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgbGVuZ3RoID09PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVsZXRlQXQuY2FsbCh0aGlzLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsQmxvdC5wcm90b3R5cGUuZm9ybWF0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5mb3JtYXRBdC5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuICAgIFNjcm9sbEJsb3QucHJvdG90eXBlLmluc2VydEF0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW5zZXJ0QXQuY2FsbCh0aGlzLCBpbmRleCwgdmFsdWUsIGRlZik7XG4gICAgfTtcbiAgICBTY3JvbGxCbG90LnByb3RvdHlwZS5vcHRpbWl6ZSA9IGZ1bmN0aW9uIChtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG11dGF0aW9ucyA9PT0gdm9pZCAwKSB7IG11dGF0aW9ucyA9IFtdOyB9XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IHt9OyB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUub3B0aW1pemUuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgLy8gV2UgbXVzdCBtb2RpZnkgbXV0YXRpb25zIGRpcmVjdGx5LCBjYW5ub3QgbWFrZSBjb3B5IGFuZCB0aGVuIG1vZGlmeVxuICAgICAgICB2YXIgcmVjb3JkcyA9IFtdLnNsaWNlLmNhbGwodGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgICAgICAgLy8gQXJyYXkucHVzaCBjdXJyZW50bHkgc2VlbXMgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYSBub24tdGFpbCByZWN1cnNpdmUgZnVuY3Rpb25cbiAgICAgICAgLy8gc28gd2UgY2Fubm90IGp1c3QgbXV0YXRpb25zLnB1c2guYXBwbHkobXV0YXRpb25zLCB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgICAgICB3aGlsZSAocmVjb3Jkcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgbXV0YXRpb25zLnB1c2gocmVjb3Jkcy5wb3AoKSk7XG4gICAgICAgIC8vIFRPRE8gdXNlIFdlYWtNYXBcbiAgICAgICAgdmFyIG1hcmsgPSBmdW5jdGlvbiAoYmxvdCwgbWFya1BhcmVudCkge1xuICAgICAgICAgICAgaWYgKG1hcmtQYXJlbnQgPT09IHZvaWQgMCkgeyBtYXJrUGFyZW50ID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKGJsb3QgPT0gbnVsbCB8fCBibG90ID09PSBfdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoYmxvdC5kb21Ob2RlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoYmxvdC5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXS5tdXRhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBibG90LmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldLm11dGF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hcmtQYXJlbnQpXG4gICAgICAgICAgICAgICAgbWFyayhibG90LnBhcmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvcHRpbWl6ZSA9IGZ1bmN0aW9uIChibG90KSB7XG4gICAgICAgICAgICAvLyBQb3N0LW9yZGVyIHRyYXZlcnNhbFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgYmxvdC5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXSA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGJsb3QuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0ubXV0YXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvdCBpbnN0YW5jZW9mIGNvbnRhaW5lcl8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBibG90LmNoaWxkcmVuLmZvckVhY2gob3B0aW1pemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvdC5vcHRpbWl6ZShjb250ZXh0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IG11dGF0aW9ucztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IHJlbWFpbmluZy5sZW5ndGggPiAwOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChpID49IE1BWF9PUFRJTUlaRV9JVEVSQVRJT05TKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbUGFyY2htZW50XSBNYXhpbXVtIG9wdGltaXplIGl0ZXJhdGlvbnMgcmVhY2hlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtYWluaW5nLmZvckVhY2goZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJsb3QgPSBSZWdpc3RyeS5maW5kKG11dGF0aW9uLnRhcmdldCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJsb3QgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChibG90LmRvbU5vZGUgPT09IG11dGF0aW9uLnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmsoUmVnaXN0cnkuZmluZChtdXRhdGlvbi5wcmV2aW91c1NpYmxpbmcsIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwobXV0YXRpb24uYWRkZWROb2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBSZWdpc3RyeS5maW5kKG5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrKGNoaWxkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgY29udGFpbmVyXzEuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChncmFuZENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrKGdyYW5kQ2hpbGQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobXV0YXRpb24udHlwZSA9PT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrKGJsb3QucHJldik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFyayhibG90KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKG9wdGltaXplKTtcbiAgICAgICAgICAgIHJlbWFpbmluZyA9IFtdLnNsaWNlLmNhbGwodGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgICAgICAgICAgIHJlY29yZHMgPSByZW1haW5pbmcuc2xpY2UoKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWNvcmRzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgbXV0YXRpb25zLnB1c2gocmVjb3Jkcy5wb3AoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcm9sbEJsb3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgbXV0YXRpb25zID0gbXV0YXRpb25zIHx8IHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgLy8gVE9ETyB1c2UgV2Vha01hcFxuICAgICAgICBtdXRhdGlvbnNcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgYmxvdCA9IFJlZ2lzdHJ5LmZpbmQobXV0YXRpb24udGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChibG90ID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoYmxvdC5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXS5tdXRhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBibG90LmRvbU5vZGVbUmVnaXN0cnkuREFUQV9LRVldLm11dGF0aW9ucyA9IFttdXRhdGlvbl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgYmxvdC5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXS5tdXRhdGlvbnMucHVzaChtdXRhdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoYmxvdCkge1xuICAgICAgICAgICAgaWYgKGJsb3QgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIGJsb3QgPT09IF90aGlzIHx8XG4gICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgYmxvdC5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGJsb3QudXBkYXRlKGJsb3QuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0ubXV0YXRpb25zIHx8IFtdLCBjb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKHRoaXMuZG9tTm9kZVtSZWdpc3RyeS5EQVRBX0tFWV0ubXV0YXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgdGhpcy5kb21Ob2RlW1JlZ2lzdHJ5LkRBVEFfS0VZXS5tdXRhdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW1pemUobXV0YXRpb25zLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFNjcm9sbEJsb3QuYmxvdE5hbWUgPSAnc2Nyb2xsJztcbiAgICBTY3JvbGxCbG90LmRlZmF1bHRDaGlsZCA9ICdibG9jayc7XG4gICAgU2Nyb2xsQmxvdC5zY29wZSA9IFJlZ2lzdHJ5LlNjb3BlLkJMT0NLX0JMT1Q7XG4gICAgU2Nyb2xsQmxvdC50YWdOYW1lID0gJ0RJVic7XG4gICAgcmV0dXJuIFNjcm9sbEJsb3Q7XG59KGNvbnRhaW5lcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFNjcm9sbEJsb3Q7XG5cblxuLyoqKi8gfSksXG4vKiA0NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZm9ybWF0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbnZhciBSZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vLyBTaGFsbG93IG9iamVjdCBjb21wYXJpc29uXG5mdW5jdGlvbiBpc0VxdWFsKG9iajEsIG9iajIpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMob2JqMSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhvYmoyKS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmoxKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKG9iajFbcHJvcF0gIT09IG9iajJbcHJvcF0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxudmFyIElubGluZUJsb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKElubGluZUJsb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5saW5lQmxvdCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBJbmxpbmVCbG90LmZvcm1hdHMgPSBmdW5jdGlvbiAoZG9tTm9kZSkge1xuICAgICAgICBpZiAoZG9tTm9kZS50YWdOYW1lID09PSBJbmxpbmVCbG90LnRhZ05hbWUpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmZvcm1hdHMuY2FsbCh0aGlzLCBkb21Ob2RlKTtcbiAgICB9O1xuICAgIElubGluZUJsb3QucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobmFtZSA9PT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgZm9ybWF0XzEuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC53cmFwKElubGluZUJsb3QuYmxvdE5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRyaWJ1dGVzLmNvcHkoY2hpbGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVud3JhcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5mb3JtYXQuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElubGluZUJsb3QucHJvdG90eXBlLmZvcm1hdEF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcm1hdHMoKVtuYW1lXSAhPSBudWxsIHx8IFJlZ2lzdHJ5LnF1ZXJ5KG5hbWUsIFJlZ2lzdHJ5LlNjb3BlLkFUVFJJQlVURSkpIHtcbiAgICAgICAgICAgIHZhciBibG90ID0gdGhpcy5pc29sYXRlKGluZGV4LCBsZW5ndGgpO1xuICAgICAgICAgICAgYmxvdC5mb3JtYXQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5mb3JtYXRBdC5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5saW5lQmxvdC5wcm90b3R5cGUub3B0aW1pemUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm9wdGltaXplLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICAgIHZhciBmb3JtYXRzID0gdGhpcy5mb3JtYXRzKCk7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhmb3JtYXRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVud3JhcCgpOyAvLyB1bmZvcm1hdHRlZCBzcGFuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm5leHQ7XG4gICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgSW5saW5lQmxvdCAmJiBuZXh0LnByZXYgPT09IHRoaXMgJiYgaXNFcXVhbChmb3JtYXRzLCBuZXh0LmZvcm1hdHMoKSkpIHtcbiAgICAgICAgICAgIG5leHQubW92ZUNoaWxkcmVuKHRoaXMpO1xuICAgICAgICAgICAgbmV4dC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5saW5lQmxvdC5ibG90TmFtZSA9ICdpbmxpbmUnO1xuICAgIElubGluZUJsb3Quc2NvcGUgPSBSZWdpc3RyeS5TY29wZS5JTkxJTkVfQkxPVDtcbiAgICBJbmxpbmVCbG90LnRhZ05hbWUgPSAnU1BBTic7XG4gICAgcmV0dXJuIElubGluZUJsb3Q7XG59KGZvcm1hdF8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IElubGluZUJsb3Q7XG5cblxuLyoqKi8gfSksXG4vKiA0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZm9ybWF0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbnZhciBSZWdpc3RyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgQmxvY2tCbG90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCbG9ja0Jsb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmxvY2tCbG90KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEJsb2NrQmxvdC5mb3JtYXRzID0gZnVuY3Rpb24gKGRvbU5vZGUpIHtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBSZWdpc3RyeS5xdWVyeShCbG9ja0Jsb3QuYmxvdE5hbWUpLnRhZ05hbWU7XG4gICAgICAgIGlmIChkb21Ob2RlLnRhZ05hbWUgPT09IHRhZ05hbWUpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gX3N1cGVyLmZvcm1hdHMuY2FsbCh0aGlzLCBkb21Ob2RlKTtcbiAgICB9O1xuICAgIEJsb2NrQmxvdC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChSZWdpc3RyeS5xdWVyeShuYW1lLCBSZWdpc3RyeS5TY29wZS5CTE9DSykgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSAmJiAhdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVdpdGgoQmxvY2tCbG90LmJsb3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZm9ybWF0LmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCbG9ja0Jsb3QucHJvdG90eXBlLmZvcm1hdEF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChSZWdpc3RyeS5xdWVyeShuYW1lLCBSZWdpc3RyeS5TY29wZS5CTE9DSykgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5mb3JtYXRBdC5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmxvY2tCbG90LnByb3RvdHlwZS5pbnNlcnRBdCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUsIGRlZikge1xuICAgICAgICBpZiAoZGVmID09IG51bGwgfHwgUmVnaXN0cnkucXVlcnkodmFsdWUsIFJlZ2lzdHJ5LlNjb3BlLklOTElORSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRleHQgb3IgaW5saW5lXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluc2VydEF0LmNhbGwodGhpcywgaW5kZXgsIHZhbHVlLCBkZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFmdGVyID0gdGhpcy5zcGxpdChpbmRleCk7XG4gICAgICAgICAgICB2YXIgYmxvdCA9IFJlZ2lzdHJ5LmNyZWF0ZSh2YWx1ZSwgZGVmKTtcbiAgICAgICAgICAgIGFmdGVyLnBhcmVudC5pbnNlcnRCZWZvcmUoYmxvdCwgYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCbG9ja0Jsb3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1RyaWRlbnQvKSkge1xuICAgICAgICAgICAgdGhpcy5idWlsZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzLCBtdXRhdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCbG9ja0Jsb3QuYmxvdE5hbWUgPSAnYmxvY2snO1xuICAgIEJsb2NrQmxvdC5zY29wZSA9IFJlZ2lzdHJ5LlNjb3BlLkJMT0NLX0JMT1Q7XG4gICAgQmxvY2tCbG90LnRhZ05hbWUgPSAnUCc7XG4gICAgcmV0dXJuIEJsb2NrQmxvdDtcbn0oZm9ybWF0XzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2tCbG90O1xuXG5cbi8qKiovIH0pLFxuLyogNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxlYWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xudmFyIEVtYmVkQmxvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW1iZWRCbG90LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVtYmVkQmxvdCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBFbWJlZEJsb3QuZm9ybWF0cyA9IGZ1bmN0aW9uIChkb21Ob2RlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBFbWJlZEJsb3QucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAvLyBzdXBlci5mb3JtYXRBdCB3cmFwcywgd2hpY2ggaXMgd2hhdCB3ZSB3YW50IGluIGdlbmVyYWwsXG4gICAgICAgIC8vIGJ1dCB0aGlzIGFsbG93cyBzdWJjbGFzc2VzIHRvIG92ZXJ3cml0ZSBmb3IgZm9ybWF0c1xuICAgICAgICAvLyB0aGF0IGp1c3QgYXBwbHkgdG8gcGFydGljdWxhciBlbWJlZHNcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5mb3JtYXRBdC5jYWxsKHRoaXMsIDAsIHRoaXMubGVuZ3RoKCksIG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuICAgIEVtYmVkQmxvdC5wcm90b3R5cGUuZm9ybWF0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwICYmIGxlbmd0aCA9PT0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5mb3JtYXRBdC5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRW1iZWRCbG90LnByb3RvdHlwZS5mb3JtYXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0aWNzLmZvcm1hdHModGhpcy5kb21Ob2RlKTtcbiAgICB9O1xuICAgIHJldHVybiBFbWJlZEJsb3Q7XG59KGxlYWZfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFbWJlZEJsb3Q7XG5cblxuLyoqKi8gfSksXG4vKiA0OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGVhZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG52YXIgUmVnaXN0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIFRleHRCbG90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUZXh0QmxvdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXh0QmxvdChub2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5vZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRleHQgPSBfdGhpcy5zdGF0aWNzLnZhbHVlKF90aGlzLmRvbU5vZGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRleHRCbG90LmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICAgIH07XG4gICAgVGV4dEJsb3QudmFsdWUgPSBmdW5jdGlvbiAoZG9tTm9kZSkge1xuICAgICAgICB2YXIgdGV4dCA9IGRvbU5vZGUuZGF0YTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAodGV4dFsnbm9ybWFsaXplJ10pXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dFsnbm9ybWFsaXplJ10oKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICBUZXh0QmxvdC5wcm90b3R5cGUuZGVsZXRlQXQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgICB0aGlzLmRvbU5vZGUuZGF0YSA9IHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBpbmRleCkgKyB0aGlzLnRleHQuc2xpY2UoaW5kZXggKyBsZW5ndGgpO1xuICAgIH07XG4gICAgVGV4dEJsb3QucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24gKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5kb21Ob2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIFRleHRCbG90LnByb3RvdHlwZS5pbnNlcnRBdCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUsIGRlZikge1xuICAgICAgICBpZiAoZGVmID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBpbmRleCkgKyB2YWx1ZSArIHRoaXMudGV4dC5zbGljZShpbmRleCk7XG4gICAgICAgICAgICB0aGlzLmRvbU5vZGUuZGF0YSA9IHRoaXMudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW5zZXJ0QXQuY2FsbCh0aGlzLCBpbmRleCwgdmFsdWUsIGRlZik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRCbG90LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQubGVuZ3RoO1xuICAgIH07XG4gICAgVGV4dEJsb3QucHJvdG90eXBlLm9wdGltaXplID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vcHRpbWl6ZS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnN0YXRpY3MudmFsdWUodGhpcy5kb21Ob2RlKTtcbiAgICAgICAgaWYgKHRoaXMudGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0IGluc3RhbmNlb2YgVGV4dEJsb3QgJiYgdGhpcy5uZXh0LnByZXYgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0QXQodGhpcy5sZW5ndGgoKSwgdGhpcy5uZXh0LnZhbHVlKCkpO1xuICAgICAgICAgICAgdGhpcy5uZXh0LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0QmxvdC5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAoaW5kZXgsIGluY2x1c2l2ZSkge1xuICAgICAgICBpZiAoaW5jbHVzaXZlID09PSB2b2lkIDApIHsgaW5jbHVzaXZlID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIFt0aGlzLmRvbU5vZGUsIGluZGV4XTtcbiAgICB9O1xuICAgIFRleHRCbG90LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChpbmRleCwgZm9yY2UpIHtcbiAgICAgICAgaWYgKGZvcmNlID09PSB2b2lkIDApIHsgZm9yY2UgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoIWZvcmNlKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMubGVuZ3RoKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWZ0ZXIgPSBSZWdpc3RyeS5jcmVhdGUodGhpcy5kb21Ob2RlLnNwbGl0VGV4dChpbmRleCkpO1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYWZ0ZXIsIHRoaXMubmV4dCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMuc3RhdGljcy52YWx1ZSh0aGlzLmRvbU5vZGUpO1xuICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgfTtcbiAgICBUZXh0QmxvdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobXV0YXRpb25zLnNvbWUoZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbXV0YXRpb24udHlwZSA9PT0gJ2NoYXJhY3RlckRhdGEnICYmIG11dGF0aW9uLnRhcmdldCA9PT0gX3RoaXMuZG9tTm9kZTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHRoaXMuc3RhdGljcy52YWx1ZSh0aGlzLmRvbU5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0QmxvdC5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfTtcbiAgICBUZXh0QmxvdC5ibG90TmFtZSA9ICd0ZXh0JztcbiAgICBUZXh0QmxvdC5zY29wZSA9IFJlZ2lzdHJ5LlNjb3BlLklOTElORV9CTE9UO1xuICAgIHJldHVybiBUZXh0QmxvdDtcbn0obGVhZl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRleHRCbG90O1xuXG5cbi8qKiovIH0pLFxuLyogNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbmVsZW0uY2xhc3NMaXN0LnRvZ2dsZSgndGVzdC1jbGFzcycsIGZhbHNlKTtcbmlmIChlbGVtLmNsYXNzTGlzdC5jb250YWlucygndGVzdC1jbGFzcycpKSB7XG4gIHZhciBfdG9nZ2xlID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGU7XG4gIERPTVRva2VuTGlzdC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKHRva2VuLCBmb3JjZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiAhdGhpcy5jb250YWlucyh0b2tlbikgPT09ICFmb3JjZSkge1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX3RvZ2dsZS5jYWxsKHRoaXMsIHRva2VuKTtcbiAgICB9XG4gIH07XG59XG5cbmlmICghU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKSB7XG4gIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiB8fCAwO1xuICAgIHJldHVybiB0aGlzLnN1YnN0cihwb3NpdGlvbiwgc2VhcmNoU3RyaW5nLmxlbmd0aCkgPT09IHNlYXJjaFN0cmluZztcbiAgfTtcbn1cblxuaWYgKCFTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKSB7XG4gIFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGggPSBmdW5jdGlvbiAoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICAgIHZhciBzdWJqZWN0U3RyaW5nID0gdGhpcy50b1N0cmluZygpO1xuICAgIGlmICh0eXBlb2YgcG9zaXRpb24gIT09ICdudW1iZXInIHx8ICFpc0Zpbml0ZShwb3NpdGlvbikgfHwgTWF0aC5mbG9vcihwb3NpdGlvbikgIT09IHBvc2l0aW9uIHx8IHBvc2l0aW9uID4gc3ViamVjdFN0cmluZy5sZW5ndGgpIHtcbiAgICAgIHBvc2l0aW9uID0gc3ViamVjdFN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIHBvc2l0aW9uIC09IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gICAgdmFyIGxhc3RJbmRleCA9IHN1YmplY3RTdHJpbmcuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gbGFzdEluZGV4ICE9PSAtMSAmJiBsYXN0SW5kZXggPT09IHBvc2l0aW9uO1xuICB9O1xufVxuXG5pZiAoIUFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsIFwiZmluZFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHByZWRpY2F0ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLmZpbmQgY2FsbGVkIG9uIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcmVkaWNhdGUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgICB2YXIgbGlzdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aCA+Pj4gMDtcbiAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpLCBsaXN0KSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xufVxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBmdW5jdGlvbiAoKSB7XG4gIC8vIERpc2FibGUgcmVzaXppbmcgaW4gRmlyZWZveFxuICBkb2N1bWVudC5leGVjQ29tbWFuZChcImVuYWJsZU9iamVjdFJlc2l6aW5nXCIsIGZhbHNlLCBmYWxzZSk7XG4gIC8vIERpc2FibGUgYXV0b21hdGljIGxpbmtpZnlpbmcgaW4gSUUxMVxuICBkb2N1bWVudC5leGVjQ29tbWFuZChcImF1dG9VcmxEZXRlY3RcIiwgZmFsc2UsIGZhbHNlKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogVGhpcyBsaWJyYXJ5IG1vZGlmaWVzIHRoZSBkaWZmLXBhdGNoLW1hdGNoIGxpYnJhcnkgYnkgTmVpbCBGcmFzZXJcbiAqIGJ5IHJlbW92aW5nIHRoZSBwYXRjaCBhbmQgbWF0Y2ggZnVuY3Rpb25hbGl0eSBhbmQgY2VydGFpbiBhZHZhbmNlZFxuICogb3B0aW9ucyBpbiB0aGUgZGlmZiBmdW5jdGlvbi4gVGhlIG9yaWdpbmFsIGxpY2Vuc2UgaXMgYXMgZm9sbG93czpcbiAqXG4gKiA9PT1cbiAqXG4gKiBEaWZmIE1hdGNoIGFuZCBQYXRjaFxuICpcbiAqIENvcHlyaWdodCAyMDA2IEdvb2dsZSBJbmMuXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWRpZmYtbWF0Y2gtcGF0Y2gvXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbi8qKlxuICogVGhlIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhIGRpZmYgaXMgYW4gYXJyYXkgb2YgdHVwbGVzOlxuICogW1tESUZGX0RFTEVURSwgJ0hlbGxvJ10sIFtESUZGX0lOU0VSVCwgJ0dvb2RieWUnXSwgW0RJRkZfRVFVQUwsICcgd29ybGQuJ11dXG4gKiB3aGljaCBtZWFuczogZGVsZXRlICdIZWxsbycsIGFkZCAnR29vZGJ5ZScgYW5kIGtlZXAgJyB3b3JsZC4nXG4gKi9cbnZhciBESUZGX0RFTEVURSA9IC0xO1xudmFyIERJRkZfSU5TRVJUID0gMTtcbnZhciBESUZGX0VRVUFMID0gMDtcblxuXG4vKipcbiAqIEZpbmQgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIHRleHRzLiAgU2ltcGxpZmllcyB0aGUgcHJvYmxlbSBieSBzdHJpcHBpbmdcbiAqIGFueSBjb21tb24gcHJlZml4IG9yIHN1ZmZpeCBvZmYgdGhlIHRleHRzIGJlZm9yZSBkaWZmaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtJbnR9IGN1cnNvcl9wb3MgRXhwZWN0ZWQgZWRpdCBwb3NpdGlvbiBpbiB0ZXh0MSAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbmZ1bmN0aW9uIGRpZmZfbWFpbih0ZXh0MSwgdGV4dDIsIGN1cnNvcl9wb3MpIHtcbiAgLy8gQ2hlY2sgZm9yIGVxdWFsaXR5IChzcGVlZHVwKS5cbiAgaWYgKHRleHQxID09IHRleHQyKSB7XG4gICAgaWYgKHRleHQxKSB7XG4gICAgICByZXR1cm4gW1tESUZGX0VRVUFMLCB0ZXh0MV1dO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvLyBDaGVjayBjdXJzb3JfcG9zIHdpdGhpbiBib3VuZHNcbiAgaWYgKGN1cnNvcl9wb3MgPCAwIHx8IHRleHQxLmxlbmd0aCA8IGN1cnNvcl9wb3MpIHtcbiAgICBjdXJzb3JfcG9zID0gbnVsbDtcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGNvbW1vbiBwcmVmaXggKHNwZWVkdXApLlxuICB2YXIgY29tbW9ubGVuZ3RoID0gZGlmZl9jb21tb25QcmVmaXgodGV4dDEsIHRleHQyKTtcbiAgdmFyIGNvbW1vbnByZWZpeCA9IHRleHQxLnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuXG4gIC8vIFRyaW0gb2ZmIGNvbW1vbiBzdWZmaXggKHNwZWVkdXApLlxuICBjb21tb25sZW5ndGggPSBkaWZmX2NvbW1vblN1ZmZpeCh0ZXh0MSwgdGV4dDIpO1xuICB2YXIgY29tbW9uc3VmZml4ID0gdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKDAsIHRleHQxLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQyLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCk7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgZGlmZiBvbiB0aGUgbWlkZGxlIGJsb2NrLlxuICB2YXIgZGlmZnMgPSBkaWZmX2NvbXB1dGVfKHRleHQxLCB0ZXh0Mik7XG5cbiAgLy8gUmVzdG9yZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gIGlmIChjb21tb25wcmVmaXgpIHtcbiAgICBkaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBjb21tb25wcmVmaXhdKTtcbiAgfVxuICBpZiAoY29tbW9uc3VmZml4KSB7XG4gICAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgY29tbW9uc3VmZml4XSk7XG4gIH1cbiAgZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICBpZiAoY3Vyc29yX3BvcyAhPSBudWxsKSB7XG4gICAgZGlmZnMgPSBmaXhfY3Vyc29yKGRpZmZzLCBjdXJzb3JfcG9zKTtcbiAgfVxuICBkaWZmcyA9IGZpeF9lbW9qaShkaWZmcyk7XG4gIHJldHVybiBkaWZmcztcbn07XG5cblxuLyoqXG4gKiBGaW5kIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byB0ZXh0cy4gIEFzc3VtZXMgdGhhdCB0aGUgdGV4dHMgZG8gbm90XG4gKiBoYXZlIGFueSBjb21tb24gcHJlZml4IG9yIHN1ZmZpeC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZnVuY3Rpb24gZGlmZl9jb21wdXRlXyh0ZXh0MSwgdGV4dDIpIHtcbiAgdmFyIGRpZmZzO1xuXG4gIGlmICghdGV4dDEpIHtcbiAgICAvLyBKdXN0IGFkZCBzb21lIHRleHQgKHNwZWVkdXApLlxuICAgIHJldHVybiBbW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuICB9XG5cbiAgaWYgKCF0ZXh0Mikge1xuICAgIC8vIEp1c3QgZGVsZXRlIHNvbWUgdGV4dCAoc3BlZWR1cCkuXG4gICAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXV07XG4gIH1cblxuICB2YXIgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyO1xuICB2YXIgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MTtcbiAgdmFyIGkgPSBsb25ndGV4dC5pbmRleE9mKHNob3J0dGV4dCk7XG4gIGlmIChpICE9IC0xKSB7XG4gICAgLy8gU2hvcnRlciB0ZXh0IGlzIGluc2lkZSB0aGUgbG9uZ2VyIHRleHQgKHNwZWVkdXApLlxuICAgIGRpZmZzID0gW1tESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpXSxcbiAgICAgICAgICAgICBbRElGRl9FUVVBTCwgc2hvcnR0ZXh0XSxcbiAgICAgICAgICAgICBbRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgc2hvcnR0ZXh0Lmxlbmd0aCldXTtcbiAgICAvLyBTd2FwIGluc2VydGlvbnMgZm9yIGRlbGV0aW9ucyBpZiBkaWZmIGlzIHJldmVyc2VkLlxuICAgIGlmICh0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGgpIHtcbiAgICAgIGRpZmZzWzBdWzBdID0gZGlmZnNbMl1bMF0gPSBESUZGX0RFTEVURTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmZzO1xuICB9XG5cbiAgaWYgKHNob3J0dGV4dC5sZW5ndGggPT0gMSkge1xuICAgIC8vIFNpbmdsZSBjaGFyYWN0ZXIgc3RyaW5nLlxuICAgIC8vIEFmdGVyIHRoZSBwcmV2aW91cyBzcGVlZHVwLCB0aGUgY2hhcmFjdGVyIGNhbid0IGJlIGFuIGVxdWFsaXR5LlxuICAgIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV0sIFtESUZGX0lOU0VSVCwgdGV4dDJdXTtcbiAgfVxuXG4gIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgcHJvYmxlbSBjYW4gYmUgc3BsaXQgaW4gdHdvLlxuICB2YXIgaG0gPSBkaWZmX2hhbGZNYXRjaF8odGV4dDEsIHRleHQyKTtcbiAgaWYgKGhtKSB7XG4gICAgLy8gQSBoYWxmLW1hdGNoIHdhcyBmb3VuZCwgc29ydCBvdXQgdGhlIHJldHVybiBkYXRhLlxuICAgIHZhciB0ZXh0MV9hID0gaG1bMF07XG4gICAgdmFyIHRleHQxX2IgPSBobVsxXTtcbiAgICB2YXIgdGV4dDJfYSA9IGhtWzJdO1xuICAgIHZhciB0ZXh0Ml9iID0gaG1bM107XG4gICAgdmFyIG1pZF9jb21tb24gPSBobVs0XTtcbiAgICAvLyBTZW5kIGJvdGggcGFpcnMgb2ZmIGZvciBzZXBhcmF0ZSBwcm9jZXNzaW5nLlxuICAgIHZhciBkaWZmc19hID0gZGlmZl9tYWluKHRleHQxX2EsIHRleHQyX2EpO1xuICAgIHZhciBkaWZmc19iID0gZGlmZl9tYWluKHRleHQxX2IsIHRleHQyX2IpO1xuICAgIC8vIE1lcmdlIHRoZSByZXN1bHRzLlxuICAgIHJldHVybiBkaWZmc19hLmNvbmNhdChbW0RJRkZfRVFVQUwsIG1pZF9jb21tb25dXSwgZGlmZnNfYik7XG4gIH1cblxuICByZXR1cm4gZGlmZl9iaXNlY3RfKHRleHQxLCB0ZXh0Mik7XG59O1xuXG5cbi8qKlxuICogRmluZCB0aGUgJ21pZGRsZSBzbmFrZScgb2YgYSBkaWZmLCBzcGxpdCB0aGUgcHJvYmxlbSBpbiB0d29cbiAqIGFuZCByZXR1cm4gdGhlIHJlY3Vyc2l2ZWx5IGNvbnN0cnVjdGVkIGRpZmYuXG4gKiBTZWUgTXllcnMgMTk4NiBwYXBlcjogQW4gTyhORCkgRGlmZmVyZW5jZSBBbGdvcml0aG0gYW5kIEl0cyBWYXJpYXRpb25zLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGlmZl9iaXNlY3RfKHRleHQxLCB0ZXh0Mikge1xuICAvLyBDYWNoZSB0aGUgdGV4dCBsZW5ndGhzIHRvIHByZXZlbnQgbXVsdGlwbGUgY2FsbHMuXG4gIHZhciB0ZXh0MV9sZW5ndGggPSB0ZXh0MS5sZW5ndGg7XG4gIHZhciB0ZXh0Ml9sZW5ndGggPSB0ZXh0Mi5sZW5ndGg7XG4gIHZhciBtYXhfZCA9IE1hdGguY2VpbCgodGV4dDFfbGVuZ3RoICsgdGV4dDJfbGVuZ3RoKSAvIDIpO1xuICB2YXIgdl9vZmZzZXQgPSBtYXhfZDtcbiAgdmFyIHZfbGVuZ3RoID0gMiAqIG1heF9kO1xuICB2YXIgdjEgPSBuZXcgQXJyYXkodl9sZW5ndGgpO1xuICB2YXIgdjIgPSBuZXcgQXJyYXkodl9sZW5ndGgpO1xuICAvLyBTZXR0aW5nIGFsbCBlbGVtZW50cyB0byAtMSBpcyBmYXN0ZXIgaW4gQ2hyb21lICYgRmlyZWZveCB0aGFuIG1peGluZ1xuICAvLyBpbnRlZ2VycyBhbmQgdW5kZWZpbmVkLlxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHZfbGVuZ3RoOyB4KyspIHtcbiAgICB2MVt4XSA9IC0xO1xuICAgIHYyW3hdID0gLTE7XG4gIH1cbiAgdjFbdl9vZmZzZXQgKyAxXSA9IDA7XG4gIHYyW3Zfb2Zmc2V0ICsgMV0gPSAwO1xuICB2YXIgZGVsdGEgPSB0ZXh0MV9sZW5ndGggLSB0ZXh0Ml9sZW5ndGg7XG4gIC8vIElmIHRoZSB0b3RhbCBudW1iZXIgb2YgY2hhcmFjdGVycyBpcyBvZGQsIHRoZW4gdGhlIGZyb250IHBhdGggd2lsbCBjb2xsaWRlXG4gIC8vIHdpdGggdGhlIHJldmVyc2UgcGF0aC5cbiAgdmFyIGZyb250ID0gKGRlbHRhICUgMiAhPSAwKTtcbiAgLy8gT2Zmc2V0cyBmb3Igc3RhcnQgYW5kIGVuZCBvZiBrIGxvb3AuXG4gIC8vIFByZXZlbnRzIG1hcHBpbmcgb2Ygc3BhY2UgYmV5b25kIHRoZSBncmlkLlxuICB2YXIgazFzdGFydCA9IDA7XG4gIHZhciBrMWVuZCA9IDA7XG4gIHZhciBrMnN0YXJ0ID0gMDtcbiAgdmFyIGsyZW5kID0gMDtcbiAgZm9yICh2YXIgZCA9IDA7IGQgPCBtYXhfZDsgZCsrKSB7XG4gICAgLy8gV2FsayB0aGUgZnJvbnQgcGF0aCBvbmUgc3RlcC5cbiAgICBmb3IgKHZhciBrMSA9IC1kICsgazFzdGFydDsgazEgPD0gZCAtIGsxZW5kOyBrMSArPSAyKSB7XG4gICAgICB2YXIgazFfb2Zmc2V0ID0gdl9vZmZzZXQgKyBrMTtcbiAgICAgIHZhciB4MTtcbiAgICAgIGlmIChrMSA9PSAtZCB8fCAoazEgIT0gZCAmJiB2MVtrMV9vZmZzZXQgLSAxXSA8IHYxW2sxX29mZnNldCArIDFdKSkge1xuICAgICAgICB4MSA9IHYxW2sxX29mZnNldCArIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDEgPSB2MVtrMV9vZmZzZXQgLSAxXSArIDE7XG4gICAgICB9XG4gICAgICB2YXIgeTEgPSB4MSAtIGsxO1xuICAgICAgd2hpbGUgKHgxIDwgdGV4dDFfbGVuZ3RoICYmIHkxIDwgdGV4dDJfbGVuZ3RoICYmXG4gICAgICAgICAgICAgdGV4dDEuY2hhckF0KHgxKSA9PSB0ZXh0Mi5jaGFyQXQoeTEpKSB7XG4gICAgICAgIHgxKys7XG4gICAgICAgIHkxKys7XG4gICAgICB9XG4gICAgICB2MVtrMV9vZmZzZXRdID0geDE7XG4gICAgICBpZiAoeDEgPiB0ZXh0MV9sZW5ndGgpIHtcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgcmlnaHQgb2YgdGhlIGdyYXBoLlxuICAgICAgICBrMWVuZCArPSAyO1xuICAgICAgfSBlbHNlIGlmICh5MSA+IHRleHQyX2xlbmd0aCkge1xuICAgICAgICAvLyBSYW4gb2ZmIHRoZSBib3R0b20gb2YgdGhlIGdyYXBoLlxuICAgICAgICBrMXN0YXJ0ICs9IDI7XG4gICAgICB9IGVsc2UgaWYgKGZyb250KSB7XG4gICAgICAgIHZhciBrMl9vZmZzZXQgPSB2X29mZnNldCArIGRlbHRhIC0gazE7XG4gICAgICAgIGlmIChrMl9vZmZzZXQgPj0gMCAmJiBrMl9vZmZzZXQgPCB2X2xlbmd0aCAmJiB2MltrMl9vZmZzZXRdICE9IC0xKSB7XG4gICAgICAgICAgLy8gTWlycm9yIHgyIG9udG8gdG9wLWxlZnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICAgICAgdmFyIHgyID0gdGV4dDFfbGVuZ3RoIC0gdjJbazJfb2Zmc2V0XTtcbiAgICAgICAgICBpZiAoeDEgPj0geDIpIHtcbiAgICAgICAgICAgIC8vIE92ZXJsYXAgZGV0ZWN0ZWQuXG4gICAgICAgICAgICByZXR1cm4gZGlmZl9iaXNlY3RTcGxpdF8odGV4dDEsIHRleHQyLCB4MSwgeTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdhbGsgdGhlIHJldmVyc2UgcGF0aCBvbmUgc3RlcC5cbiAgICBmb3IgKHZhciBrMiA9IC1kICsgazJzdGFydDsgazIgPD0gZCAtIGsyZW5kOyBrMiArPSAyKSB7XG4gICAgICB2YXIgazJfb2Zmc2V0ID0gdl9vZmZzZXQgKyBrMjtcbiAgICAgIHZhciB4MjtcbiAgICAgIGlmIChrMiA9PSAtZCB8fCAoazIgIT0gZCAmJiB2MltrMl9vZmZzZXQgLSAxXSA8IHYyW2syX29mZnNldCArIDFdKSkge1xuICAgICAgICB4MiA9IHYyW2syX29mZnNldCArIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB2MltrMl9vZmZzZXQgLSAxXSArIDE7XG4gICAgICB9XG4gICAgICB2YXIgeTIgPSB4MiAtIGsyO1xuICAgICAgd2hpbGUgKHgyIDwgdGV4dDFfbGVuZ3RoICYmIHkyIDwgdGV4dDJfbGVuZ3RoICYmXG4gICAgICAgICAgICAgdGV4dDEuY2hhckF0KHRleHQxX2xlbmd0aCAtIHgyIC0gMSkgPT1cbiAgICAgICAgICAgICB0ZXh0Mi5jaGFyQXQodGV4dDJfbGVuZ3RoIC0geTIgLSAxKSkge1xuICAgICAgICB4MisrO1xuICAgICAgICB5MisrO1xuICAgICAgfVxuICAgICAgdjJbazJfb2Zmc2V0XSA9IHgyO1xuICAgICAgaWYgKHgyID4gdGV4dDFfbGVuZ3RoKSB7XG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIGxlZnQgb2YgdGhlIGdyYXBoLlxuICAgICAgICBrMmVuZCArPSAyO1xuICAgICAgfSBlbHNlIGlmICh5MiA+IHRleHQyX2xlbmd0aCkge1xuICAgICAgICAvLyBSYW4gb2ZmIHRoZSB0b3Agb2YgdGhlIGdyYXBoLlxuICAgICAgICBrMnN0YXJ0ICs9IDI7XG4gICAgICB9IGVsc2UgaWYgKCFmcm9udCkge1xuICAgICAgICB2YXIgazFfb2Zmc2V0ID0gdl9vZmZzZXQgKyBkZWx0YSAtIGsyO1xuICAgICAgICBpZiAoazFfb2Zmc2V0ID49IDAgJiYgazFfb2Zmc2V0IDwgdl9sZW5ndGggJiYgdjFbazFfb2Zmc2V0XSAhPSAtMSkge1xuICAgICAgICAgIHZhciB4MSA9IHYxW2sxX29mZnNldF07XG4gICAgICAgICAgdmFyIHkxID0gdl9vZmZzZXQgKyB4MSAtIGsxX29mZnNldDtcbiAgICAgICAgICAvLyBNaXJyb3IgeDIgb250byB0b3AtbGVmdCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgICAgICB4MiA9IHRleHQxX2xlbmd0aCAtIHgyO1xuICAgICAgICAgIGlmICh4MSA+PSB4Mikge1xuICAgICAgICAgICAgLy8gT3ZlcmxhcCBkZXRlY3RlZC5cbiAgICAgICAgICAgIHJldHVybiBkaWZmX2Jpc2VjdFNwbGl0Xyh0ZXh0MSwgdGV4dDIsIHgxLCB5MSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIERpZmYgdG9vayB0b28gbG9uZyBhbmQgaGl0IHRoZSBkZWFkbGluZSBvclxuICAvLyBudW1iZXIgb2YgZGlmZnMgZXF1YWxzIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBubyBjb21tb25hbGl0eSBhdCBhbGwuXG4gIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV0sIFtESUZGX0lOU0VSVCwgdGV4dDJdXTtcbn07XG5cblxuLyoqXG4gKiBHaXZlbiB0aGUgbG9jYXRpb24gb2YgdGhlICdtaWRkbGUgc25ha2UnLCBzcGxpdCB0aGUgZGlmZiBpbiB0d28gcGFydHNcbiAqIGFuZCByZWN1cnNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHggSW5kZXggb2Ygc3BsaXQgcG9pbnQgaW4gdGV4dDEuXG4gKiBAcGFyYW0ge251bWJlcn0geSBJbmRleCBvZiBzcGxpdCBwb2ludCBpbiB0ZXh0Mi5cbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZnVuY3Rpb24gZGlmZl9iaXNlY3RTcGxpdF8odGV4dDEsIHRleHQyLCB4LCB5KSB7XG4gIHZhciB0ZXh0MWEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgeCk7XG4gIHZhciB0ZXh0MmEgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgeSk7XG4gIHZhciB0ZXh0MWIgPSB0ZXh0MS5zdWJzdHJpbmcoeCk7XG4gIHZhciB0ZXh0MmIgPSB0ZXh0Mi5zdWJzdHJpbmcoeSk7XG5cbiAgLy8gQ29tcHV0ZSBib3RoIGRpZmZzIHNlcmlhbGx5LlxuICB2YXIgZGlmZnMgPSBkaWZmX21haW4odGV4dDFhLCB0ZXh0MmEpO1xuICB2YXIgZGlmZnNiID0gZGlmZl9tYWluKHRleHQxYiwgdGV4dDJiKTtcblxuICByZXR1cm4gZGlmZnMuY29uY2F0KGRpZmZzYik7XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBjb21tb24gcHJlZml4IG9mIHR3byBzdHJpbmdzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29tbW9uIHRvIHRoZSBzdGFydCBvZiBlYWNoXG4gKiAgICAgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBkaWZmX2NvbW1vblByZWZpeCh0ZXh0MSwgdGV4dDIpIHtcbiAgLy8gUXVpY2sgY2hlY2sgZm9yIGNvbW1vbiBudWxsIGNhc2VzLlxuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MS5jaGFyQXQoMCkgIT0gdGV4dDIuY2hhckF0KDApKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gQmluYXJ5IHNlYXJjaC5cbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHA6Ly9uZWlsLmZyYXNlci5uYW1lL25ld3MvMjAwNy8xMC8wOS9cbiAgdmFyIHBvaW50ZXJtaW4gPSAwO1xuICB2YXIgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcbiAgdmFyIHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xuICB2YXIgcG9pbnRlcnN0YXJ0ID0gMDtcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG4gICAgaWYgKHRleHQxLnN1YnN0cmluZyhwb2ludGVyc3RhcnQsIHBvaW50ZXJtaWQpID09XG4gICAgICAgIHRleHQyLnN1YnN0cmluZyhwb2ludGVyc3RhcnQsIHBvaW50ZXJtaWQpKSB7XG4gICAgICBwb2ludGVybWluID0gcG9pbnRlcm1pZDtcbiAgICAgIHBvaW50ZXJzdGFydCA9IHBvaW50ZXJtaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xuICAgIH1cbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xuICB9XG4gIHJldHVybiBwb2ludGVybWlkO1xufTtcblxuXG4vKipcbiAqIERldGVybWluZSB0aGUgY29tbW9uIHN1ZmZpeCBvZiB0d28gc3RyaW5ncy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgZW5kIG9mIGVhY2ggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBkaWZmX2NvbW1vblN1ZmZpeCh0ZXh0MSwgdGV4dDIpIHtcbiAgLy8gUXVpY2sgY2hlY2sgZm9yIGNvbW1vbiBudWxsIGNhc2VzLlxuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fFxuICAgICAgdGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIDEpICE9IHRleHQyLmNoYXJBdCh0ZXh0Mi5sZW5ndGggLSAxKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIEJpbmFyeSBzZWFyY2guXG4gIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMDcvMTAvMDkvXG4gIHZhciBwb2ludGVybWluID0gMDtcbiAgdmFyIHBvaW50ZXJtYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XG4gIHZhciBwb2ludGVybWlkID0gcG9pbnRlcm1heDtcbiAgdmFyIHBvaW50ZXJlbmQgPSAwO1xuICB3aGlsZSAocG9pbnRlcm1pbiA8IHBvaW50ZXJtaWQpIHtcbiAgICBpZiAodGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHBvaW50ZXJtaWQsIHRleHQxLmxlbmd0aCAtIHBvaW50ZXJlbmQpID09XG4gICAgICAgIHRleHQyLnN1YnN0cmluZyh0ZXh0Mi5sZW5ndGggLSBwb2ludGVybWlkLCB0ZXh0Mi5sZW5ndGggLSBwb2ludGVyZW5kKSkge1xuICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XG4gICAgICBwb2ludGVyZW5kID0gcG9pbnRlcm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRlcm1heCA9IHBvaW50ZXJtaWQ7XG4gICAgfVxuICAgIHBvaW50ZXJtaWQgPSBNYXRoLmZsb29yKChwb2ludGVybWF4IC0gcG9pbnRlcm1pbikgLyAyICsgcG9pbnRlcm1pbik7XG4gIH1cbiAgcmV0dXJuIHBvaW50ZXJtaWQ7XG59O1xuXG5cbi8qKlxuICogRG8gdGhlIHR3byB0ZXh0cyBzaGFyZSBhIHN1YnN0cmluZyB3aGljaCBpcyBhdCBsZWFzdCBoYWxmIHRoZSBsZW5ndGggb2YgdGhlXG4gKiBsb25nZXIgdGV4dD9cbiAqIFRoaXMgc3BlZWR1cCBjYW4gcHJvZHVjZSBub24tbWluaW1hbCBkaWZmcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBGaXZlIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlIHByZWZpeCBvZlxuICogICAgIHRleHQxLCB0aGUgc3VmZml4IG9mIHRleHQxLCB0aGUgcHJlZml4IG9mIHRleHQyLCB0aGUgc3VmZml4IG9mXG4gKiAgICAgdGV4dDIgYW5kIHRoZSBjb21tb24gbWlkZGxlLiAgT3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gbWF0Y2guXG4gKi9cbmZ1bmN0aW9uIGRpZmZfaGFsZk1hdGNoXyh0ZXh0MSwgdGV4dDIpIHtcbiAgdmFyIGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0MjtcbiAgdmFyIHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gIGlmIChsb25ndGV4dC5sZW5ndGggPCA0IHx8IHNob3J0dGV4dC5sZW5ndGggKiAyIDwgbG9uZ3RleHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7ICAvLyBQb2ludGxlc3MuXG4gIH1cblxuICAvKipcbiAgICogRG9lcyBhIHN1YnN0cmluZyBvZiBzaG9ydHRleHQgZXhpc3Qgd2l0aGluIGxvbmd0ZXh0IHN1Y2ggdGhhdCB0aGUgc3Vic3RyaW5nXG4gICAqIGlzIGF0IGxlYXN0IGhhbGYgdGhlIGxlbmd0aCBvZiBsb25ndGV4dD9cbiAgICogQ2xvc3VyZSwgYnV0IGRvZXMgbm90IHJlZmVyZW5jZSBhbnkgZXh0ZXJuYWwgdmFyaWFibGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9uZ3RleHQgTG9uZ2VyIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNob3J0dGV4dCBTaG9ydGVyIHN0cmluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgU3RhcnQgaW5kZXggb2YgcXVhcnRlciBsZW5ndGggc3Vic3RyaW5nIHdpdGhpbiBsb25ndGV4dC5cbiAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEZpdmUgZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGUgcHJlZml4IG9mXG4gICAqICAgICBsb25ndGV4dCwgdGhlIHN1ZmZpeCBvZiBsb25ndGV4dCwgdGhlIHByZWZpeCBvZiBzaG9ydHRleHQsIHRoZSBzdWZmaXhcbiAgICogICAgIG9mIHNob3J0dGV4dCBhbmQgdGhlIGNvbW1vbiBtaWRkbGUuICBPciBudWxsIGlmIHRoZXJlIHdhcyBubyBtYXRjaC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGRpZmZfaGFsZk1hdGNoSV8obG9uZ3RleHQsIHNob3J0dGV4dCwgaSkge1xuICAgIC8vIFN0YXJ0IHdpdGggYSAxLzQgbGVuZ3RoIHN1YnN0cmluZyBhdCBwb3NpdGlvbiBpIGFzIGEgc2VlZC5cbiAgICB2YXIgc2VlZCA9IGxvbmd0ZXh0LnN1YnN0cmluZyhpLCBpICsgTWF0aC5mbG9vcihsb25ndGV4dC5sZW5ndGggLyA0KSk7XG4gICAgdmFyIGogPSAtMTtcbiAgICB2YXIgYmVzdF9jb21tb24gPSAnJztcbiAgICB2YXIgYmVzdF9sb25ndGV4dF9hLCBiZXN0X2xvbmd0ZXh0X2IsIGJlc3Rfc2hvcnR0ZXh0X2EsIGJlc3Rfc2hvcnR0ZXh0X2I7XG4gICAgd2hpbGUgKChqID0gc2hvcnR0ZXh0LmluZGV4T2Yoc2VlZCwgaiArIDEpKSAhPSAtMSkge1xuICAgICAgdmFyIHByZWZpeExlbmd0aCA9IGRpZmZfY29tbW9uUHJlZml4KGxvbmd0ZXh0LnN1YnN0cmluZyhpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKGopKTtcbiAgICAgIHZhciBzdWZmaXhMZW5ndGggPSBkaWZmX2NvbW1vblN1ZmZpeChsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnR0ZXh0LnN1YnN0cmluZygwLCBqKSk7XG4gICAgICBpZiAoYmVzdF9jb21tb24ubGVuZ3RoIDwgc3VmZml4TGVuZ3RoICsgcHJlZml4TGVuZ3RoKSB7XG4gICAgICAgIGJlc3RfY29tbW9uID0gc2hvcnR0ZXh0LnN1YnN0cmluZyhqIC0gc3VmZml4TGVuZ3RoLCBqKSArXG4gICAgICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKGosIGogKyBwcmVmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X2xvbmd0ZXh0X2EgPSBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSAtIHN1ZmZpeExlbmd0aCk7XG4gICAgICAgIGJlc3RfbG9uZ3RleHRfYiA9IGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgcHJlZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9zaG9ydHRleHRfYSA9IHNob3J0dGV4dC5zdWJzdHJpbmcoMCwgaiAtIHN1ZmZpeExlbmd0aCk7XG4gICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2IgPSBzaG9ydHRleHQuc3Vic3RyaW5nKGogKyBwcmVmaXhMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmVzdF9jb21tb24ubGVuZ3RoICogMiA+PSBsb25ndGV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbYmVzdF9sb25ndGV4dF9hLCBiZXN0X2xvbmd0ZXh0X2IsXG4gICAgICAgICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2EsIGJlc3Rfc2hvcnR0ZXh0X2IsIGJlc3RfY29tbW9uXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIHNlY29uZCBxdWFydGVyIGlzIHRoZSBzZWVkIGZvciBhIGhhbGYtbWF0Y2guXG4gIHZhciBobTEgPSBkaWZmX2hhbGZNYXRjaElfKGxvbmd0ZXh0LCBzaG9ydHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyA0KSk7XG4gIC8vIENoZWNrIGFnYWluIGJhc2VkIG9uIHRoZSB0aGlyZCBxdWFydGVyLlxuICB2YXIgaG0yID0gZGlmZl9oYWxmTWF0Y2hJXyhsb25ndGV4dCwgc2hvcnR0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmNlaWwobG9uZ3RleHQubGVuZ3RoIC8gMikpO1xuICB2YXIgaG07XG4gIGlmICghaG0xICYmICFobTIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmICghaG0yKSB7XG4gICAgaG0gPSBobTE7XG4gIH0gZWxzZSBpZiAoIWhtMSkge1xuICAgIGhtID0gaG0yO1xuICB9IGVsc2Uge1xuICAgIC8vIEJvdGggbWF0Y2hlZC4gIFNlbGVjdCB0aGUgbG9uZ2VzdC5cbiAgICBobSA9IGhtMVs0XS5sZW5ndGggPiBobTJbNF0ubGVuZ3RoID8gaG0xIDogaG0yO1xuICB9XG5cbiAgLy8gQSBoYWxmLW1hdGNoIHdhcyBmb3VuZCwgc29ydCBvdXQgdGhlIHJldHVybiBkYXRhLlxuICB2YXIgdGV4dDFfYSwgdGV4dDFfYiwgdGV4dDJfYSwgdGV4dDJfYjtcbiAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xuICAgIHRleHQxX2EgPSBobVswXTtcbiAgICB0ZXh0MV9iID0gaG1bMV07XG4gICAgdGV4dDJfYSA9IGhtWzJdO1xuICAgIHRleHQyX2IgPSBobVszXTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0Ml9hID0gaG1bMF07XG4gICAgdGV4dDJfYiA9IGhtWzFdO1xuICAgIHRleHQxX2EgPSBobVsyXTtcbiAgICB0ZXh0MV9iID0gaG1bM107XG4gIH1cbiAgdmFyIG1pZF9jb21tb24gPSBobVs0XTtcbiAgcmV0dXJuIFt0ZXh0MV9hLCB0ZXh0MV9iLCB0ZXh0Ml9hLCB0ZXh0Ml9iLCBtaWRfY29tbW9uXTtcbn07XG5cblxuLyoqXG4gKiBSZW9yZGVyIGFuZCBtZXJnZSBsaWtlIGVkaXQgc2VjdGlvbnMuICBNZXJnZSBlcXVhbGl0aWVzLlxuICogQW55IGVkaXQgc2VjdGlvbiBjYW4gbW92ZSBhcyBsb25nIGFzIGl0IGRvZXNuJ3QgY3Jvc3MgYW4gZXF1YWxpdHkuXG4gKiBAcGFyYW0ge0FycmF5fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZnVuY3Rpb24gZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpIHtcbiAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgJyddKTsgIC8vIEFkZCBhIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gIHZhciBwb2ludGVyID0gMDtcbiAgdmFyIGNvdW50X2RlbGV0ZSA9IDA7XG4gIHZhciBjb3VudF9pbnNlcnQgPSAwO1xuICB2YXIgdGV4dF9kZWxldGUgPSAnJztcbiAgdmFyIHRleHRfaW5zZXJ0ID0gJyc7XG4gIHZhciBjb21tb25sZW5ndGg7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgY291bnRfaW5zZXJ0Kys7XG4gICAgICAgIHRleHRfaW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgY291bnRfZGVsZXRlKys7XG4gICAgICAgIHRleHRfZGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICAvLyBVcG9uIHJlYWNoaW5nIGFuIGVxdWFsaXR5LCBjaGVjayBmb3IgcHJpb3IgcmVkdW5kYW5jaWVzLlxuICAgICAgICBpZiAoY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0ID4gMSkge1xuICAgICAgICAgIGlmIChjb3VudF9kZWxldGUgIT09IDAgJiYgY291bnRfaW5zZXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBGYWN0b3Igb3V0IGFueSBjb21tb24gcHJlZml4aWVzLlxuICAgICAgICAgICAgY29tbW9ubGVuZ3RoID0gZGlmZl9jb21tb25QcmVmaXgodGV4dF9pbnNlcnQsIHRleHRfZGVsZXRlKTtcbiAgICAgICAgICAgIGlmIChjb21tb25sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgaWYgKChwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0KSA+IDAgJiZcbiAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQgLSAxXVswXSA9PVxuICAgICAgICAgICAgICAgICAgRElGRl9FUVVBTCkge1xuICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQgLSAxXVsxXSArPVxuICAgICAgICAgICAgICAgICAgICB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UoMCwgMCwgW0RJRkZfRVFVQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKV0pO1xuICAgICAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0ZXh0X2luc2VydCA9IHRleHRfaW5zZXJ0LnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9IHRleHRfZGVsZXRlLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmFjdG9yIG91dCBhbnkgY29tbW9uIHN1ZmZpeGllcy5cbiAgICAgICAgICAgIGNvbW1vbmxlbmd0aCA9IGRpZmZfY29tbW9uU3VmZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKHRleHRfaW5zZXJ0Lmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpICsgZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgICAgIHRleHRfaW5zZXJ0ID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIHRleHRfaW5zZXJ0Lmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9IHRleHRfZGVsZXRlLnN1YnN0cmluZygwLCB0ZXh0X2RlbGV0ZS5sZW5ndGggLVxuICAgICAgICAgICAgICAgICAgY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRGVsZXRlIHRoZSBvZmZlbmRpbmcgcmVjb3JkcyBhbmQgYWRkIHRoZSBtZXJnZWQgb25lcy5cbiAgICAgICAgICBpZiAoY291bnRfZGVsZXRlID09PSAwKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2luc2VydCxcbiAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQsIFtESUZGX0lOU0VSVCwgdGV4dF9pbnNlcnRdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50X2luc2VydCA9PT0gMCkge1xuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9kZWxldGUsXG4gICAgICAgICAgICAgICAgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0LCBbRElGRl9ERUxFVEUsIHRleHRfZGVsZXRlXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LFxuICAgICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCwgW0RJRkZfREVMRVRFLCB0ZXh0X2RlbGV0ZV0sXG4gICAgICAgICAgICAgICAgW0RJRkZfSU5TRVJULCB0ZXh0X2luc2VydF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludGVyID0gcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCArXG4gICAgICAgICAgICAgICAgICAgIChjb3VudF9kZWxldGUgPyAxIDogMCkgKyAoY291bnRfaW5zZXJ0ID8gMSA6IDApICsgMTtcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyICE9PSAwICYmIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgLy8gTWVyZ2UgdGhpcyBlcXVhbGl0eSB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRfaW5zZXJ0ID0gMDtcbiAgICAgICAgY291bnRfZGVsZXRlID0gMDtcbiAgICAgICAgdGV4dF9kZWxldGUgPSAnJztcbiAgICAgICAgdGV4dF9pbnNlcnQgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSA9PT0gJycpIHtcbiAgICBkaWZmcy5wb3AoKTsgIC8vIFJlbW92ZSB0aGUgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cbiAgfVxuXG4gIC8vIFNlY29uZCBwYXNzOiBsb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcbiAgLy8gd2hpY2ggY2FuIGJlIHNoaWZ0ZWQgc2lkZXdheXMgdG8gZWxpbWluYXRlIGFuIGVxdWFsaXR5LlxuICAvLyBlLmc6IEE8aW5zPkJBPC9pbnM+QyAtPiA8aW5zPkFCPC9pbnM+QUNcbiAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcbiAgcG9pbnRlciA9IDE7XG4gIC8vIEludGVudGlvbmFsbHkgaWdub3JlIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50IChkb24ndCBuZWVkIGNoZWNraW5nKS5cbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMICYmXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PSBESUZGX0VRVUFMKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIGVkaXQgc3Vycm91bmRlZCBieSBlcXVhbGl0aWVzLlxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLVxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpID09IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSkge1xuICAgICAgICAvLyBTaGlmdCB0aGUgZWRpdCBvdmVyIHRoZSBwcmV2aW91cyBlcXVhbGl0eS5cbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gK1xuICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCk7XG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArIGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKTtcbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSA9PVxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSkge1xuICAgICAgICAvLyBTaGlmdCB0aGUgZWRpdCBvdmVyIHRoZSBuZXh0IGVxdWFsaXR5LlxuICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9XG4gICAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgK1xuICAgICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIC8vIElmIHNoaWZ0cyB3ZXJlIG1hZGUsIHRoZSBkaWZmIG5lZWRzIHJlb3JkZXJpbmcgYW5kIGFub3RoZXIgc2hpZnQgc3dlZXAuXG4gIGlmIChjaGFuZ2VzKSB7XG4gICAgZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICB9XG59O1xuXG5cbnZhciBkaWZmID0gZGlmZl9tYWluO1xuZGlmZi5JTlNFUlQgPSBESUZGX0lOU0VSVDtcbmRpZmYuREVMRVRFID0gRElGRl9ERUxFVEU7XG5kaWZmLkVRVUFMID0gRElGRl9FUVVBTDtcblxubW9kdWxlLmV4cG9ydHMgPSBkaWZmO1xuXG4vKlxuICogTW9kaWZ5IGEgZGlmZiBzdWNoIHRoYXQgdGhlIGN1cnNvciBwb3NpdGlvbiBwb2ludHMgdG8gdGhlIHN0YXJ0IG9mIGEgY2hhbmdlOlxuICogRS5nLlxuICogICBjdXJzb3Jfbm9ybWFsaXplX2RpZmYoW1tESUZGX0VRVUFMLCAnYWJjJ11dLCAxKVxuICogICAgID0+IFsxLCBbW0RJRkZfRVFVQUwsICdhJ10sIFtESUZGX0VRVUFMLCAnYmMnXV1dXG4gKiAgIGN1cnNvcl9ub3JtYWxpemVfZGlmZihbW0RJRkZfSU5TRVJULCAnbmV3J10sIFtESUZGX0RFTEVURSwgJ3h5eiddXSwgMilcbiAqICAgICA9PiBbMiwgW1tESUZGX0lOU0VSVCwgJ25ldyddLCBbRElGRl9ERUxFVEUsICd4eSddLCBbRElGRl9ERUxFVEUsICd6J11dXVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKiBAcGFyYW0ge0ludH0gY3Vyc29yX3BvcyBTdWdnZXN0ZWQgZWRpdCBwb3NpdGlvbi4gTXVzdCBub3QgYmUgb3V0IG9mIGJvdW5kcyFcbiAqIEByZXR1cm4ge0FycmF5fSBBIHR1cGxlIFtjdXJzb3IgbG9jYXRpb24gaW4gdGhlIG1vZGlmaWVkIGRpZmYsIG1vZGlmaWVkIGRpZmZdXG4gKi9cbmZ1bmN0aW9uIGN1cnNvcl9ub3JtYWxpemVfZGlmZiAoZGlmZnMsIGN1cnNvcl9wb3MpIHtcbiAgaWYgKGN1cnNvcl9wb3MgPT09IDApIHtcbiAgICByZXR1cm4gW0RJRkZfRVFVQUwsIGRpZmZzXTtcbiAgfVxuICBmb3IgKHZhciBjdXJyZW50X3BvcyA9IDAsIGkgPSAwOyBpIDwgZGlmZnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZCA9IGRpZmZzW2ldO1xuICAgIGlmIChkWzBdID09PSBESUZGX0RFTEVURSB8fCBkWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICB2YXIgbmV4dF9wb3MgPSBjdXJyZW50X3BvcyArIGRbMV0ubGVuZ3RoO1xuICAgICAgaWYgKGN1cnNvcl9wb3MgPT09IG5leHRfcG9zKSB7XG4gICAgICAgIHJldHVybiBbaSArIDEsIGRpZmZzXTtcbiAgICAgIH0gZWxzZSBpZiAoY3Vyc29yX3BvcyA8IG5leHRfcG9zKSB7XG4gICAgICAgIC8vIGNvcHkgdG8gcHJldmVudCBzaWRlIGVmZmVjdHNcbiAgICAgICAgZGlmZnMgPSBkaWZmcy5zbGljZSgpO1xuICAgICAgICAvLyBzcGxpdCBkIGludG8gdHdvIGRpZmYgY2hhbmdlc1xuICAgICAgICB2YXIgc3BsaXRfcG9zID0gY3Vyc29yX3BvcyAtIGN1cnJlbnRfcG9zO1xuICAgICAgICB2YXIgZF9sZWZ0ID0gW2RbMF0sIGRbMV0uc2xpY2UoMCwgc3BsaXRfcG9zKV07XG4gICAgICAgIHZhciBkX3JpZ2h0ID0gW2RbMF0sIGRbMV0uc2xpY2Uoc3BsaXRfcG9zKV07XG4gICAgICAgIGRpZmZzLnNwbGljZShpLCAxLCBkX2xlZnQsIGRfcmlnaHQpO1xuICAgICAgICByZXR1cm4gW2kgKyAxLCBkaWZmc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50X3BvcyA9IG5leHRfcG9zO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnNvcl9wb3MgaXMgb3V0IG9mIGJvdW5kcyEnKVxufVxuXG4vKlxuICogTW9kaWZ5IGEgZGlmZiBzdWNoIHRoYXQgdGhlIGVkaXQgcG9zaXRpb24gaXMgXCJzaGlmdGVkXCIgdG8gdGhlIHByb3Bvc2VkIGVkaXQgbG9jYXRpb24gKGN1cnNvcl9wb3NpdGlvbikuXG4gKlxuICogQ2FzZSAxKVxuICogICBDaGVjayBpZiBhIG5haXZlIHNoaWZ0IGlzIHBvc3NpYmxlOlxuICogICAgIFswLCBYXSwgWyAxLCBZXSAtPiBbIDEsIFldLCBbMCwgWF0gICAgKGlmIFggKyBZID09PSBZICsgWClcbiAqICAgICBbMCwgWF0sIFstMSwgWV0gLT4gWy0xLCBZXSwgWzAsIFhdICAgIChpZiBYICsgWSA9PT0gWSArIFgpIC0gaG9sZHMgc2FtZSByZXN1bHRcbiAqIENhc2UgMilcbiAqICAgQ2hlY2sgaWYgdGhlIGZvbGxvd2luZyBzaGlmdHMgYXJlIHBvc3NpYmxlOlxuICogICAgIFswLCAncHJlJ10sIFsgMSwgJ3ByZWZpeCddIC0+IFsgMSwgJ3ByZSddLCBbMCwgJ3ByZSddLCBbIDEsICdmaXgnXVxuICogICAgIFswLCAncHJlJ10sIFstMSwgJ3ByZWZpeCddIC0+IFstMSwgJ3ByZSddLCBbMCwgJ3ByZSddLCBbLTEsICdmaXgnXVxuICogICAgICAgICBeICAgICAgICAgICAgXlxuICogICAgICAgICBkICAgICAgICAgIGRfbmV4dFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKiBAcGFyYW0ge0ludH0gY3Vyc29yX3BvcyBTdWdnZXN0ZWQgZWRpdCBwb3NpdGlvbi4gTXVzdCBub3QgYmUgb3V0IG9mIGJvdW5kcyFcbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICovXG5mdW5jdGlvbiBmaXhfY3Vyc29yIChkaWZmcywgY3Vyc29yX3Bvcykge1xuICB2YXIgbm9ybSA9IGN1cnNvcl9ub3JtYWxpemVfZGlmZihkaWZmcywgY3Vyc29yX3Bvcyk7XG4gIHZhciBuZGlmZnMgPSBub3JtWzFdO1xuICB2YXIgY3Vyc29yX3BvaW50ZXIgPSBub3JtWzBdO1xuICB2YXIgZCA9IG5kaWZmc1tjdXJzb3JfcG9pbnRlcl07XG4gIHZhciBkX25leHQgPSBuZGlmZnNbY3Vyc29yX3BvaW50ZXIgKyAxXTtcblxuICBpZiAoZCA9PSBudWxsKSB7XG4gICAgLy8gVGV4dCB3YXMgZGVsZXRlZCBmcm9tIGVuZCBvZiBvcmlnaW5hbCBzdHJpbmcsXG4gICAgLy8gY3Vyc29yIGlzIG5vdyBvdXQgb2YgYm91bmRzIGluIG5ldyBzdHJpbmdcbiAgICByZXR1cm4gZGlmZnM7XG4gIH0gZWxzZSBpZiAoZFswXSAhPT0gRElGRl9FUVVBTCkge1xuICAgIC8vIEEgbW9kaWZpY2F0aW9uIGhhcHBlbmVkIGF0IHRoZSBjdXJzb3IgbG9jYXRpb24uXG4gICAgLy8gVGhpcyBpcyB0aGUgZXhwZWN0ZWQgb3V0Y29tZSwgc28gd2UgY2FuIHJldHVybiB0aGUgb3JpZ2luYWwgZGlmZi5cbiAgICByZXR1cm4gZGlmZnM7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRfbmV4dCAhPSBudWxsICYmIGRbMV0gKyBkX25leHRbMV0gPT09IGRfbmV4dFsxXSArIGRbMV0pIHtcbiAgICAgIC8vIENhc2UgMSlcbiAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRvIHBlcmZvcm0gYSBuYWl2ZSBzaGlmdFxuICAgICAgbmRpZmZzLnNwbGljZShjdXJzb3JfcG9pbnRlciwgMiwgZF9uZXh0LCBkKVxuICAgICAgcmV0dXJuIG1lcmdlX3R1cGxlcyhuZGlmZnMsIGN1cnNvcl9wb2ludGVyLCAyKVxuICAgIH0gZWxzZSBpZiAoZF9uZXh0ICE9IG51bGwgJiYgZF9uZXh0WzFdLmluZGV4T2YoZFsxXSkgPT09IDApIHtcbiAgICAgIC8vIENhc2UgMilcbiAgICAgIC8vIGRbMV0gaXMgYSBwcmVmaXggb2YgZF9uZXh0WzFdXG4gICAgICAvLyBXZSBjYW4gYXNzdW1lIHRoYXQgZF9uZXh0WzBdICE9PSAwLCBzaW5jZSBkWzBdID09PSAwXG4gICAgICAvLyBTaGlmdCBlZGl0IGxvY2F0aW9ucy4uXG4gICAgICBuZGlmZnMuc3BsaWNlKGN1cnNvcl9wb2ludGVyLCAyLCBbZF9uZXh0WzBdLCBkWzFdXSwgWzAsIGRbMV1dKTtcbiAgICAgIHZhciBzdWZmaXggPSBkX25leHRbMV0uc2xpY2UoZFsxXS5sZW5ndGgpO1xuICAgICAgaWYgKHN1ZmZpeC5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5kaWZmcy5zcGxpY2UoY3Vyc29yX3BvaW50ZXIgKyAyLCAwLCBbZF9uZXh0WzBdLCBzdWZmaXhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZV90dXBsZXMobmRpZmZzLCBjdXJzb3JfcG9pbnRlciwgMylcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm90IHBvc3NpYmxlIHRvIHBlcmZvcm0gYW55IG1vZGlmaWNhdGlvblxuICAgICAgcmV0dXJuIGRpZmZzO1xuICAgIH1cbiAgfVxufVxuXG4vKlxuICogQ2hlY2sgZGlmZiBkaWQgbm90IHNwbGl0IHN1cnJvZ2F0ZSBwYWlycy5cbiAqIEV4LiBbMCwgJ1xcdUQ4M0QnXSwgWy0xLCAnXFx1REMzNiddLCBbMSwgJ1xcdURDMkYnXSAtPiBbLTEsICdcXHVEODNEXFx1REMzNiddLCBbMSwgJ1xcdUQ4M0RcXHVEQzJGJ11cbiAqICAgICAnXFx1RDgzRFxcdURDMzYnID09PSAn8J+QticsICdcXHVEODNEXFx1REMyRicgPT09ICfwn5CvJ1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgZGlmZiB0dXBsZXNcbiAqL1xuZnVuY3Rpb24gZml4X2Vtb2ppIChkaWZmcykge1xuICB2YXIgY29tcGFjdCA9IGZhbHNlO1xuICB2YXIgc3RhcnRzX3dpdGhfcGFpcl9lbmQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoMCkgPj0gMHhEQzAwICYmIHN0ci5jaGFyQ29kZUF0KDApIDw9IDB4REZGRjtcbiAgfVxuICB2YXIgZW5kc193aXRoX3BhaXJfc3RhcnQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoc3RyLmxlbmd0aC0xKSA+PSAweEQ4MDAgJiYgc3RyLmNoYXJDb2RlQXQoc3RyLmxlbmd0aC0xKSA8PSAweERCRkY7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBkaWZmcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChkaWZmc1tpLTJdWzBdID09PSBESUZGX0VRVUFMICYmIGVuZHNfd2l0aF9wYWlyX3N0YXJ0KGRpZmZzW2ktMl1bMV0pICYmXG4gICAgICAgIGRpZmZzW2ktMV1bMF0gPT09IERJRkZfREVMRVRFICYmIHN0YXJ0c193aXRoX3BhaXJfZW5kKGRpZmZzW2ktMV1bMV0pICYmXG4gICAgICAgIGRpZmZzW2ldWzBdID09PSBESUZGX0lOU0VSVCAmJiBzdGFydHNfd2l0aF9wYWlyX2VuZChkaWZmc1tpXVsxXSkpIHtcbiAgICAgIGNvbXBhY3QgPSB0cnVlO1xuXG4gICAgICBkaWZmc1tpLTFdWzFdID0gZGlmZnNbaS0yXVsxXS5zbGljZSgtMSkgKyBkaWZmc1tpLTFdWzFdO1xuICAgICAgZGlmZnNbaV1bMV0gPSBkaWZmc1tpLTJdWzFdLnNsaWNlKC0xKSArIGRpZmZzW2ldWzFdO1xuXG4gICAgICBkaWZmc1tpLTJdWzFdID0gZGlmZnNbaS0yXVsxXS5zbGljZSgwLCAtMSk7XG4gICAgfVxuICB9XG4gIGlmICghY29tcGFjdCkge1xuICAgIHJldHVybiBkaWZmcztcbiAgfVxuICB2YXIgZml4ZWRfZGlmZnMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChkaWZmc1tpXVsxXS5sZW5ndGggPiAwKSB7XG4gICAgICBmaXhlZF9kaWZmcy5wdXNoKGRpZmZzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpeGVkX2RpZmZzO1xufVxuXG4vKlxuICogVHJ5IHRvIG1lcmdlIHR1cGxlcyB3aXRoIHRoZWlyIG5laWdib3JzIGluIGEgZ2l2ZW4gcmFuZ2UuXG4gKiBFLmcuIFswLCAnYSddLCBbMCwgJ2InXSAtPiBbMCwgJ2FiJ11cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqIEBwYXJhbSB7SW50fSBzdGFydCBQb3NpdGlvbiBvZiB0aGUgZmlyc3QgZWxlbWVudCB0byBtZXJnZSAoZGlmZnNbc3RhcnRdIGlzIGFsc28gbWVyZ2VkIHdpdGggZGlmZnNbc3RhcnQgLSAxXSkuXG4gKiBAcGFyYW0ge0ludH0gbGVuZ3RoIE51bWJlciBvZiBjb25zZWN1dGl2ZSBlbGVtZW50cyB0byBjaGVjay5cbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBtZXJnZWQgZGlmZiB0dXBsZXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlX3R1cGxlcyAoZGlmZnMsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgLy8gQ2hlY2sgZnJvbSAoc3RhcnQtMSkgdG8gKHN0YXJ0K2xlbmd0aCkuXG4gIGZvciAodmFyIGkgPSBzdGFydCArIGxlbmd0aCAtIDE7IGkgPj0gMCAmJiBpID49IHN0YXJ0IC0gMTsgaS0tKSB7XG4gICAgaWYgKGkgKyAxIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgICB2YXIgbGVmdF9kID0gZGlmZnNbaV07XG4gICAgICB2YXIgcmlnaHRfZCA9IGRpZmZzW2krMV07XG4gICAgICBpZiAobGVmdF9kWzBdID09PSByaWdodF9kWzFdKSB7XG4gICAgICAgIGRpZmZzLnNwbGljZShpLCAyLCBbbGVmdF9kWzBdLCBsZWZ0X2RbMV0gKyByaWdodF9kWzFdXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWZmcztcbn1cblxuXG4vKioqLyB9KSxcbi8qIDUyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJ1xuICA/IE9iamVjdC5rZXlzIDogc2hpbTtcblxuZXhwb3J0cy5zaGltID0gc2hpbTtcbmZ1bmN0aW9uIHNoaW0gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG5cblxuLyoqKi8gfSksXG4vKiA1MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA9IChmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50cylcbn0pKCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPyBzdXBwb3J0ZWQgOiB1bnN1cHBvcnRlZDtcblxuZXhwb3J0cy5zdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG5mdW5jdGlvbiBzdXBwb3J0ZWQob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbmV4cG9ydHMudW5zdXBwb3J0ZWQgPSB1bnN1cHBvcnRlZDtcbmZ1bmN0aW9uIHVuc3VwcG9ydGVkKG9iamVjdCl7XG4gIHJldHVybiBvYmplY3QgJiZcbiAgICB0eXBlb2Ygb2JqZWN0ID09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnY2FsbGVlJykgJiZcbiAgICAhT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpIHx8XG4gICAgZmFsc2U7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGV4aXN0cyBPbmx5IGNoZWNrIGlmIHRoZXJlIGFyZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7QXJyYXl8Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50LCBleGlzdHMpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGF2YWlsYWJsZSA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChleGlzdHMpIHJldHVybiAhIWF2YWlsYWJsZTtcbiAgaWYgKCFhdmFpbGFibGUpIHJldHVybiBbXTtcbiAgaWYgKGF2YWlsYWJsZS5mbikgcmV0dXJuIFthdmFpbGFibGUuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXZhaWxhYmxlLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGF2YWlsYWJsZVtpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgdGhpcylcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgdGhpcy5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgdGhpcy5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIXRoaXMuX2V2ZW50c1tldnRdLmZuKSB0aGlzLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSB0aGlzLl9ldmVudHNbZXZ0XSA9IFt0aGlzLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IHRoaXMsIHRydWUpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHRoaXMuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIHRoaXMuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XS5mbikgdGhpcy5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgdGhpcy5fZXZlbnRzW2V2dF0gPSBbdGhpcy5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgICAgbGlzdGVuZXJzLmZuID09PSBmblxuICAgICAgJiYgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKVxuICAgICAgJiYgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICAgIGVsc2UgZGVsZXRlIHRoaXMuX2V2ZW50c1tldnRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuXG4gICAgICAgIHx8IChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSlcbiAgICAgICAgfHwgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIGVsc2UgZGVsZXRlIHRoaXMuX2V2ZW50c1tldnRdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIHtcbiAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgICBlbHNlIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIGRvZXNuJ3QgYXBwbHkgYW55bW9yZS5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuXG5cbi8qKiovIH0pLFxuLyogNTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWF0Y2hUZXh0ID0gZXhwb3J0cy5tYXRjaFNwYWNpbmcgPSBleHBvcnRzLm1hdGNoTmV3bGluZSA9IGV4cG9ydHMubWF0Y2hCbG90ID0gZXhwb3J0cy5tYXRjaEF0dHJpYnV0b3IgPSBleHBvcnRzLmRlZmF1bHQgPSB1bmRlZmluZWQ7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2V4dGVuZDIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2V4dGVuZDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmQyKTtcblxudmFyIF9xdWlsbERlbHRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9xdWlsbERlbHRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsRGVsdGEpO1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfcXVpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX3F1aWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsKTtcblxudmFyIF9sb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIF9sb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nZ2VyKTtcblxudmFyIF9tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX21vZHVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb2R1bGUpO1xuXG52YXIgX2FsaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cbnZhciBfYmFja2dyb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXG52YXIgX2NvZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIF9jb2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvZGUpO1xuXG52YXIgX2NvbG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbnZhciBfZGlyZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG5cbnZhciBfZm9udCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXG52YXIgX3NpemUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgZGVidWcgPSAoMCwgX2xvZ2dlcjIuZGVmYXVsdCkoJ3F1aWxsOmNsaXBib2FyZCcpO1xuXG52YXIgRE9NX0tFWSA9ICdfX3FsLW1hdGNoZXInO1xuXG52YXIgQ0xJUEJPQVJEX0NPTkZJRyA9IFtbTm9kZS5URVhUX05PREUsIG1hdGNoVGV4dF0sIFtOb2RlLlRFWFRfTk9ERSwgbWF0Y2hOZXdsaW5lXSwgWydicicsIG1hdGNoQnJlYWtdLCBbTm9kZS5FTEVNRU5UX05PREUsIG1hdGNoTmV3bGluZV0sIFtOb2RlLkVMRU1FTlRfTk9ERSwgbWF0Y2hCbG90XSwgW05vZGUuRUxFTUVOVF9OT0RFLCBtYXRjaFNwYWNpbmddLCBbTm9kZS5FTEVNRU5UX05PREUsIG1hdGNoQXR0cmlidXRvcl0sIFtOb2RlLkVMRU1FTlRfTk9ERSwgbWF0Y2hTdHlsZXNdLCBbJ2xpJywgbWF0Y2hJbmRlbnRdLCBbJ2InLCBtYXRjaEFsaWFzLmJpbmQobWF0Y2hBbGlhcywgJ2JvbGQnKV0sIFsnaScsIG1hdGNoQWxpYXMuYmluZChtYXRjaEFsaWFzLCAnaXRhbGljJyldLCBbJ3N0eWxlJywgbWF0Y2hJZ25vcmVdXTtcblxudmFyIEFUVFJJQlVURV9BVFRSSUJVVE9SUyA9IFtfYWxpZ24uQWxpZ25BdHRyaWJ1dGUsIF9kaXJlY3Rpb24uRGlyZWN0aW9uQXR0cmlidXRlXS5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGF0dHIpIHtcbiAgbWVtb1thdHRyLmtleU5hbWVdID0gYXR0cjtcbiAgcmV0dXJuIG1lbW87XG59LCB7fSk7XG5cbnZhciBTVFlMRV9BVFRSSUJVVE9SUyA9IFtfYWxpZ24uQWxpZ25TdHlsZSwgX2JhY2tncm91bmQuQmFja2dyb3VuZFN0eWxlLCBfY29sb3IuQ29sb3JTdHlsZSwgX2RpcmVjdGlvbi5EaXJlY3Rpb25TdHlsZSwgX2ZvbnQuRm9udFN0eWxlLCBfc2l6ZS5TaXplU3R5bGVdLnJlZHVjZShmdW5jdGlvbiAobWVtbywgYXR0cikge1xuICBtZW1vW2F0dHIua2V5TmFtZV0gPSBhdHRyO1xuICByZXR1cm4gbWVtbztcbn0sIHt9KTtcblxudmFyIENsaXBib2FyZCA9IGZ1bmN0aW9uIChfTW9kdWxlKSB7XG4gIF9pbmhlcml0cyhDbGlwYm9hcmQsIF9Nb2R1bGUpO1xuXG4gIGZ1bmN0aW9uIENsaXBib2FyZChxdWlsbCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGlwYm9hcmQpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENsaXBib2FyZC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENsaXBib2FyZCkpLmNhbGwodGhpcywgcXVpbGwsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnF1aWxsLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBfdGhpcy5vblBhc3RlLmJpbmQoX3RoaXMpKTtcbiAgICBfdGhpcy5jb250YWluZXIgPSBfdGhpcy5xdWlsbC5hZGRDb250YWluZXIoJ3FsLWNsaXBib2FyZCcpO1xuICAgIF90aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIHRydWUpO1xuICAgIF90aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpO1xuICAgIF90aGlzLm1hdGNoZXJzID0gW107XG4gICAgQ0xJUEJPQVJEX0NPTkZJRy5jb25jYXQoX3RoaXMub3B0aW9ucy5tYXRjaGVycykuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgc2VsZWN0b3IgPSBfcmVmMlswXSxcbiAgICAgICAgICBtYXRjaGVyID0gX3JlZjJbMV07XG5cbiAgICAgIGlmICghb3B0aW9ucy5tYXRjaFZpc3VhbCAmJiBtYXRjaGVyID09PSBtYXRjaFNwYWNpbmcpIHJldHVybjtcbiAgICAgIF90aGlzLmFkZE1hdGNoZXIoc2VsZWN0b3IsIG1hdGNoZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDbGlwYm9hcmQsIFt7XG4gICAga2V5OiAnYWRkTWF0Y2hlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE1hdGNoZXIoc2VsZWN0b3IsIG1hdGNoZXIpIHtcbiAgICAgIHRoaXMubWF0Y2hlcnMucHVzaChbc2VsZWN0b3IsIG1hdGNoZXJdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb252ZXJ0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udmVydChodG1sKSB7XG4gICAgICBpZiAodHlwZW9mIGh0bWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWwucmVwbGFjZSgvXFw+XFxyP1xcbiArXFw8L2csICc+PCcpOyAvLyBSZW1vdmUgc3BhY2VzIGJldHdlZW4gdGFnc1xuICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0KCk7XG4gICAgICB9XG4gICAgICB2YXIgZm9ybWF0cyA9IHRoaXMucXVpbGwuZ2V0Rm9ybWF0KHRoaXMucXVpbGwuc2VsZWN0aW9uLnNhdmVkUmFuZ2UuaW5kZXgpO1xuICAgICAgaWYgKGZvcm1hdHNbX2NvZGUyLmRlZmF1bHQuYmxvdE5hbWVdKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5jb250YWluZXIuaW5uZXJUZXh0O1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgcmV0dXJuIG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLmluc2VydCh0ZXh0LCBfZGVmaW5lUHJvcGVydHkoe30sIF9jb2RlMi5kZWZhdWx0LmJsb3ROYW1lLCBmb3JtYXRzW19jb2RlMi5kZWZhdWx0LmJsb3ROYW1lXSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3ByZXBhcmVNYXRjaGluZyA9IHRoaXMucHJlcGFyZU1hdGNoaW5nKCksXG4gICAgICAgICAgX3ByZXBhcmVNYXRjaGluZzIgPSBfc2xpY2VkVG9BcnJheShfcHJlcGFyZU1hdGNoaW5nLCAyKSxcbiAgICAgICAgICBlbGVtZW50TWF0Y2hlcnMgPSBfcHJlcGFyZU1hdGNoaW5nMlswXSxcbiAgICAgICAgICB0ZXh0TWF0Y2hlcnMgPSBfcHJlcGFyZU1hdGNoaW5nMlsxXTtcblxuICAgICAgdmFyIGRlbHRhID0gdHJhdmVyc2UodGhpcy5jb250YWluZXIsIGVsZW1lbnRNYXRjaGVycywgdGV4dE1hdGNoZXJzKTtcbiAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBuZXdsaW5lXG4gICAgICBpZiAoZGVsdGFFbmRzV2l0aChkZWx0YSwgJ1xcbicpICYmIGRlbHRhLm9wc1tkZWx0YS5vcHMubGVuZ3RoIC0gMV0uYXR0cmlidXRlcyA9PSBudWxsKSB7XG4gICAgICAgIGRlbHRhID0gZGVsdGEuY29tcG9zZShuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4oZGVsdGEubGVuZ3RoKCkgLSAxKS5kZWxldGUoMSkpO1xuICAgICAgfVxuICAgICAgZGVidWcubG9nKCdjb252ZXJ0JywgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MLCBkZWx0YSk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkYW5nZXJvdXNseVBhc3RlSFRNTCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRhbmdlcm91c2x5UGFzdGVIVE1MKGluZGV4LCBodG1sKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5BUEk7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0Q29udGVudHModGhpcy5jb252ZXJ0KGluZGV4KSwgaHRtbCk7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKDAsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGFzdGUgPSB0aGlzLmNvbnZlcnQoaHRtbCk7XG4gICAgICAgIHRoaXMucXVpbGwudXBkYXRlQ29udGVudHMobmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKGluZGV4KS5jb25jYXQocGFzdGUpLCBzb3VyY2UpO1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihpbmRleCArIHBhc3RlLmxlbmd0aCgpLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uUGFzdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblBhc3RlKGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkIHx8ICF0aGlzLnF1aWxsLmlzRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnF1aWxsLmdldFNlbGVjdGlvbigpO1xuICAgICAgdmFyIGRlbHRhID0gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkucmV0YWluKHJhbmdlLmluZGV4KTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLnF1aWxsLnNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3A7XG4gICAgICB0aGlzLmNvbnRhaW5lci5mb2N1cygpO1xuICAgICAgdGhpcy5xdWlsbC5zZWxlY3Rpb24udXBkYXRlKF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVsdGEgPSBkZWx0YS5jb25jYXQoX3RoaXMyLmNvbnZlcnQoKSkuZGVsZXRlKHJhbmdlLmxlbmd0aCk7XG4gICAgICAgIF90aGlzMi5xdWlsbC51cGRhdGVDb250ZW50cyhkZWx0YSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgIC8vIHJhbmdlLmxlbmd0aCBjb250cmlidXRlcyB0byBkZWx0YS5sZW5ndGgoKVxuICAgICAgICBfdGhpczIucXVpbGwuc2V0U2VsZWN0aW9uKGRlbHRhLmxlbmd0aCgpIC0gcmFuZ2UubGVuZ3RoLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICAgICAgICBfdGhpczIucXVpbGwuc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgX3RoaXMyLnF1aWxsLmZvY3VzKCk7XG4gICAgICB9LCAxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwcmVwYXJlTWF0Y2hpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwYXJlTWF0Y2hpbmcoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuICAgICAgICAgIHRleHRNYXRjaGVycyA9IFtdO1xuICAgICAgdGhpcy5tYXRjaGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgIHZhciBfcGFpciA9IF9zbGljZWRUb0FycmF5KHBhaXIsIDIpLFxuICAgICAgICAgICAgc2VsZWN0b3IgPSBfcGFpclswXSxcbiAgICAgICAgICAgIG1hdGNoZXIgPSBfcGFpclsxXTtcblxuICAgICAgICBzd2l0Y2ggKHNlbGVjdG9yKSB7XG4gICAgICAgICAgY2FzZSBOb2RlLlRFWFRfTk9ERTpcbiAgICAgICAgICAgIHRleHRNYXRjaGVycy5wdXNoKG1hdGNoZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERTpcbiAgICAgICAgICAgIGVsZW1lbnRNYXRjaGVycy5wdXNoKG1hdGNoZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIFtdLmZvckVhY2guY2FsbChfdGhpczMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAvLyBUT0RPIHVzZSB3ZWFrbWFwXG4gICAgICAgICAgICAgIG5vZGVbRE9NX0tFWV0gPSBub2RlW0RPTV9LRVldIHx8IFtdO1xuICAgICAgICAgICAgICBub2RlW0RPTV9LRVldLnB1c2gobWF0Y2hlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbZWxlbWVudE1hdGNoZXJzLCB0ZXh0TWF0Y2hlcnNdO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDbGlwYm9hcmQ7XG59KF9tb2R1bGUyLmRlZmF1bHQpO1xuXG5DbGlwYm9hcmQuREVGQVVMVFMgPSB7XG4gIG1hdGNoZXJzOiBbXSxcbiAgbWF0Y2hWaXN1YWw6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGFwcGx5Rm9ybWF0KGRlbHRhLCBmb3JtYXQsIHZhbHVlKSB7XG4gIGlmICgodHlwZW9mIGZvcm1hdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZm9ybWF0KSkgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGZvcm1hdCkucmVkdWNlKGZ1bmN0aW9uIChkZWx0YSwga2V5KSB7XG4gICAgICByZXR1cm4gYXBwbHlGb3JtYXQoZGVsdGEsIGtleSwgZm9ybWF0W2tleV0pO1xuICAgIH0sIGRlbHRhKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVsdGEucmVkdWNlKGZ1bmN0aW9uIChkZWx0YSwgb3ApIHtcbiAgICAgIGlmIChvcC5hdHRyaWJ1dGVzICYmIG9wLmF0dHJpYnV0ZXNbZm9ybWF0XSkge1xuICAgICAgICByZXR1cm4gZGVsdGEucHVzaChvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVsdGEuaW5zZXJ0KG9wLmluc2VydCwgKDAsIF9leHRlbmQzLmRlZmF1bHQpKHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGZvcm1hdCwgdmFsdWUpLCBvcC5hdHRyaWJ1dGVzKSk7XG4gICAgICB9XG4gICAgfSwgbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZShub2RlKSB7XG4gIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkgcmV0dXJuIHt9O1xuICB2YXIgRE9NX0tFWSA9ICdfX3FsLWNvbXB1dGVkLXN0eWxlJztcbiAgcmV0dXJuIG5vZGVbRE9NX0tFWV0gfHwgKG5vZGVbRE9NX0tFWV0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKSk7XG59XG5cbmZ1bmN0aW9uIGRlbHRhRW5kc1dpdGgoZGVsdGEsIHRleHQpIHtcbiAgdmFyIGVuZFRleHQgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gZGVsdGEub3BzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiBlbmRUZXh0Lmxlbmd0aCA8IHRleHQubGVuZ3RoOyAtLWkpIHtcbiAgICB2YXIgb3AgPSBkZWx0YS5vcHNbaV07XG4gICAgaWYgKHR5cGVvZiBvcC5pbnNlcnQgIT09ICdzdHJpbmcnKSBicmVhaztcbiAgICBlbmRUZXh0ID0gb3AuaW5zZXJ0ICsgZW5kVGV4dDtcbiAgfVxuICByZXR1cm4gZW5kVGV4dC5zbGljZSgtMSAqIHRleHQubGVuZ3RoKSA9PT0gdGV4dDtcbn1cblxuZnVuY3Rpb24gaXNMaW5lKG5vZGUpIHtcbiAgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTsgLy8gRXhjbHVkZSBlbWJlZCBibG9ja3NcbiAgdmFyIHN0eWxlID0gY29tcHV0ZVN0eWxlKG5vZGUpO1xuICByZXR1cm4gWydibG9jaycsICdsaXN0LWl0ZW0nXS5pbmRleE9mKHN0eWxlLmRpc3BsYXkpID4gLTE7XG59XG5cbmZ1bmN0aW9uIHRyYXZlcnNlKG5vZGUsIGVsZW1lbnRNYXRjaGVycywgdGV4dE1hdGNoZXJzKSB7XG4gIC8vIFBvc3Qtb3JkZXJcbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGUuVEVYVF9OT0RFKSB7XG4gICAgcmV0dXJuIHRleHRNYXRjaGVycy5yZWR1Y2UoZnVuY3Rpb24gKGRlbHRhLCBtYXRjaGVyKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcihub2RlLCBkZWx0YSk7XG4gICAgfSwgbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCkpO1xuICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIFtdLnJlZHVjZS5jYWxsKG5vZGUuY2hpbGROb2RlcyB8fCBbXSwgZnVuY3Rpb24gKGRlbHRhLCBjaGlsZE5vZGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbkRlbHRhID0gdHJhdmVyc2UoY2hpbGROb2RlLCBlbGVtZW50TWF0Y2hlcnMsIHRleHRNYXRjaGVycyk7XG4gICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSBub2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICBjaGlsZHJlbkRlbHRhID0gZWxlbWVudE1hdGNoZXJzLnJlZHVjZShmdW5jdGlvbiAoY2hpbGRyZW5EZWx0YSwgbWF0Y2hlcikge1xuICAgICAgICAgIHJldHVybiBtYXRjaGVyKGNoaWxkTm9kZSwgY2hpbGRyZW5EZWx0YSk7XG4gICAgICAgIH0sIGNoaWxkcmVuRGVsdGEpO1xuICAgICAgICBjaGlsZHJlbkRlbHRhID0gKGNoaWxkTm9kZVtET01fS0VZXSB8fCBbXSkucmVkdWNlKGZ1bmN0aW9uIChjaGlsZHJlbkRlbHRhLCBtYXRjaGVyKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoZXIoY2hpbGROb2RlLCBjaGlsZHJlbkRlbHRhKTtcbiAgICAgICAgfSwgY2hpbGRyZW5EZWx0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVsdGEuY29uY2F0KGNoaWxkcmVuRGVsdGEpO1xuICAgIH0sIG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IF9xdWlsbERlbHRhMi5kZWZhdWx0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hBbGlhcyhmb3JtYXQsIG5vZGUsIGRlbHRhKSB7XG4gIHJldHVybiBhcHBseUZvcm1hdChkZWx0YSwgZm9ybWF0LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hBdHRyaWJ1dG9yKG5vZGUsIGRlbHRhKSB7XG4gIHZhciBhdHRyaWJ1dGVzID0gX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLkF0dHJpYnV0ZS5rZXlzKG5vZGUpO1xuICB2YXIgY2xhc3NlcyA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5DbGFzcy5rZXlzKG5vZGUpO1xuICB2YXIgc3R5bGVzID0gX3BhcmNobWVudDIuZGVmYXVsdC5BdHRyaWJ1dG9yLlN0eWxlLmtleXMobm9kZSk7XG4gIHZhciBmb3JtYXRzID0ge307XG4gIGF0dHJpYnV0ZXMuY29uY2F0KGNsYXNzZXMpLmNvbmNhdChzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgYXR0ciA9IF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkobmFtZSwgX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5BVFRSSUJVVEUpO1xuICAgIGlmIChhdHRyICE9IG51bGwpIHtcbiAgICAgIGZvcm1hdHNbYXR0ci5hdHRyTmFtZV0gPSBhdHRyLnZhbHVlKG5vZGUpO1xuICAgICAgaWYgKGZvcm1hdHNbYXR0ci5hdHRyTmFtZV0pIHJldHVybjtcbiAgICB9XG4gICAgYXR0ciA9IEFUVFJJQlVURV9BVFRSSUJVVE9SU1tuYW1lXTtcbiAgICBpZiAoYXR0ciAhPSBudWxsICYmIChhdHRyLmF0dHJOYW1lID09PSBuYW1lIHx8IGF0dHIua2V5TmFtZSA9PT0gbmFtZSkpIHtcbiAgICAgIGZvcm1hdHNbYXR0ci5hdHRyTmFtZV0gPSBhdHRyLnZhbHVlKG5vZGUpIHx8IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXR0ciA9IFNUWUxFX0FUVFJJQlVUT1JTW25hbWVdO1xuICAgIGlmIChhdHRyICE9IG51bGwgJiYgKGF0dHIuYXR0ck5hbWUgPT09IG5hbWUgfHwgYXR0ci5rZXlOYW1lID09PSBuYW1lKSkge1xuICAgICAgYXR0ciA9IFNUWUxFX0FUVFJJQlVUT1JTW25hbWVdO1xuICAgICAgZm9ybWF0c1thdHRyLmF0dHJOYW1lXSA9IGF0dHIudmFsdWUobm9kZSkgfHwgdW5kZWZpbmVkO1xuICAgIH1cbiAgfSk7XG4gIGlmIChPYmplY3Qua2V5cyhmb3JtYXRzKS5sZW5ndGggPiAwKSB7XG4gICAgZGVsdGEgPSBhcHBseUZvcm1hdChkZWx0YSwgZm9ybWF0cyk7XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBtYXRjaEJsb3Qobm9kZSwgZGVsdGEpIHtcbiAgdmFyIG1hdGNoID0gX3BhcmNobWVudDIuZGVmYXVsdC5xdWVyeShub2RlKTtcbiAgaWYgKG1hdGNoID09IG51bGwpIHJldHVybiBkZWx0YTtcbiAgaWYgKG1hdGNoLnByb3RvdHlwZSBpbnN0YW5jZW9mIF9wYXJjaG1lbnQyLmRlZmF1bHQuRW1iZWQpIHtcbiAgICB2YXIgZW1iZWQgPSB7fTtcbiAgICB2YXIgdmFsdWUgPSBtYXRjaC52YWx1ZShub2RlKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgZW1iZWRbbWF0Y2guYmxvdE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWx0YSA9IG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLmluc2VydChlbWJlZCwgbWF0Y2guZm9ybWF0cyhub2RlKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtYXRjaC5mb3JtYXRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGVsdGEgPSBhcHBseUZvcm1hdChkZWx0YSwgbWF0Y2guYmxvdE5hbWUsIG1hdGNoLmZvcm1hdHMobm9kZSkpO1xuICB9XG4gIHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hCcmVhayhub2RlLCBkZWx0YSkge1xuICBpZiAoIWRlbHRhRW5kc1dpdGgoZGVsdGEsICdcXG4nKSkge1xuICAgIGRlbHRhLmluc2VydCgnXFxuJyk7XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBtYXRjaElnbm9yZSgpIHtcbiAgcmV0dXJuIG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpO1xufVxuXG5mdW5jdGlvbiBtYXRjaEluZGVudChub2RlLCBkZWx0YSkge1xuICB2YXIgbWF0Y2ggPSBfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KG5vZGUpO1xuICBpZiAobWF0Y2ggPT0gbnVsbCB8fCBtYXRjaC5ibG90TmFtZSAhPT0gJ2xpc3QtaXRlbScgfHwgIWRlbHRhRW5kc1dpdGgoZGVsdGEsICdcXG4nKSkge1xuICAgIHJldHVybiBkZWx0YTtcbiAgfVxuICB2YXIgaW5kZW50ID0gLTEsXG4gICAgICBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gIHdoaWxlICghcGFyZW50LmNsYXNzTGlzdC5jb250YWlucygncWwtY2xpcGJvYXJkJykpIHtcbiAgICBpZiAoKF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkocGFyZW50KSB8fCB7fSkuYmxvdE5hbWUgPT09ICdsaXN0Jykge1xuICAgICAgaW5kZW50ICs9IDE7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICB9XG4gIGlmIChpbmRlbnQgPD0gMCkgcmV0dXJuIGRlbHRhO1xuICByZXR1cm4gZGVsdGEuY29tcG9zZShuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5yZXRhaW4oZGVsdGEubGVuZ3RoKCkgLSAxKS5yZXRhaW4oMSwgeyBpbmRlbnQ6IGluZGVudCB9KSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoTmV3bGluZShub2RlLCBkZWx0YSkge1xuICBpZiAoIWRlbHRhRW5kc1dpdGgoZGVsdGEsICdcXG4nKSkge1xuICAgIGlmIChpc0xpbmUobm9kZSkgfHwgZGVsdGEubGVuZ3RoKCkgPiAwICYmIG5vZGUubmV4dFNpYmxpbmcgJiYgaXNMaW5lKG5vZGUubmV4dFNpYmxpbmcpKSB7XG4gICAgICBkZWx0YS5pbnNlcnQoJ1xcbicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIG1hdGNoU3BhY2luZyhub2RlLCBkZWx0YSkge1xuICBpZiAoaXNMaW5lKG5vZGUpICYmIG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nICE9IG51bGwgJiYgIWRlbHRhRW5kc1dpdGgoZGVsdGEsICdcXG5cXG4nKSkge1xuICAgIHZhciBub2RlSGVpZ2h0ID0gbm9kZS5vZmZzZXRIZWlnaHQgKyBwYXJzZUZsb2F0KGNvbXB1dGVTdHlsZShub2RlKS5tYXJnaW5Ub3ApICsgcGFyc2VGbG9hdChjb21wdXRlU3R5bGUobm9kZSkubWFyZ2luQm90dG9tKTtcbiAgICBpZiAobm9kZS5uZXh0RWxlbWVudFNpYmxpbmcub2Zmc2V0VG9wID4gbm9kZS5vZmZzZXRUb3AgKyBub2RlSGVpZ2h0ICogMS41KSB7XG4gICAgICBkZWx0YS5pbnNlcnQoJ1xcbicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIG1hdGNoU3R5bGVzKG5vZGUsIGRlbHRhKSB7XG4gIHZhciBmb3JtYXRzID0ge307XG4gIHZhciBzdHlsZSA9IG5vZGUuc3R5bGUgfHwge307XG4gIGlmIChzdHlsZS5mb250U3R5bGUgJiYgY29tcHV0ZVN0eWxlKG5vZGUpLmZvbnRTdHlsZSA9PT0gJ2l0YWxpYycpIHtcbiAgICBmb3JtYXRzLml0YWxpYyA9IHRydWU7XG4gIH1cbiAgaWYgKHN0eWxlLmZvbnRXZWlnaHQgJiYgKGNvbXB1dGVTdHlsZShub2RlKS5mb250V2VpZ2h0LnN0YXJ0c1dpdGgoJ2JvbGQnKSB8fCBwYXJzZUludChjb21wdXRlU3R5bGUobm9kZSkuZm9udFdlaWdodCkgPj0gNzAwKSkge1xuICAgIGZvcm1hdHMuYm9sZCA9IHRydWU7XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKGZvcm1hdHMpLmxlbmd0aCA+IDApIHtcbiAgICBkZWx0YSA9IGFwcGx5Rm9ybWF0KGRlbHRhLCBmb3JtYXRzKTtcbiAgfVxuICBpZiAocGFyc2VGbG9hdChzdHlsZS50ZXh0SW5kZW50IHx8IDApID4gMCkge1xuICAgIC8vIENvdWxkIGJlIDAuNWluXG4gICAgZGVsdGEgPSBuZXcgX3F1aWxsRGVsdGEyLmRlZmF1bHQoKS5pbnNlcnQoJ1xcdCcpLmNvbmNhdChkZWx0YSk7XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBtYXRjaFRleHQobm9kZSwgZGVsdGEpIHtcbiAgdmFyIHRleHQgPSBub2RlLmRhdGE7XG4gIC8vIFdvcmQgcmVwcmVzZW50cyBlbXB0eSBsaW5lIHdpdGggPG86cD4mbmJzcDs8L286cD5cbiAgaWYgKG5vZGUucGFyZW50Tm9kZS50YWdOYW1lID09PSAnTzpQJykge1xuICAgIHJldHVybiBkZWx0YS5pbnNlcnQodGV4dC50cmltKCkpO1xuICB9XG4gIGlmICh0ZXh0LnRyaW0oKS5sZW5ndGggPT09IDAgJiYgbm9kZS5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygncWwtY2xpcGJvYXJkJykpIHtcbiAgICByZXR1cm4gZGVsdGE7XG4gIH1cbiAgaWYgKCFjb21wdXRlU3R5bGUobm9kZS5wYXJlbnROb2RlKS53aGl0ZVNwYWNlLnN0YXJ0c1dpdGgoJ3ByZScpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtc3R5bGVcbiAgICB2YXIgcmVwbGFjZXIgPSBmdW5jdGlvbiByZXBsYWNlcihjb2xsYXBzZSwgbWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gbWF0Y2gucmVwbGFjZSgvW15cXHUwMGEwXS9nLCAnJyk7IC8vIFxcdTAwYTAgaXMgbmJzcDtcbiAgICAgIHJldHVybiBtYXRjaC5sZW5ndGggPCAxICYmIGNvbGxhcHNlID8gJyAnIDogbWF0Y2g7XG4gICAgfTtcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJyAnKS5yZXBsYWNlKC9cXG4vZywgJyAnKTtcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHNcXHMrL2csIHJlcGxhY2VyLmJpbmQocmVwbGFjZXIsIHRydWUpKTsgLy8gY29sbGFwc2Ugd2hpdGVzcGFjZVxuICAgIGlmIChub2RlLnByZXZpb3VzU2libGluZyA9PSBudWxsICYmIGlzTGluZShub2RlLnBhcmVudE5vZGUpIHx8IG5vZGUucHJldmlvdXNTaWJsaW5nICE9IG51bGwgJiYgaXNMaW5lKG5vZGUucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXlxccysvLCByZXBsYWNlci5iaW5kKHJlcGxhY2VyLCBmYWxzZSkpO1xuICAgIH1cbiAgICBpZiAobm9kZS5uZXh0U2libGluZyA9PSBudWxsICYmIGlzTGluZShub2RlLnBhcmVudE5vZGUpIHx8IG5vZGUubmV4dFNpYmxpbmcgIT0gbnVsbCAmJiBpc0xpbmUobm9kZS5uZXh0U2libGluZykpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xccyskLywgcmVwbGFjZXIuYmluZChyZXBsYWNlciwgZmFsc2UpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlbHRhLmluc2VydCh0ZXh0KTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2xpcGJvYXJkO1xuZXhwb3J0cy5tYXRjaEF0dHJpYnV0b3IgPSBtYXRjaEF0dHJpYnV0b3I7XG5leHBvcnRzLm1hdGNoQmxvdCA9IG1hdGNoQmxvdDtcbmV4cG9ydHMubWF0Y2hOZXdsaW5lID0gbWF0Y2hOZXdsaW5lO1xuZXhwb3J0cy5tYXRjaFNwYWNpbmcgPSBtYXRjaFNwYWNpbmc7XG5leHBvcnRzLm1hdGNoVGV4dCA9IG1hdGNoVGV4dDtcblxuLyoqKi8gfSksXG4vKiA1NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfaW5saW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9pbmxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5saW5lKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQm9sZCA9IGZ1bmN0aW9uIChfSW5saW5lKSB7XG4gIF9pbmhlcml0cyhCb2xkLCBfSW5saW5lKTtcblxuICBmdW5jdGlvbiBCb2xkKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCb2xkKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQm9sZC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJvbGQpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCb2xkLCBbe1xuICAgIGtleTogJ29wdGltaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW1pemUoY29udGV4dCkge1xuICAgICAgX2dldChCb2xkLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJvbGQucHJvdG90eXBlKSwgJ29wdGltaXplJywgdGhpcykuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIGlmICh0aGlzLmRvbU5vZGUudGFnTmFtZSAhPT0gdGhpcy5zdGF0aWNzLnRhZ05hbWVbMF0pIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlV2l0aCh0aGlzLnN0YXRpY3MuYmxvdE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnY3JlYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgcmV0dXJuIF9nZXQoQm9sZC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJvbGQpLCAnY3JlYXRlJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cygpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCb2xkO1xufShfaW5saW5lMi5kZWZhdWx0KTtcblxuQm9sZC5ibG90TmFtZSA9ICdib2xkJztcbkJvbGQudGFnTmFtZSA9IFsnU1RST05HJywgJ0InXTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQm9sZDtcblxuLyoqKi8gfSksXG4vKiA1NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGRDb250cm9scyA9IGV4cG9ydHMuZGVmYXVsdCA9IHVuZGVmaW5lZDtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3F1aWxsRGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX3F1aWxsRGVsdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGxEZWx0YSk7XG5cbnZhciBfcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9wYXJjaG1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyY2htZW50KTtcblxudmFyIF9xdWlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfcXVpbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVpbGwpO1xuXG52YXIgX2xvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgX2xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2dnZXIpO1xuXG52YXIgX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfbW9kdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGRlYnVnID0gKDAsIF9sb2dnZXIyLmRlZmF1bHQpKCdxdWlsbDp0b29sYmFyJyk7XG5cbnZhciBUb29sYmFyID0gZnVuY3Rpb24gKF9Nb2R1bGUpIHtcbiAgX2luaGVyaXRzKFRvb2xiYXIsIF9Nb2R1bGUpO1xuXG4gIGZ1bmN0aW9uIFRvb2xiYXIocXVpbGwsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbGJhcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVG9vbGJhci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRvb2xiYXIpKS5jYWxsKHRoaXMsIHF1aWxsLCBvcHRpb25zKSk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShfdGhpcy5vcHRpb25zLmNvbnRhaW5lcikpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGFkZENvbnRyb2xzKGNvbnRhaW5lciwgX3RoaXMub3B0aW9ucy5jb250YWluZXIpO1xuICAgICAgcXVpbGwuY29udGFpbmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgcXVpbGwuY29udGFpbmVyKTtcbiAgICAgIF90aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhpcy5vcHRpb25zLmNvbnRhaW5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIF90aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMub3B0aW9ucy5jb250YWluZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5jb250YWluZXIgPSBfdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICB9XG4gICAgaWYgKCEoX3RoaXMuY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICB2YXIgX3JldDtcblxuICAgICAgcmV0dXJuIF9yZXQgPSBkZWJ1Zy5lcnJvcignQ29udGFpbmVyIHJlcXVpcmVkIGZvciB0b29sYmFyJywgX3RoaXMub3B0aW9ucyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgICB9XG4gICAgX3RoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3FsLXRvb2xiYXInKTtcbiAgICBfdGhpcy5jb250cm9scyA9IFtdO1xuICAgIF90aGlzLmhhbmRsZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoX3RoaXMub3B0aW9ucy5oYW5kbGVycykuZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICBfdGhpcy5hZGRIYW5kbGVyKGZvcm1hdCwgX3RoaXMub3B0aW9ucy5oYW5kbGVyc1tmb3JtYXRdKTtcbiAgICB9KTtcbiAgICBbXS5mb3JFYWNoLmNhbGwoX3RoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbiwgc2VsZWN0JyksIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgX3RoaXMuYXR0YWNoKGlucHV0KTtcbiAgICB9KTtcbiAgICBfdGhpcy5xdWlsbC5vbihfcXVpbGwyLmRlZmF1bHQuZXZlbnRzLkVESVRPUl9DSEFOR0UsIGZ1bmN0aW9uICh0eXBlLCByYW5nZSkge1xuICAgICAgaWYgKHR5cGUgPT09IF9xdWlsbDIuZGVmYXVsdC5ldmVudHMuU0VMRUNUSU9OX0NIQU5HRSkge1xuICAgICAgICBfdGhpcy51cGRhdGUocmFuZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF90aGlzLnF1aWxsLm9uKF9xdWlsbDIuZGVmYXVsdC5ldmVudHMuU0NST0xMX09QVElNSVpFLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMkcXVpbGwkc2VsZWN0aW9uID0gX3RoaXMucXVpbGwuc2VsZWN0aW9uLmdldFJhbmdlKCksXG4gICAgICAgICAgX3RoaXMkcXVpbGwkc2VsZWN0aW9uMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJHF1aWxsJHNlbGVjdGlvbiwgMSksXG4gICAgICAgICAgcmFuZ2UgPSBfdGhpcyRxdWlsbCRzZWxlY3Rpb24yWzBdOyAvLyBxdWlsbC5nZXRTZWxlY3Rpb24gdHJpZ2dlcnMgdXBkYXRlXG5cblxuICAgICAgX3RoaXMudXBkYXRlKHJhbmdlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVG9vbGJhciwgW3tcbiAgICBrZXk6ICdhZGRIYW5kbGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSGFuZGxlcihmb3JtYXQsIGhhbmRsZXIpIHtcbiAgICAgIHRoaXMuaGFuZGxlcnNbZm9ybWF0XSA9IGhhbmRsZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXR0YWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoKGlucHV0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGZvcm1hdCA9IFtdLmZpbmQuY2FsbChpbnB1dC5jbGFzc0xpc3QsIGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZS5pbmRleE9mKCdxbC0nKSA9PT0gMDtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFmb3JtYXQpIHJldHVybjtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5zbGljZSgncWwtJy5sZW5ndGgpO1xuICAgICAgaWYgKGlucHV0LnRhZ05hbWUgPT09ICdCVVRUT04nKSB7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhbmRsZXJzW2Zvcm1hdF0gPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5xdWlsbC5zY3JvbGwud2hpdGVsaXN0ICE9IG51bGwgJiYgdGhpcy5xdWlsbC5zY3JvbGwud2hpdGVsaXN0W2Zvcm1hdF0gPT0gbnVsbCkge1xuICAgICAgICAgIGRlYnVnLndhcm4oJ2lnbm9yaW5nIGF0dGFjaGluZyB0byBkaXNhYmxlZCBmb3JtYXQnLCBmb3JtYXQsIGlucHV0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkoZm9ybWF0KSA9PSBudWxsKSB7XG4gICAgICAgICAgZGVidWcud2FybignaWdub3JpbmcgYXR0YWNoaW5nIHRvIG5vbmV4aXN0ZW50IGZvcm1hdCcsIGZvcm1hdCwgaW5wdXQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGV2ZW50TmFtZSA9IGlucHV0LnRhZ05hbWUgPT09ICdTRUxFQ1QnID8gJ2NoYW5nZScgOiAnY2xpY2snO1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGlucHV0LnRhZ05hbWUgPT09ICdTRUxFQ1QnKSB7XG4gICAgICAgICAgaWYgKGlucHV0LnNlbGVjdGVkSW5kZXggPCAwKSByZXR1cm47XG4gICAgICAgICAgdmFyIHNlbGVjdGVkID0gaW5wdXQub3B0aW9uc1tpbnB1dC5zZWxlY3RlZEluZGV4XTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWQuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHNlbGVjdGVkLnZhbHVlIHx8IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdxbC1hY3RpdmUnKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBpbnB1dC52YWx1ZSB8fCAhaW5wdXQuaGFzQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMyLnF1aWxsLmZvY3VzKCk7XG5cbiAgICAgICAgdmFyIF9xdWlsbCRzZWxlY3Rpb24kZ2V0UiA9IF90aGlzMi5xdWlsbC5zZWxlY3Rpb24uZ2V0UmFuZ2UoKSxcbiAgICAgICAgICAgIF9xdWlsbCRzZWxlY3Rpb24kZ2V0UjIgPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkc2VsZWN0aW9uJGdldFIsIDEpLFxuICAgICAgICAgICAgcmFuZ2UgPSBfcXVpbGwkc2VsZWN0aW9uJGdldFIyWzBdO1xuXG4gICAgICAgIGlmIChfdGhpczIuaGFuZGxlcnNbZm9ybWF0XSAhPSBudWxsKSB7XG4gICAgICAgICAgX3RoaXMyLmhhbmRsZXJzW2Zvcm1hdF0uY2FsbChfdGhpczIsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfcGFyY2htZW50Mi5kZWZhdWx0LnF1ZXJ5KGZvcm1hdCkucHJvdG90eXBlIGluc3RhbmNlb2YgX3BhcmNobWVudDIuZGVmYXVsdC5FbWJlZCkge1xuICAgICAgICAgIHZhbHVlID0gcHJvbXB0KCdFbnRlciAnICsgZm9ybWF0KTtcbiAgICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm47XG4gICAgICAgICAgX3RoaXMyLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKG5ldyBfcXVpbGxEZWx0YTIuZGVmYXVsdCgpLnJldGFpbihyYW5nZS5pbmRleCkuZGVsZXRlKHJhbmdlLmxlbmd0aCkuaW5zZXJ0KF9kZWZpbmVQcm9wZXJ0eSh7fSwgZm9ybWF0LCB2YWx1ZSkpLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczIucXVpbGwuZm9ybWF0KGZvcm1hdCwgdmFsdWUsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzMi51cGRhdGUocmFuZ2UpO1xuICAgICAgfSk7XG4gICAgICAvLyBUT0RPIHVzZSB3ZWFrbWFwXG4gICAgICB0aGlzLmNvbnRyb2xzLnB1c2goW2Zvcm1hdCwgaW5wdXRdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUocmFuZ2UpIHtcbiAgICAgIHZhciBmb3JtYXRzID0gcmFuZ2UgPT0gbnVsbCA/IHt9IDogdGhpcy5xdWlsbC5nZXRGb3JtYXQocmFuZ2UpO1xuICAgICAgdGhpcy5jb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgIHZhciBfcGFpciA9IF9zbGljZWRUb0FycmF5KHBhaXIsIDIpLFxuICAgICAgICAgICAgZm9ybWF0ID0gX3BhaXJbMF0sXG4gICAgICAgICAgICBpbnB1dCA9IF9wYWlyWzFdO1xuXG4gICAgICAgIGlmIChpbnB1dC50YWdOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgICAgIHZhciBvcHRpb24gPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKHJhbmdlID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbiA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXRzW2Zvcm1hdF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9uID0gaW5wdXQucXVlcnlTZWxlY3Rvcignb3B0aW9uW3NlbGVjdGVkXScpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZm9ybWF0c1tmb3JtYXRdKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZm9ybWF0c1tmb3JtYXRdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFwiL2csICdcXFxcXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbiA9IGlucHV0LnF1ZXJ5U2VsZWN0b3IoJ29wdGlvblt2YWx1ZT1cIicgKyB2YWx1ZSArICdcIl0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9ICcnOyAvLyBUT0RPIG1ha2UgY29uZmlndXJhYmxlP1xuICAgICAgICAgICAgaW5wdXQuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmFuZ2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSgncWwtYWN0aXZlJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgIC8vIGJvdGggYmVpbmcgbnVsbCBzaG91bGQgbWF0Y2ggKGRlZmF1bHQgdmFsdWVzKVxuICAgICAgICAgICAgLy8gJzEnIHNob3VsZCBtYXRjaCB3aXRoIDEgKGhlYWRlcnMpXG4gICAgICAgICAgICB2YXIgaXNBY3RpdmUgPSBmb3JtYXRzW2Zvcm1hdF0gPT09IGlucHV0LmdldEF0dHJpYnV0ZSgndmFsdWUnKSB8fCBmb3JtYXRzW2Zvcm1hdF0gIT0gbnVsbCAmJiBmb3JtYXRzW2Zvcm1hdF0udG9TdHJpbmcoKSA9PT0gaW5wdXQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpIHx8IGZvcm1hdHNbZm9ybWF0XSA9PSBudWxsICYmICFpbnB1dC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QudG9nZ2xlKCdxbC1hY3RpdmUnLCBpc0FjdGl2ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0LmNsYXNzTGlzdC50b2dnbGUoJ3FsLWFjdGl2ZScsIGZvcm1hdHNbZm9ybWF0XSAhPSBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUb29sYmFyO1xufShfbW9kdWxlMi5kZWZhdWx0KTtcblxuVG9vbGJhci5ERUZBVUxUUyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRCdXR0b24oY29udGFpbmVyLCBmb3JtYXQsIHZhbHVlKSB7XG4gIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gIGlucHV0LmNsYXNzTGlzdC5hZGQoJ3FsLScgKyBmb3JtYXQpO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGlucHV0KTtcbn1cblxuZnVuY3Rpb24gYWRkQ29udHJvbHMoY29udGFpbmVyLCBncm91cHMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGdyb3Vwc1swXSkpIHtcbiAgICBncm91cHMgPSBbZ3JvdXBzXTtcbiAgfVxuICBncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbHMpIHtcbiAgICB2YXIgZ3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgZ3JvdXAuY2xhc3NMaXN0LmFkZCgncWwtZm9ybWF0cycpO1xuICAgIGNvbnRyb2xzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgIGlmICh0eXBlb2YgY29udHJvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYWRkQnV0dG9uKGdyb3VwLCBjb250cm9sKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSBPYmplY3Qua2V5cyhjb250cm9sKVswXTtcbiAgICAgICAgdmFyIHZhbHVlID0gY29udHJvbFtmb3JtYXRdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBhZGRTZWxlY3QoZ3JvdXAsIGZvcm1hdCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEJ1dHRvbihncm91cCwgZm9ybWF0LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkU2VsZWN0KGNvbnRhaW5lciwgZm9ybWF0LCB2YWx1ZXMpIHtcbiAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gIGlucHV0LmNsYXNzTGlzdC5hZGQoJ3FsLScgKyBmb3JtYXQpO1xuICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgb3B0aW9uLnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJ3NlbGVjdGVkJyk7XG4gICAgfVxuICAgIGlucHV0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gIH0pO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xufVxuXG5Ub29sYmFyLkRFRkFVTFRTID0ge1xuICBjb250YWluZXI6IG51bGwsXG4gIGhhbmRsZXJzOiB7XG4gICAgY2xlYW46IGZ1bmN0aW9uIGNsZWFuKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAocmFuZ2UgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgaWYgKHJhbmdlLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHZhciBmb3JtYXRzID0gdGhpcy5xdWlsbC5nZXRGb3JtYXQoKTtcbiAgICAgICAgT2JqZWN0LmtleXMoZm9ybWF0cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIC8vIENsZWFuIGZ1bmN0aW9uYWxpdHkgaW4gZXhpc3RpbmcgYXBwcyBvbmx5IGNsZWFuIGlubGluZSBmb3JtYXRzXG4gICAgICAgICAgaWYgKF9wYXJjaG1lbnQyLmRlZmF1bHQucXVlcnkobmFtZSwgX3BhcmNobWVudDIuZGVmYXVsdC5TY29wZS5JTkxJTkUpICE9IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzMy5xdWlsbC5mb3JtYXQobmFtZSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnF1aWxsLnJlbW92ZUZvcm1hdChyYW5nZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaXJlY3Rpb246IGZ1bmN0aW9uIGRpcmVjdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGFsaWduID0gdGhpcy5xdWlsbC5nZXRGb3JtYXQoKVsnYWxpZ24nXTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gJ3J0bCcgJiYgYWxpZ24gPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnYWxpZ24nLCAncmlnaHQnLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH0gZWxzZSBpZiAoIXZhbHVlICYmIGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdhbGlnbicsIGZhbHNlLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdkaXJlY3Rpb24nLCB2YWx1ZSwgX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgfSxcbiAgICBpbmRlbnQ6IGZ1bmN0aW9uIGluZGVudCh2YWx1ZSkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5xdWlsbC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHZhciBmb3JtYXRzID0gdGhpcy5xdWlsbC5nZXRGb3JtYXQocmFuZ2UpO1xuICAgICAgdmFyIGluZGVudCA9IHBhcnNlSW50KGZvcm1hdHMuaW5kZW50IHx8IDApO1xuICAgICAgaWYgKHZhbHVlID09PSAnKzEnIHx8IHZhbHVlID09PSAnLTEnKSB7XG4gICAgICAgIHZhciBtb2RpZmllciA9IHZhbHVlID09PSAnKzEnID8gMSA6IC0xO1xuICAgICAgICBpZiAoZm9ybWF0cy5kaXJlY3Rpb24gPT09ICdydGwnKSBtb2RpZmllciAqPSAtMTtcbiAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2luZGVudCcsIGluZGVudCArIG1vZGlmaWVyLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uIGxpbmsodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YWx1ZSA9IHByb21wdCgnRW50ZXIgbGluayBVUkw6Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnbGluaycsIHZhbHVlLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICB9LFxuICAgIGxpc3Q6IGZ1bmN0aW9uIGxpc3QodmFsdWUpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICB2YXIgZm9ybWF0cyA9IHRoaXMucXVpbGwuZ2V0Rm9ybWF0KHJhbmdlKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gJ2NoZWNrJykge1xuICAgICAgICBpZiAoZm9ybWF0c1snbGlzdCddID09PSAnY2hlY2tlZCcgfHwgZm9ybWF0c1snbGlzdCddID09PSAndW5jaGVja2VkJykge1xuICAgICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdsaXN0JywgZmFsc2UsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdsaXN0JywgJ3VuY2hlY2tlZCcsIF9xdWlsbDIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnbGlzdCcsIHZhbHVlLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRvb2xiYXI7XG5leHBvcnRzLmFkZENvbnRyb2xzID0gYWRkQ29udHJvbHM7XG5cbi8qKiovIH0pLFxuLyogNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBvbHlsaW5lIGNsYXNzPVxcXCJxbC1ldmVuIHFsLXN0cm9rZVxcXCIgcG9pbnRzPVxcXCI1IDcgMyA5IDUgMTFcXFwiPjwvcG9seWxpbmU+IDxwb2x5bGluZSBjbGFzcz1cXFwicWwtZXZlbiBxbC1zdHJva2VcXFwiIHBvaW50cz1cXFwiMTMgNyAxNSA5IDEzIDExXFxcIj48L3BvbHlsaW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTAgeDI9OCB5MT01IHkyPTEzPjwvbGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3BpY2tlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG52YXIgX3BpY2tlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9waWNrZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDb2xvclBpY2tlciA9IGZ1bmN0aW9uIChfUGlja2VyKSB7XG4gIF9pbmhlcml0cyhDb2xvclBpY2tlciwgX1BpY2tlcik7XG5cbiAgZnVuY3Rpb24gQ29sb3JQaWNrZXIoc2VsZWN0LCBsYWJlbCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvclBpY2tlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ29sb3JQaWNrZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2xvclBpY2tlcikpLmNhbGwodGhpcywgc2VsZWN0KSk7XG5cbiAgICBfdGhpcy5sYWJlbC5pbm5lckhUTUwgPSBsYWJlbDtcbiAgICBfdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCgncWwtY29sb3ItcGlja2VyJyk7XG4gICAgW10uc2xpY2UuY2FsbChfdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLnFsLXBpY2tlci1pdGVtJyksIDAsIDcpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZCgncWwtcHJpbWFyeScpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb2xvclBpY2tlciwgW3tcbiAgICBrZXk6ICdidWlsZEl0ZW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZEl0ZW0ob3B0aW9uKSB7XG4gICAgICB2YXIgaXRlbSA9IF9nZXQoQ29sb3JQaWNrZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29sb3JQaWNrZXIucHJvdG90eXBlKSwgJ2J1aWxkSXRlbScsIHRoaXMpLmNhbGwodGhpcywgb3B0aW9uKTtcbiAgICAgIGl0ZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3B0aW9uLmdldEF0dHJpYnV0ZSgndmFsdWUnKSB8fCAnJztcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdEl0ZW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RJdGVtKGl0ZW0sIHRyaWdnZXIpIHtcbiAgICAgIF9nZXQoQ29sb3JQaWNrZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29sb3JQaWNrZXIucHJvdG90eXBlKSwgJ3NlbGVjdEl0ZW0nLCB0aGlzKS5jYWxsKHRoaXMsIGl0ZW0sIHRyaWdnZXIpO1xuICAgICAgdmFyIGNvbG9yTGFiZWwgPSB0aGlzLmxhYmVsLnF1ZXJ5U2VsZWN0b3IoJy5xbC1jb2xvci1sYWJlbCcpO1xuICAgICAgdmFyIHZhbHVlID0gaXRlbSA/IGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJykgfHwgJycgOiAnJztcbiAgICAgIGlmIChjb2xvckxhYmVsKSB7XG4gICAgICAgIGlmIChjb2xvckxhYmVsLnRhZ05hbWUgPT09ICdsaW5lJykge1xuICAgICAgICAgIGNvbG9yTGFiZWwuc3R5bGUuc3Ryb2tlID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29sb3JMYWJlbC5zdHlsZS5maWxsID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29sb3JQaWNrZXI7XG59KF9waWNrZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDb2xvclBpY2tlcjtcblxuLyoqKi8gfSksXG4vKiA2MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfcGlja2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbnZhciBfcGlja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BpY2tlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEljb25QaWNrZXIgPSBmdW5jdGlvbiAoX1BpY2tlcikge1xuICBfaW5oZXJpdHMoSWNvblBpY2tlciwgX1BpY2tlcik7XG5cbiAgZnVuY3Rpb24gSWNvblBpY2tlcihzZWxlY3QsIGljb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEljb25QaWNrZXIpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEljb25QaWNrZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJY29uUGlja2VyKSkuY2FsbCh0aGlzLCBzZWxlY3QpKTtcblxuICAgIF90aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdxbC1pY29uLXBpY2tlcicpO1xuICAgIFtdLmZvckVhY2guY2FsbChfdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLnFsLXBpY2tlci1pdGVtJyksIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpdGVtLmlubmVySFRNTCA9IGljb25zW2l0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJykgfHwgJyddO1xuICAgIH0pO1xuICAgIF90aGlzLmRlZmF1bHRJdGVtID0gX3RoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5xbC1zZWxlY3RlZCcpO1xuICAgIF90aGlzLnNlbGVjdEl0ZW0oX3RoaXMuZGVmYXVsdEl0ZW0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJY29uUGlja2VyLCBbe1xuICAgIGtleTogJ3NlbGVjdEl0ZW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RJdGVtKGl0ZW0sIHRyaWdnZXIpIHtcbiAgICAgIF9nZXQoSWNvblBpY2tlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJY29uUGlja2VyLnByb3RvdHlwZSksICdzZWxlY3RJdGVtJywgdGhpcykuY2FsbCh0aGlzLCBpdGVtLCB0cmlnZ2VyKTtcbiAgICAgIGl0ZW0gPSBpdGVtIHx8IHRoaXMuZGVmYXVsdEl0ZW07XG4gICAgICB0aGlzLmxhYmVsLmlubmVySFRNTCA9IGl0ZW0uaW5uZXJIVE1MO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJY29uUGlja2VyO1xufShfcGlja2VyMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSWNvblBpY2tlcjtcblxuLyoqKi8gfSksXG4vKiA2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVG9vbHRpcChxdWlsbCwgYm91bmRzQ29udGFpbmVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sdGlwKTtcblxuICAgIHRoaXMucXVpbGwgPSBxdWlsbDtcbiAgICB0aGlzLmJvdW5kc0NvbnRhaW5lciA9IGJvdW5kc0NvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuICAgIHRoaXMucm9vdCA9IHF1aWxsLmFkZENvbnRhaW5lcigncWwtdG9vbHRpcCcpO1xuICAgIHRoaXMucm9vdC5pbm5lckhUTUwgPSB0aGlzLmNvbnN0cnVjdG9yLlRFTVBMQVRFO1xuICAgIGlmICh0aGlzLnF1aWxsLnJvb3QgPT09IHRoaXMucXVpbGwuc2Nyb2xsaW5nQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLnF1aWxsLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yb290LnN0eWxlLm1hcmdpblRvcCA9IC0xICogX3RoaXMucXVpbGwucm9vdC5zY3JvbGxUb3AgKyAncHgnO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuaGlkZSgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRvb2x0aXAsIFt7XG4gICAga2V5OiAnaGlkZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB0aGlzLnJvb3QuY2xhc3NMaXN0LmFkZCgncWwtaGlkZGVuJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3NpdGlvbihyZWZlcmVuY2UpIHtcbiAgICAgIHZhciBsZWZ0ID0gcmVmZXJlbmNlLmxlZnQgKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gdGhpcy5yb290Lm9mZnNldFdpZHRoIC8gMjtcbiAgICAgIC8vIHJvb3Quc2Nyb2xsVG9wIHNob3VsZCBiZSAwIGlmIHNjcm9sbENvbnRhaW5lciAhPT0gcm9vdFxuICAgICAgdmFyIHRvcCA9IHJlZmVyZW5jZS5ib3R0b20gKyB0aGlzLnF1aWxsLnJvb3Quc2Nyb2xsVG9wO1xuICAgICAgdGhpcy5yb290LnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcbiAgICAgIHRoaXMucm9vdC5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgICAgdGhpcy5yb290LmNsYXNzTGlzdC5yZW1vdmUoJ3FsLWZsaXAnKTtcbiAgICAgIHZhciBjb250YWluZXJCb3VuZHMgPSB0aGlzLmJvdW5kc0NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciByb290Qm91bmRzID0gdGhpcy5yb290LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHNoaWZ0ID0gMDtcbiAgICAgIGlmIChyb290Qm91bmRzLnJpZ2h0ID4gY29udGFpbmVyQm91bmRzLnJpZ2h0KSB7XG4gICAgICAgIHNoaWZ0ID0gY29udGFpbmVyQm91bmRzLnJpZ2h0IC0gcm9vdEJvdW5kcy5yaWdodDtcbiAgICAgICAgdGhpcy5yb290LnN0eWxlLmxlZnQgPSBsZWZ0ICsgc2hpZnQgKyAncHgnO1xuICAgICAgfVxuICAgICAgaWYgKHJvb3RCb3VuZHMubGVmdCA8IGNvbnRhaW5lckJvdW5kcy5sZWZ0KSB7XG4gICAgICAgIHNoaWZ0ID0gY29udGFpbmVyQm91bmRzLmxlZnQgLSByb290Qm91bmRzLmxlZnQ7XG4gICAgICAgIHRoaXMucm9vdC5zdHlsZS5sZWZ0ID0gbGVmdCArIHNoaWZ0ICsgJ3B4JztcbiAgICAgIH1cbiAgICAgIGlmIChyb290Qm91bmRzLmJvdHRvbSA+IGNvbnRhaW5lckJvdW5kcy5ib3R0b20pIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IHJvb3RCb3VuZHMuYm90dG9tIC0gcm9vdEJvdW5kcy50b3A7XG4gICAgICAgIHZhciB2ZXJ0aWNhbFNoaWZ0ID0gcmVmZXJlbmNlLmJvdHRvbSAtIHJlZmVyZW5jZS50b3AgKyBoZWlnaHQ7XG4gICAgICAgIHRoaXMucm9vdC5zdHlsZS50b3AgPSB0b3AgLSB2ZXJ0aWNhbFNoaWZ0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5yb290LmNsYXNzTGlzdC5hZGQoJ3FsLWZsaXAnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaGlmdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzaG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHRoaXMucm9vdC5jbGFzc0xpc3QucmVtb3ZlKCdxbC1lZGl0aW5nJyk7XG4gICAgICB0aGlzLnJvb3QuY2xhc3NMaXN0LnJlbW92ZSgncWwtaGlkZGVuJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRvb2x0aXA7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRvb2x0aXA7XG5cbi8qKiovIH0pLFxuLyogNjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZXh0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9leHRlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXh0ZW5kKTtcblxudmFyIF9lbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIF9lbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VtaXR0ZXIpO1xuXG52YXIgX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcblxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xuXG52YXIgX2xpbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxudmFyIF9saW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpbmspO1xuXG52YXIgX3NlbGVjdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG52YXIgX2ljb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG5cbnZhciBfaWNvbnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaWNvbnMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBUT09MQkFSX0NPTkZJRyA9IFtbeyBoZWFkZXI6IFsnMScsICcyJywgJzMnLCBmYWxzZV0gfV0sIFsnYm9sZCcsICdpdGFsaWMnLCAndW5kZXJsaW5lJywgJ2xpbmsnXSwgW3sgbGlzdDogJ29yZGVyZWQnIH0sIHsgbGlzdDogJ2J1bGxldCcgfV0sIFsnY2xlYW4nXV07XG5cbnZhciBTbm93VGhlbWUgPSBmdW5jdGlvbiAoX0Jhc2VUaGVtZSkge1xuICBfaW5oZXJpdHMoU25vd1RoZW1lLCBfQmFzZVRoZW1lKTtcblxuICBmdW5jdGlvbiBTbm93VGhlbWUocXVpbGwsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU25vd1RoZW1lKTtcblxuICAgIGlmIChvcHRpb25zLm1vZHVsZXMudG9vbGJhciAhPSBudWxsICYmIG9wdGlvbnMubW9kdWxlcy50b29sYmFyLmNvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zLm1vZHVsZXMudG9vbGJhci5jb250YWluZXIgPSBUT09MQkFSX0NPTkZJRztcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU25vd1RoZW1lLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU25vd1RoZW1lKSkuY2FsbCh0aGlzLCBxdWlsbCwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMucXVpbGwuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3FsLXNub3cnKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU25vd1RoZW1lLCBbe1xuICAgIGtleTogJ2V4dGVuZFRvb2xiYXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmRUb29sYmFyKHRvb2xiYXIpIHtcbiAgICAgIHRvb2xiYXIuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3FsLXNub3cnKTtcbiAgICAgIHRoaXMuYnVpbGRCdXR0b25zKFtdLnNsaWNlLmNhbGwodG9vbGJhci5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uJykpLCBfaWNvbnMyLmRlZmF1bHQpO1xuICAgICAgdGhpcy5idWlsZFBpY2tlcnMoW10uc2xpY2UuY2FsbCh0b29sYmFyLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3QnKSksIF9pY29uczIuZGVmYXVsdCk7XG4gICAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU25vd1Rvb2x0aXAodGhpcy5xdWlsbCwgdGhpcy5vcHRpb25zLmJvdW5kcyk7XG4gICAgICBpZiAodG9vbGJhci5jb250YWluZXIucXVlcnlTZWxlY3RvcignLnFsLWxpbmsnKSkge1xuICAgICAgICB0aGlzLnF1aWxsLmtleWJvYXJkLmFkZEJpbmRpbmcoeyBrZXk6ICdLJywgc2hvcnRLZXk6IHRydWUgfSwgZnVuY3Rpb24gKHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICAgICAgdG9vbGJhci5oYW5kbGVyc1snbGluayddLmNhbGwodG9vbGJhciwgIWNvbnRleHQuZm9ybWF0LmxpbmspO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU25vd1RoZW1lO1xufShfYmFzZTIuZGVmYXVsdCk7XG5cblNub3dUaGVtZS5ERUZBVUxUUyA9ICgwLCBfZXh0ZW5kMi5kZWZhdWx0KSh0cnVlLCB7fSwgX2Jhc2UyLmRlZmF1bHQuREVGQVVMVFMsIHtcbiAgbW9kdWxlczoge1xuICAgIHRvb2xiYXI6IHtcbiAgICAgIGhhbmRsZXJzOiB7XG4gICAgICAgIGxpbms6IGZ1bmN0aW9uIGxpbmsodmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAocmFuZ2UgPT0gbnVsbCB8fCByYW5nZS5sZW5ndGggPT0gMCkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHByZXZpZXcgPSB0aGlzLnF1aWxsLmdldFRleHQocmFuZ2UpO1xuICAgICAgICAgICAgaWYgKC9eXFxTK0BcXFMrXFwuXFxTKyQvLnRlc3QocHJldmlldykgJiYgcHJldmlldy5pbmRleE9mKCdtYWlsdG86JykgIT09IDApIHtcbiAgICAgICAgICAgICAgcHJldmlldyA9ICdtYWlsdG86JyArIHByZXZpZXc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG9vbHRpcCA9IHRoaXMucXVpbGwudGhlbWUudG9vbHRpcDtcbiAgICAgICAgICAgIHRvb2x0aXAuZWRpdCgnbGluaycsIHByZXZpZXcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnbGluaycsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgU25vd1Rvb2x0aXAgPSBmdW5jdGlvbiAoX0Jhc2VUb29sdGlwKSB7XG4gIF9pbmhlcml0cyhTbm93VG9vbHRpcCwgX0Jhc2VUb29sdGlwKTtcblxuICBmdW5jdGlvbiBTbm93VG9vbHRpcChxdWlsbCwgYm91bmRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNub3dUb29sdGlwKTtcblxuICAgIHZhciBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU25vd1Rvb2x0aXAuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTbm93VG9vbHRpcCkpLmNhbGwodGhpcywgcXVpbGwsIGJvdW5kcykpO1xuXG4gICAgX3RoaXMyLnByZXZpZXcgPSBfdGhpczIucm9vdC5xdWVyeVNlbGVjdG9yKCdhLnFsLXByZXZpZXcnKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNub3dUb29sdGlwLCBbe1xuICAgIGtleTogJ2xpc3RlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RlbigpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBfZ2V0KFNub3dUb29sdGlwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNub3dUb29sdGlwLnByb3RvdHlwZSksICdsaXN0ZW4nLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3IoJ2EucWwtYWN0aW9uJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKF90aGlzMy5yb290LmNsYXNzTGlzdC5jb250YWlucygncWwtZWRpdGluZycpKSB7XG4gICAgICAgICAgX3RoaXMzLnNhdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczMuZWRpdCgnbGluaycsIF90aGlzMy5wcmV2aWV3LnRleHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcignYS5xbC1yZW1vdmUnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoX3RoaXMzLmxpbmtSYW5nZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gX3RoaXMzLmxpbmtSYW5nZTtcbiAgICAgICAgICBfdGhpczMucmVzdG9yZUZvY3VzKCk7XG4gICAgICAgICAgX3RoaXMzLnF1aWxsLmZvcm1hdFRleHQocmFuZ2UsICdsaW5rJywgZmFsc2UsIF9lbWl0dGVyMi5kZWZhdWx0LnNvdXJjZXMuVVNFUik7XG4gICAgICAgICAgZGVsZXRlIF90aGlzMy5saW5rUmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMzLmhpZGUoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5xdWlsbC5vbihfZW1pdHRlcjIuZGVmYXVsdC5ldmVudHMuU0VMRUNUSU9OX0NIQU5HRSwgZnVuY3Rpb24gKHJhbmdlLCBvbGRSYW5nZSwgc291cmNlKSB7XG4gICAgICAgIGlmIChyYW5nZSA9PSBudWxsKSByZXR1cm47XG4gICAgICAgIGlmIChyYW5nZS5sZW5ndGggPT09IDAgJiYgc291cmNlID09PSBfZW1pdHRlcjIuZGVmYXVsdC5zb3VyY2VzLlVTRVIpIHtcbiAgICAgICAgICB2YXIgX3F1aWxsJHNjcm9sbCRkZXNjZW5kID0gX3RoaXMzLnF1aWxsLnNjcm9sbC5kZXNjZW5kYW50KF9saW5rMi5kZWZhdWx0LCByYW5nZS5pbmRleCksXG4gICAgICAgICAgICAgIF9xdWlsbCRzY3JvbGwkZGVzY2VuZDIgPSBfc2xpY2VkVG9BcnJheShfcXVpbGwkc2Nyb2xsJGRlc2NlbmQsIDIpLFxuICAgICAgICAgICAgICBsaW5rID0gX3F1aWxsJHNjcm9sbCRkZXNjZW5kMlswXSxcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gX3F1aWxsJHNjcm9sbCRkZXNjZW5kMlsxXTtcblxuICAgICAgICAgIGlmIChsaW5rICE9IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzMy5saW5rUmFuZ2UgPSBuZXcgX3NlbGVjdGlvbi5SYW5nZShyYW5nZS5pbmRleCAtIG9mZnNldCwgbGluay5sZW5ndGgoKSk7XG4gICAgICAgICAgICB2YXIgcHJldmlldyA9IF9saW5rMi5kZWZhdWx0LmZvcm1hdHMobGluay5kb21Ob2RlKTtcbiAgICAgICAgICAgIF90aGlzMy5wcmV2aWV3LnRleHRDb250ZW50ID0gcHJldmlldztcbiAgICAgICAgICAgIF90aGlzMy5wcmV2aWV3LnNldEF0dHJpYnV0ZSgnaHJlZicsIHByZXZpZXcpO1xuICAgICAgICAgICAgX3RoaXMzLnNob3coKTtcbiAgICAgICAgICAgIF90aGlzMy5wb3NpdGlvbihfdGhpczMucXVpbGwuZ2V0Qm91bmRzKF90aGlzMy5saW5rUmFuZ2UpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIF90aGlzMy5saW5rUmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMzLmhpZGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Nob3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgX2dldChTbm93VG9vbHRpcC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTbm93VG9vbHRpcC5wcm90b3R5cGUpLCAnc2hvdycsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnJvb3QucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW1vZGUnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU25vd1Rvb2x0aXA7XG59KF9iYXNlLkJhc2VUb29sdGlwKTtcblxuU25vd1Rvb2x0aXAuVEVNUExBVEUgPSBbJzxhIGNsYXNzPVwicWwtcHJldmlld1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIiB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVwiYWJvdXQ6YmxhbmtcIj48L2E+JywgJzxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtZm9ybXVsYT1cImU9bWNeMlwiIGRhdGEtbGluaz1cImh0dHBzOi8vcXVpbGxqcy5jb21cIiBkYXRhLXZpZGVvPVwiRW1iZWQgVVJMXCI+JywgJzxhIGNsYXNzPVwicWwtYWN0aW9uXCI+PC9hPicsICc8YSBjbGFzcz1cInFsLXJlbW92ZVwiPjwvYT4nXS5qb2luKCcnKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU25vd1RoZW1lO1xuXG4vKioqLyB9KSxcbi8qIDYzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG52YXIgX2NvcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29yZSk7XG5cbnZhciBfYWxpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblxudmFyIF9kaXJlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblxudmFyIF9pbmRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KTtcblxudmFyIF9ibG9ja3F1b3RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XG5cbnZhciBfYmxvY2txdW90ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ibG9ja3F1b3RlKTtcblxudmFyIF9oZWFkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KTtcblxudmFyIF9oZWFkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGVhZGVyKTtcblxudmFyIF9saXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XG5cbnZhciBfbGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saXN0KTtcblxudmFyIF9iYWNrZ3JvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cbnZhciBfY29sb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxudmFyIF9mb250ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cbnZhciBfc2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xuXG52YXIgX2JvbGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblxudmFyIF9ib2xkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JvbGQpO1xuXG52YXIgX2l0YWxpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNjgpO1xuXG52YXIgX2l0YWxpYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGFsaWMpO1xuXG52YXIgX2xpbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxudmFyIF9saW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpbmspO1xuXG52YXIgX3NjcmlwdCA9IF9fd2VicGFja19yZXF1aXJlX18oNjkpO1xuXG52YXIgX3NjcmlwdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zY3JpcHQpO1xuXG52YXIgX3N0cmlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xuXG52YXIgX3N0cmlrZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHJpa2UpO1xuXG52YXIgX3VuZGVybGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG52YXIgX3VuZGVybGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91bmRlcmxpbmUpO1xuXG52YXIgX2ltYWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mik7XG5cbnZhciBfaW1hZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW1hZ2UpO1xuXG52YXIgX3ZpZGVvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG5cbnZhciBfdmlkZW8yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlkZW8pO1xuXG52YXIgX2NvZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIF9jb2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvZGUpO1xuXG52YXIgX2Zvcm11bGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxudmFyIF9mb3JtdWxhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Zvcm11bGEpO1xuXG52YXIgX3N5bnRheCA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG52YXIgX3N5bnRheDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW50YXgpO1xuXG52YXIgX3Rvb2xiYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcblxudmFyIF90b29sYmFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Rvb2xiYXIpO1xuXG52YXIgX2ljb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG5cbnZhciBfaWNvbnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaWNvbnMpO1xuXG52YXIgX3BpY2tlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG52YXIgX3BpY2tlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9waWNrZXIpO1xuXG52YXIgX2NvbG9yUGlja2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XG5cbnZhciBfY29sb3JQaWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29sb3JQaWNrZXIpO1xuXG52YXIgX2ljb25QaWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcblxudmFyIF9pY29uUGlja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ljb25QaWNrZXIpO1xuXG52YXIgX3Rvb2x0aXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcblxudmFyIF90b29sdGlwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Rvb2x0aXApO1xuXG52YXIgX2J1YmJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTA4KTtcblxudmFyIF9idWJibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnViYmxlKTtcblxudmFyIF9zbm93ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XG5cbnZhciBfc25vdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zbm93KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuX2NvcmUyLmRlZmF1bHQucmVnaXN0ZXIoe1xuICAnYXR0cmlidXRvcnMvYXR0cmlidXRlL2RpcmVjdGlvbic6IF9kaXJlY3Rpb24uRGlyZWN0aW9uQXR0cmlidXRlLFxuXG4gICdhdHRyaWJ1dG9ycy9jbGFzcy9hbGlnbic6IF9hbGlnbi5BbGlnbkNsYXNzLFxuICAnYXR0cmlidXRvcnMvY2xhc3MvYmFja2dyb3VuZCc6IF9iYWNrZ3JvdW5kLkJhY2tncm91bmRDbGFzcyxcbiAgJ2F0dHJpYnV0b3JzL2NsYXNzL2NvbG9yJzogX2NvbG9yLkNvbG9yQ2xhc3MsXG4gICdhdHRyaWJ1dG9ycy9jbGFzcy9kaXJlY3Rpb24nOiBfZGlyZWN0aW9uLkRpcmVjdGlvbkNsYXNzLFxuICAnYXR0cmlidXRvcnMvY2xhc3MvZm9udCc6IF9mb250LkZvbnRDbGFzcyxcbiAgJ2F0dHJpYnV0b3JzL2NsYXNzL3NpemUnOiBfc2l6ZS5TaXplQ2xhc3MsXG5cbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2FsaWduJzogX2FsaWduLkFsaWduU3R5bGUsXG4gICdhdHRyaWJ1dG9ycy9zdHlsZS9iYWNrZ3JvdW5kJzogX2JhY2tncm91bmQuQmFja2dyb3VuZFN0eWxlLFxuICAnYXR0cmlidXRvcnMvc3R5bGUvY29sb3InOiBfY29sb3IuQ29sb3JTdHlsZSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2RpcmVjdGlvbic6IF9kaXJlY3Rpb24uRGlyZWN0aW9uU3R5bGUsXG4gICdhdHRyaWJ1dG9ycy9zdHlsZS9mb250JzogX2ZvbnQuRm9udFN0eWxlLFxuICAnYXR0cmlidXRvcnMvc3R5bGUvc2l6ZSc6IF9zaXplLlNpemVTdHlsZVxufSwgdHJ1ZSk7XG5cbl9jb3JlMi5kZWZhdWx0LnJlZ2lzdGVyKHtcbiAgJ2Zvcm1hdHMvYWxpZ24nOiBfYWxpZ24uQWxpZ25DbGFzcyxcbiAgJ2Zvcm1hdHMvZGlyZWN0aW9uJzogX2RpcmVjdGlvbi5EaXJlY3Rpb25DbGFzcyxcbiAgJ2Zvcm1hdHMvaW5kZW50JzogX2luZGVudC5JbmRlbnRDbGFzcyxcblxuICAnZm9ybWF0cy9iYWNrZ3JvdW5kJzogX2JhY2tncm91bmQuQmFja2dyb3VuZFN0eWxlLFxuICAnZm9ybWF0cy9jb2xvcic6IF9jb2xvci5Db2xvclN0eWxlLFxuICAnZm9ybWF0cy9mb250JzogX2ZvbnQuRm9udENsYXNzLFxuICAnZm9ybWF0cy9zaXplJzogX3NpemUuU2l6ZUNsYXNzLFxuXG4gICdmb3JtYXRzL2Jsb2NrcXVvdGUnOiBfYmxvY2txdW90ZTIuZGVmYXVsdCxcbiAgJ2Zvcm1hdHMvY29kZS1ibG9jayc6IF9jb2RlMi5kZWZhdWx0LFxuICAnZm9ybWF0cy9oZWFkZXInOiBfaGVhZGVyMi5kZWZhdWx0LFxuICAnZm9ybWF0cy9saXN0JzogX2xpc3QyLmRlZmF1bHQsXG5cbiAgJ2Zvcm1hdHMvYm9sZCc6IF9ib2xkMi5kZWZhdWx0LFxuICAnZm9ybWF0cy9jb2RlJzogX2NvZGUuQ29kZSxcbiAgJ2Zvcm1hdHMvaXRhbGljJzogX2l0YWxpYzIuZGVmYXVsdCxcbiAgJ2Zvcm1hdHMvbGluayc6IF9saW5rMi5kZWZhdWx0LFxuICAnZm9ybWF0cy9zY3JpcHQnOiBfc2NyaXB0Mi5kZWZhdWx0LFxuICAnZm9ybWF0cy9zdHJpa2UnOiBfc3RyaWtlMi5kZWZhdWx0LFxuICAnZm9ybWF0cy91bmRlcmxpbmUnOiBfdW5kZXJsaW5lMi5kZWZhdWx0LFxuXG4gICdmb3JtYXRzL2ltYWdlJzogX2ltYWdlMi5kZWZhdWx0LFxuICAnZm9ybWF0cy92aWRlbyc6IF92aWRlbzIuZGVmYXVsdCxcblxuICAnZm9ybWF0cy9saXN0L2l0ZW0nOiBfbGlzdC5MaXN0SXRlbSxcblxuICAnbW9kdWxlcy9mb3JtdWxhJzogX2Zvcm11bGEyLmRlZmF1bHQsXG4gICdtb2R1bGVzL3N5bnRheCc6IF9zeW50YXgyLmRlZmF1bHQsXG4gICdtb2R1bGVzL3Rvb2xiYXInOiBfdG9vbGJhcjIuZGVmYXVsdCxcblxuICAndGhlbWVzL2J1YmJsZSc6IF9idWJibGUyLmRlZmF1bHQsXG4gICd0aGVtZXMvc25vdyc6IF9zbm93Mi5kZWZhdWx0LFxuXG4gICd1aS9pY29ucyc6IF9pY29uczIuZGVmYXVsdCxcbiAgJ3VpL3BpY2tlcic6IF9waWNrZXIyLmRlZmF1bHQsXG4gICd1aS9pY29uLXBpY2tlcic6IF9pY29uUGlja2VyMi5kZWZhdWx0LFxuICAndWkvY29sb3ItcGlja2VyJzogX2NvbG9yUGlja2VyMi5kZWZhdWx0LFxuICAndWkvdG9vbHRpcCc6IF90b29sdGlwMi5kZWZhdWx0XG59LCB0cnVlKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2NvcmUyLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuLyogNjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuSW5kZW50Q2xhc3MgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9wYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3BhcmNobWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJjaG1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBJZGVudEF0dHJpYnV0b3IgPSBmdW5jdGlvbiAoX1BhcmNobWVudCRBdHRyaWJ1dG9yKSB7XG4gIF9pbmhlcml0cyhJZGVudEF0dHJpYnV0b3IsIF9QYXJjaG1lbnQkQXR0cmlidXRvcik7XG5cbiAgZnVuY3Rpb24gSWRlbnRBdHRyaWJ1dG9yKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJZGVudEF0dHJpYnV0b3IpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChJZGVudEF0dHJpYnV0b3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJZGVudEF0dHJpYnV0b3IpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJZGVudEF0dHJpYnV0b3IsIFt7XG4gICAga2V5OiAnYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKG5vZGUsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICcrMScgfHwgdmFsdWUgPT09ICctMScpIHtcbiAgICAgICAgdmFyIGluZGVudCA9IHRoaXMudmFsdWUobm9kZSkgfHwgMDtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gJysxJyA/IGluZGVudCArIDEgOiBpbmRlbnQgLSAxO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKG5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfZ2V0KElkZW50QXR0cmlidXRvci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJZGVudEF0dHJpYnV0b3IucHJvdG90eXBlKSwgJ2FkZCcsIHRoaXMpLmNhbGwodGhpcywgbm9kZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbkFkZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkFkZChub2RlLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIF9nZXQoSWRlbnRBdHRyaWJ1dG9yLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKElkZW50QXR0cmlidXRvci5wcm90b3R5cGUpLCAnY2FuQWRkJywgdGhpcykuY2FsbCh0aGlzLCBub2RlLCB2YWx1ZSkgfHwgX2dldChJZGVudEF0dHJpYnV0b3IucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSWRlbnRBdHRyaWJ1dG9yLnByb3RvdHlwZSksICdjYW5BZGQnLCB0aGlzKS5jYWxsKHRoaXMsIG5vZGUsIHBhcnNlSW50KHZhbHVlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShub2RlKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoX2dldChJZGVudEF0dHJpYnV0b3IucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSWRlbnRBdHRyaWJ1dG9yLnByb3RvdHlwZSksICd2YWx1ZScsIHRoaXMpLmNhbGwodGhpcywgbm9kZSkpIHx8IHVuZGVmaW5lZDsgLy8gRG9uJ3QgcmV0dXJuIE5hTlxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJZGVudEF0dHJpYnV0b3I7XG59KF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5DbGFzcyk7XG5cbnZhciBJbmRlbnRDbGFzcyA9IG5ldyBJZGVudEF0dHJpYnV0b3IoJ2luZGVudCcsICdxbC1pbmRlbnQnLCB7XG4gIHNjb3BlOiBfcGFyY2htZW50Mi5kZWZhdWx0LlNjb3BlLkJMT0NLLFxuICB3aGl0ZWxpc3Q6IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4XVxufSk7XG5cbmV4cG9ydHMuSW5kZW50Q2xhc3MgPSBJbmRlbnRDbGFzcztcblxuLyoqKi8gfSksXG4vKiA2NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2Jsb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9ibG9jazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ibG9jayk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEJsb2NrcXVvdGUgPSBmdW5jdGlvbiAoX0Jsb2NrKSB7XG4gIF9pbmhlcml0cyhCbG9ja3F1b3RlLCBfQmxvY2spO1xuXG4gIGZ1bmN0aW9uIEJsb2NrcXVvdGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJsb2NrcXVvdGUpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChCbG9ja3F1b3RlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQmxvY2txdW90ZSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIEJsb2NrcXVvdGU7XG59KF9ibG9jazIuZGVmYXVsdCk7XG5cbkJsb2NrcXVvdGUuYmxvdE5hbWUgPSAnYmxvY2txdW90ZSc7XG5CbG9ja3F1b3RlLnRhZ05hbWUgPSAnYmxvY2txdW90ZSc7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEJsb2NrcXVvdGU7XG5cbi8qKiovIH0pLFxuLyogNjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9ibG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfYmxvY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmxvY2spO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBIZWFkZXIgPSBmdW5jdGlvbiAoX0Jsb2NrKSB7XG4gIF9pbmhlcml0cyhIZWFkZXIsIF9CbG9jayk7XG5cbiAgZnVuY3Rpb24gSGVhZGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIZWFkZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChIZWFkZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihIZWFkZXIpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhIZWFkZXIsIG51bGwsIFt7XG4gICAga2V5OiAnZm9ybWF0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGFnTmFtZS5pbmRleE9mKGRvbU5vZGUudGFnTmFtZSkgKyAxO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIZWFkZXI7XG59KF9ibG9jazIuZGVmYXVsdCk7XG5cbkhlYWRlci5ibG90TmFtZSA9ICdoZWFkZXInO1xuSGVhZGVyLnRhZ05hbWUgPSBbJ0gxJywgJ0gyJywgJ0gzJywgJ0g0JywgJ0g1JywgJ0g2J107XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEhlYWRlcjtcblxuLyoqKi8gfSksXG4vKiA2NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5MaXN0SXRlbSA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfYmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Jsb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jsb2NrKTtcblxudmFyIF9jb250YWluZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxudmFyIF9jb250YWluZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGFpbmVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgTGlzdEl0ZW0gPSBmdW5jdGlvbiAoX0Jsb2NrKSB7XG4gIF9pbmhlcml0cyhMaXN0SXRlbSwgX0Jsb2NrKTtcblxuICBmdW5jdGlvbiBMaXN0SXRlbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGlzdEl0ZW0pO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChMaXN0SXRlbS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpc3RJdGVtKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGlzdEl0ZW0sIFt7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAobmFtZSA9PT0gTGlzdC5ibG90TmFtZSAmJiAhdmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlV2l0aChfcGFyY2htZW50Mi5kZWZhdWx0LmNyZWF0ZSh0aGlzLnN0YXRpY3Muc2NvcGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQoTGlzdEl0ZW0ucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdEl0ZW0ucHJvdG90eXBlKSwgJ2Zvcm1hdCcsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIGlmICh0aGlzLnByZXYgPT0gbnVsbCAmJiB0aGlzLm5leHQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQoTGlzdEl0ZW0ucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdEl0ZW0ucHJvdG90eXBlKSwgJ3JlbW92ZScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVwbGFjZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlV2l0aChuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5wYXJlbnQuaXNvbGF0ZSh0aGlzLm9mZnNldCh0aGlzLnBhcmVudCksIHRoaXMubGVuZ3RoKCkpO1xuICAgICAgaWYgKG5hbWUgPT09IHRoaXMucGFyZW50LnN0YXRpY3MuYmxvdE5hbWUpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQucmVwbGFjZVdpdGgobmFtZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyZW50LnVud3JhcCgpO1xuICAgICAgICByZXR1cm4gX2dldChMaXN0SXRlbS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaXN0SXRlbS5wcm90b3R5cGUpLCAncmVwbGFjZVdpdGgnLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2Zvcm1hdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKGRvbU5vZGUpIHtcbiAgICAgIHJldHVybiBkb21Ob2RlLnRhZ05hbWUgPT09IHRoaXMudGFnTmFtZSA/IHVuZGVmaW5lZCA6IF9nZXQoTGlzdEl0ZW0uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaXN0SXRlbSksICdmb3JtYXRzJywgdGhpcykuY2FsbCh0aGlzLCBkb21Ob2RlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGlzdEl0ZW07XG59KF9ibG9jazIuZGVmYXVsdCk7XG5cbkxpc3RJdGVtLmJsb3ROYW1lID0gJ2xpc3QtaXRlbSc7XG5MaXN0SXRlbS50YWdOYW1lID0gJ0xJJztcblxudmFyIExpc3QgPSBmdW5jdGlvbiAoX0NvbnRhaW5lcikge1xuICBfaW5oZXJpdHMoTGlzdCwgX0NvbnRhaW5lcik7XG5cbiAgX2NyZWF0ZUNsYXNzKExpc3QsIG51bGwsIFt7XG4gICAga2V5OiAnY3JlYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICB2YXIgdGFnTmFtZSA9IHZhbHVlID09PSAnb3JkZXJlZCcgPyAnT0wnIDogJ1VMJztcbiAgICAgIHZhciBub2RlID0gX2dldChMaXN0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdCksICdjcmVhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIHRhZ05hbWUpO1xuICAgICAgaWYgKHZhbHVlID09PSAnY2hlY2tlZCcgfHwgdmFsdWUgPT09ICd1bmNoZWNrZWQnKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLWNoZWNrZWQnLCB2YWx1ZSA9PT0gJ2NoZWNrZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKGRvbU5vZGUpIHtcbiAgICAgIGlmIChkb21Ob2RlLnRhZ05hbWUgPT09ICdPTCcpIHJldHVybiAnb3JkZXJlZCc7XG4gICAgICBpZiAoZG9tTm9kZS50YWdOYW1lID09PSAnVUwnKSB7XG4gICAgICAgIGlmIChkb21Ob2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1jaGVja2VkJykpIHtcbiAgICAgICAgICByZXR1cm4gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2hlY2tlZCcpID09PSAndHJ1ZScgPyAnY2hlY2tlZCcgOiAndW5jaGVja2VkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJ2J1bGxldCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gTGlzdChkb21Ob2RlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpc3QpO1xuXG4gICAgdmFyIF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChMaXN0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdCkpLmNhbGwodGhpcywgZG9tTm9kZSkpO1xuXG4gICAgdmFyIGxpc3RFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiBsaXN0RXZlbnRIYW5kbGVyKGUpIHtcbiAgICAgIGlmIChlLnRhcmdldC5wYXJlbnROb2RlICE9PSBkb21Ob2RlKSByZXR1cm47XG4gICAgICB2YXIgZm9ybWF0ID0gX3RoaXMyLnN0YXRpY3MuZm9ybWF0cyhkb21Ob2RlKTtcbiAgICAgIHZhciBibG90ID0gX3BhcmNobWVudDIuZGVmYXVsdC5maW5kKGUudGFyZ2V0KTtcbiAgICAgIGlmIChmb3JtYXQgPT09ICdjaGVja2VkJykge1xuICAgICAgICBibG90LmZvcm1hdCgnbGlzdCcsICd1bmNoZWNrZWQnKTtcbiAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAndW5jaGVja2VkJykge1xuICAgICAgICBibG90LmZvcm1hdCgnbGlzdCcsICdjaGVja2VkJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvbU5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGxpc3RFdmVudEhhbmRsZXIpO1xuICAgIGRvbU5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbGlzdEV2ZW50SGFuZGxlcik7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaXN0LCBbe1xuICAgIGtleTogJ2Zvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnRhaWwuZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cygpIHtcbiAgICAgIC8vIFdlIGRvbid0IGluaGVyaXQgZnJvbSBGb3JtYXRCbG90XG4gICAgICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCB0aGlzLnN0YXRpY3MuYmxvdE5hbWUsIHRoaXMuc3RhdGljcy5mb3JtYXRzKHRoaXMuZG9tTm9kZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luc2VydEJlZm9yZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZShibG90LCByZWYpIHtcbiAgICAgIGlmIChibG90IGluc3RhbmNlb2YgTGlzdEl0ZW0pIHtcbiAgICAgICAgX2dldChMaXN0LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpc3QucHJvdG90eXBlKSwgJ2luc2VydEJlZm9yZScsIHRoaXMpLmNhbGwodGhpcywgYmxvdCwgcmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJlZiA9PSBudWxsID8gdGhpcy5sZW5ndGgoKSA6IHJlZi5vZmZzZXQodGhpcyk7XG4gICAgICAgIHZhciBhZnRlciA9IHRoaXMuc3BsaXQoaW5kZXgpO1xuICAgICAgICBhZnRlci5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJsb3QsIGFmdGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvcHRpbWl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKGNvbnRleHQpIHtcbiAgICAgIF9nZXQoTGlzdC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMaXN0LnByb3RvdHlwZSksICdvcHRpbWl6ZScsIHRoaXMpLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMubmV4dDtcbiAgICAgIGlmIChuZXh0ICE9IG51bGwgJiYgbmV4dC5wcmV2ID09PSB0aGlzICYmIG5leHQuc3RhdGljcy5ibG90TmFtZSA9PT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lICYmIG5leHQuZG9tTm9kZS50YWdOYW1lID09PSB0aGlzLmRvbU5vZGUudGFnTmFtZSAmJiBuZXh0LmRvbU5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWNoZWNrZWQnKSA9PT0gdGhpcy5kb21Ob2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1jaGVja2VkJykpIHtcbiAgICAgICAgbmV4dC5tb3ZlQ2hpbGRyZW4odGhpcyk7XG4gICAgICAgIG5leHQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVwbGFjZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2UodGFyZ2V0KSB7XG4gICAgICBpZiAodGFyZ2V0LnN0YXRpY3MuYmxvdE5hbWUgIT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSkge1xuICAgICAgICB2YXIgaXRlbSA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuY3JlYXRlKHRoaXMuc3RhdGljcy5kZWZhdWx0Q2hpbGQpO1xuICAgICAgICB0YXJnZXQubW92ZUNoaWxkcmVuKGl0ZW0pO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGl0ZW0pO1xuICAgICAgfVxuICAgICAgX2dldChMaXN0LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpc3QucHJvdG90eXBlKSwgJ3JlcGxhY2UnLCB0aGlzKS5jYWxsKHRoaXMsIHRhcmdldCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpc3Q7XG59KF9jb250YWluZXIyLmRlZmF1bHQpO1xuXG5MaXN0LmJsb3ROYW1lID0gJ2xpc3QnO1xuTGlzdC5zY29wZSA9IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuQkxPQ0tfQkxPVDtcbkxpc3QudGFnTmFtZSA9IFsnT0wnLCAnVUwnXTtcbkxpc3QuZGVmYXVsdENoaWxkID0gJ2xpc3QtaXRlbSc7XG5MaXN0LmFsbG93ZWRDaGlsZHJlbiA9IFtMaXN0SXRlbV07XG5cbmV4cG9ydHMuTGlzdEl0ZW0gPSBMaXN0SXRlbTtcbmV4cG9ydHMuZGVmYXVsdCA9IExpc3Q7XG5cbi8qKiovIH0pLFxuLyogNjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9ib2xkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XG5cbnZhciBfYm9sZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ib2xkKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSXRhbGljID0gZnVuY3Rpb24gKF9Cb2xkKSB7XG4gIF9pbmhlcml0cyhJdGFsaWMsIF9Cb2xkKTtcblxuICBmdW5jdGlvbiBJdGFsaWMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEl0YWxpYyk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEl0YWxpYy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEl0YWxpYykpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIEl0YWxpYztcbn0oX2JvbGQyLmRlZmF1bHQpO1xuXG5JdGFsaWMuYmxvdE5hbWUgPSAnaXRhbGljJztcbkl0YWxpYy50YWdOYW1lID0gWydFTScsICdJJ107XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEl0YWxpYztcblxuLyoqKi8gfSksXG4vKiA2OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfaW5saW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9pbmxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5saW5lKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU2NyaXB0ID0gZnVuY3Rpb24gKF9JbmxpbmUpIHtcbiAgX2luaGVyaXRzKFNjcmlwdCwgX0lubGluZSk7XG5cbiAgZnVuY3Rpb24gU2NyaXB0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY3JpcHQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTY3JpcHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTY3JpcHQpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTY3JpcHQsIG51bGwsIFt7XG4gICAga2V5OiAnY3JlYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICdzdXBlcicpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N1cCcpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ3N1YicpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N1YicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoU2NyaXB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2NyaXB0KSwgJ2NyZWF0ZScsIHRoaXMpLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKGRvbU5vZGUpIHtcbiAgICAgIGlmIChkb21Ob2RlLnRhZ05hbWUgPT09ICdTVUInKSByZXR1cm4gJ3N1Yic7XG4gICAgICBpZiAoZG9tTm9kZS50YWdOYW1lID09PSAnU1VQJykgcmV0dXJuICdzdXBlcic7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTY3JpcHQ7XG59KF9pbmxpbmUyLmRlZmF1bHQpO1xuXG5TY3JpcHQuYmxvdE5hbWUgPSAnc2NyaXB0JztcblNjcmlwdC50YWdOYW1lID0gWydTVUInLCAnU1VQJ107XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNjcmlwdDtcblxuLyoqKi8gfSksXG4vKiA3MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2lubGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfaW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lubGluZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFN0cmlrZSA9IGZ1bmN0aW9uIChfSW5saW5lKSB7XG4gIF9pbmhlcml0cyhTdHJpa2UsIF9JbmxpbmUpO1xuXG4gIGZ1bmN0aW9uIFN0cmlrZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyaWtlKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3RyaWtlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3RyaWtlKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICByZXR1cm4gU3RyaWtlO1xufShfaW5saW5lMi5kZWZhdWx0KTtcblxuU3RyaWtlLmJsb3ROYW1lID0gJ3N0cmlrZSc7XG5TdHJpa2UudGFnTmFtZSA9ICdTJztcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3RyaWtlO1xuXG4vKioqLyB9KSxcbi8qIDcxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfaW5saW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9pbmxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5saW5lKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVW5kZXJsaW5lID0gZnVuY3Rpb24gKF9JbmxpbmUpIHtcbiAgX2luaGVyaXRzKFVuZGVybGluZSwgX0lubGluZSk7XG5cbiAgZnVuY3Rpb24gVW5kZXJsaW5lKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVbmRlcmxpbmUpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChVbmRlcmxpbmUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihVbmRlcmxpbmUpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBVbmRlcmxpbmU7XG59KF9pbmxpbmUyLmRlZmF1bHQpO1xuXG5VbmRlcmxpbmUuYmxvdE5hbWUgPSAndW5kZXJsaW5lJztcblVuZGVybGluZS50YWdOYW1lID0gJ1UnO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBVbmRlcmxpbmU7XG5cbi8qKiovIH0pLFxuLyogNzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfbGluayA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBBVFRSSUJVVEVTID0gWydhbHQnLCAnaGVpZ2h0JywgJ3dpZHRoJ107XG5cbnZhciBJbWFnZSA9IGZ1bmN0aW9uIChfUGFyY2htZW50JEVtYmVkKSB7XG4gIF9pbmhlcml0cyhJbWFnZSwgX1BhcmNobWVudCRFbWJlZCk7XG5cbiAgZnVuY3Rpb24gSW1hZ2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoSW1hZ2UuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbWFnZSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEltYWdlLCBbe1xuICAgIGtleTogJ2Zvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKEFUVFJJQlVURVMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuZG9tTm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZG9tTm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQoSW1hZ2UucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSW1hZ2UucHJvdG90eXBlKSwgJ2Zvcm1hdCcsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnY3JlYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZSA9IF9nZXQoSW1hZ2UuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbWFnZSksICdjcmVhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdzcmMnLCB0aGlzLnNhbml0aXplKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cyhkb21Ob2RlKSB7XG4gICAgICByZXR1cm4gQVRUUklCVVRFUy5yZWR1Y2UoZnVuY3Rpb24gKGZvcm1hdHMsIGF0dHJpYnV0ZSkge1xuICAgICAgICBpZiAoZG9tTm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlKSkge1xuICAgICAgICAgIGZvcm1hdHNbYXR0cmlidXRlXSA9IGRvbU5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgICB9LCB7fSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWF0Y2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaCh1cmwpIHtcbiAgICAgIHJldHVybiAoL1xcLihqcGU/Z3xnaWZ8cG5nKSQvLnRlc3QodXJsKSB8fCAvXmRhdGE6aW1hZ2VcXC8uKztiYXNlNjQvLnRlc3QodXJsKVxuICAgICAgKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzYW5pdGl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhbml0aXplKHVybCkge1xuICAgICAgcmV0dXJuICgwLCBfbGluay5zYW5pdGl6ZSkodXJsLCBbJ2h0dHAnLCAnaHR0cHMnLCAnZGF0YSddKSA/IHVybCA6ICcvLzowJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd2YWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGRvbU5vZGUpIHtcbiAgICAgIHJldHVybiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEltYWdlO1xufShfcGFyY2htZW50Mi5kZWZhdWx0LkVtYmVkKTtcblxuSW1hZ2UuYmxvdE5hbWUgPSAnaW1hZ2UnO1xuSW1hZ2UudGFnTmFtZSA9ICdJTUcnO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbWFnZTtcblxuLyoqKi8gfSksXG4vKiA3MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfYmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2xpbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxudmFyIF9saW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpbmspO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBBVFRSSUJVVEVTID0gWydoZWlnaHQnLCAnd2lkdGgnXTtcblxudmFyIFZpZGVvID0gZnVuY3Rpb24gKF9CbG9ja0VtYmVkKSB7XG4gIF9pbmhlcml0cyhWaWRlbywgX0Jsb2NrRW1iZWQpO1xuXG4gIGZ1bmN0aW9uIFZpZGVvKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWRlbyk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFZpZGVvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVmlkZW8pKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhWaWRlbywgW3tcbiAgICBrZXk6ICdmb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChBVFRSSUJVVEVTLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmRvbU5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRvbU5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0KFZpZGVvLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFZpZGVvLnByb3RvdHlwZSksICdmb3JtYXQnLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2NyZWF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgdmFyIG5vZGUgPSBfZ2V0KFZpZGVvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVmlkZW8pLCAnY3JlYXRlJywgdGhpcykuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZnJhbWVib3JkZXInLCAnMCcpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2FsbG93ZnVsbHNjcmVlbicsIHRydWUpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHRoaXMuc2FuaXRpemUodmFsdWUpKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKGRvbU5vZGUpIHtcbiAgICAgIHJldHVybiBBVFRSSUJVVEVTLnJlZHVjZShmdW5jdGlvbiAoZm9ybWF0cywgYXR0cmlidXRlKSB7XG4gICAgICAgIGlmIChkb21Ob2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgZm9ybWF0c1thdHRyaWJ1dGVdID0gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0cztcbiAgICAgIH0sIHt9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzYW5pdGl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhbml0aXplKHVybCkge1xuICAgICAgcmV0dXJuIF9saW5rMi5kZWZhdWx0LnNhbml0aXplKHVybCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShkb21Ob2RlKSB7XG4gICAgICByZXR1cm4gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWaWRlbztcbn0oX2Jsb2NrLkJsb2NrRW1iZWQpO1xuXG5WaWRlby5ibG90TmFtZSA9ICd2aWRlbyc7XG5WaWRlby5jbGFzc05hbWUgPSAncWwtdmlkZW8nO1xuVmlkZW8udGFnTmFtZSA9ICdJRlJBTUUnO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBWaWRlbztcblxuLyoqKi8gfSksXG4vKiA3NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5Gb3JtdWxhQmxvdCA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2VtYmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cbnZhciBfZW1iZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZW1iZWQpO1xuXG52YXIgX3F1aWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9xdWlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWlsbCk7XG5cbnZhciBfbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9tb2R1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9kdWxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRm9ybXVsYUJsb3QgPSBmdW5jdGlvbiAoX0VtYmVkKSB7XG4gIF9pbmhlcml0cyhGb3JtdWxhQmxvdCwgX0VtYmVkKTtcblxuICBmdW5jdGlvbiBGb3JtdWxhQmxvdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9ybXVsYUJsb3QpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChGb3JtdWxhQmxvdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZvcm11bGFCbG90KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRm9ybXVsYUJsb3QsIG51bGwsIFt7XG4gICAga2V5OiAnY3JlYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZSA9IF9nZXQoRm9ybXVsYUJsb3QuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGb3JtdWxhQmxvdCksICdjcmVhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHdpbmRvdy5rYXRleC5yZW5kZXIodmFsdWUsIG5vZGUsIHtcbiAgICAgICAgICB0aHJvd09uRXJyb3I6IGZhbHNlLFxuICAgICAgICAgIGVycm9yQ29sb3I6ICcjZjAwJ1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd2YWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGRvbU5vZGUpIHtcbiAgICAgIHJldHVybiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb3JtdWxhQmxvdDtcbn0oX2VtYmVkMi5kZWZhdWx0KTtcblxuRm9ybXVsYUJsb3QuYmxvdE5hbWUgPSAnZm9ybXVsYSc7XG5Gb3JtdWxhQmxvdC5jbGFzc05hbWUgPSAncWwtZm9ybXVsYSc7XG5Gb3JtdWxhQmxvdC50YWdOYW1lID0gJ1NQQU4nO1xuXG52YXIgRm9ybXVsYSA9IGZ1bmN0aW9uIChfTW9kdWxlKSB7XG4gIF9pbmhlcml0cyhGb3JtdWxhLCBfTW9kdWxlKTtcblxuICBfY3JlYXRlQ2xhc3MoRm9ybXVsYSwgbnVsbCwgW3tcbiAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKCkge1xuICAgICAgX3F1aWxsMi5kZWZhdWx0LnJlZ2lzdGVyKEZvcm11bGFCbG90LCB0cnVlKTtcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBGb3JtdWxhKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JtdWxhKTtcblxuICAgIHZhciBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRm9ybXVsYS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZvcm11bGEpKS5jYWxsKHRoaXMpKTtcblxuICAgIGlmICh3aW5kb3cua2F0ZXggPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtdWxhIG1vZHVsZSByZXF1aXJlcyBLYVRlWC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIHJldHVybiBGb3JtdWxhO1xufShfbW9kdWxlMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5Gb3JtdWxhQmxvdCA9IEZvcm11bGFCbG90O1xuZXhwb3J0cy5kZWZhdWx0ID0gRm9ybXVsYTtcblxuLyoqKi8gfSksXG4vKiA3NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5Db2RlVG9rZW4gPSBleHBvcnRzLkNvZGVCbG9jayA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3BhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcGFyY2htZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmNobWVudCk7XG5cbnZhciBfcXVpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX3F1aWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3F1aWxsKTtcblxudmFyIF9tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX21vZHVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb2R1bGUpO1xuXG52YXIgX2NvZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIF9jb2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvZGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBTeW50YXhDb2RlQmxvY2sgPSBmdW5jdGlvbiAoX0NvZGVCbG9jaykge1xuICBfaW5oZXJpdHMoU3ludGF4Q29kZUJsb2NrLCBfQ29kZUJsb2NrKTtcblxuICBmdW5jdGlvbiBTeW50YXhDb2RlQmxvY2soKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN5bnRheENvZGVCbG9jayk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFN5bnRheENvZGVCbG9jay5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN5bnRheENvZGVCbG9jaykpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN5bnRheENvZGVCbG9jaywgW3tcbiAgICBrZXk6ICdyZXBsYWNlV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VXaXRoKGJsb2NrKSB7XG4gICAgICB0aGlzLmRvbU5vZGUudGV4dENvbnRlbnQgPSB0aGlzLmRvbU5vZGUudGV4dENvbnRlbnQ7XG4gICAgICB0aGlzLmF0dGFjaCgpO1xuICAgICAgX2dldChTeW50YXhDb2RlQmxvY2sucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3ludGF4Q29kZUJsb2NrLnByb3RvdHlwZSksICdyZXBsYWNlV2l0aCcsIHRoaXMpLmNhbGwodGhpcywgYmxvY2spO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hpZ2hsaWdodCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZ2hsaWdodChfaGlnaGxpZ2h0KSB7XG4gICAgICB2YXIgdGV4dCA9IHRoaXMuZG9tTm9kZS50ZXh0Q29udGVudDtcbiAgICAgIGlmICh0aGlzLmNhY2hlZFRleHQgIT09IHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQudHJpbSgpLmxlbmd0aCA+IDAgfHwgdGhpcy5jYWNoZWRUZXh0ID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmRvbU5vZGUuaW5uZXJIVE1MID0gX2hpZ2hsaWdodCh0ZXh0KTtcbiAgICAgICAgICB0aGlzLmRvbU5vZGUubm9ybWFsaXplKCk7XG4gICAgICAgICAgdGhpcy5hdHRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlZFRleHQgPSB0ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTeW50YXhDb2RlQmxvY2s7XG59KF9jb2RlMi5kZWZhdWx0KTtcblxuU3ludGF4Q29kZUJsb2NrLmNsYXNzTmFtZSA9ICdxbC1zeW50YXgnO1xuXG52YXIgQ29kZVRva2VuID0gbmV3IF9wYXJjaG1lbnQyLmRlZmF1bHQuQXR0cmlidXRvci5DbGFzcygndG9rZW4nLCAnaGxqcycsIHtcbiAgc2NvcGU6IF9wYXJjaG1lbnQyLmRlZmF1bHQuU2NvcGUuSU5MSU5FXG59KTtcblxudmFyIFN5bnRheCA9IGZ1bmN0aW9uIChfTW9kdWxlKSB7XG4gIF9pbmhlcml0cyhTeW50YXgsIF9Nb2R1bGUpO1xuXG4gIF9jcmVhdGVDbGFzcyhTeW50YXgsIG51bGwsIFt7XG4gICAga2V5OiAncmVnaXN0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlcigpIHtcbiAgICAgIF9xdWlsbDIuZGVmYXVsdC5yZWdpc3RlcihDb2RlVG9rZW4sIHRydWUpO1xuICAgICAgX3F1aWxsMi5kZWZhdWx0LnJlZ2lzdGVyKFN5bnRheENvZGVCbG9jaywgdHJ1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gU3ludGF4KHF1aWxsLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN5bnRheCk7XG5cbiAgICB2YXIgX3RoaXMyID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFN5bnRheC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN5bnRheCkpLmNhbGwodGhpcywgcXVpbGwsIG9wdGlvbnMpKTtcblxuICAgIGlmICh0eXBlb2YgX3RoaXMyLm9wdGlvbnMuaGlnaGxpZ2h0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N5bnRheCBtb2R1bGUgcmVxdWlyZXMgaGlnaGxpZ2h0LmpzLiBQbGVhc2UgaW5jbHVkZSB0aGUgbGlicmFyeSBvbiB0aGUgcGFnZSBiZWZvcmUgUXVpbGwuJyk7XG4gICAgfVxuICAgIHZhciB0aW1lciA9IG51bGw7XG4gICAgX3RoaXMyLnF1aWxsLm9uKF9xdWlsbDIuZGVmYXVsdC5ldmVudHMuU0NST0xMX09QVElNSVpFLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmhpZ2hsaWdodCgpO1xuICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICB9LCBfdGhpczIub3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgfSk7XG4gICAgX3RoaXMyLmhpZ2hsaWdodCgpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3ludGF4LCBbe1xuICAgIGtleTogJ2hpZ2hsaWdodCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZ2hsaWdodCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5xdWlsbC5zZWxlY3Rpb24uY29tcG9zaW5nKSByZXR1cm47XG4gICAgICB0aGlzLnF1aWxsLnVwZGF0ZShfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5VU0VSKTtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICB0aGlzLnF1aWxsLnNjcm9sbC5kZXNjZW5kYW50cyhTeW50YXhDb2RlQmxvY2spLmZvckVhY2goZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgY29kZS5oaWdobGlnaHQoX3RoaXMzLm9wdGlvbnMuaGlnaGxpZ2h0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5xdWlsbC51cGRhdGUoX3F1aWxsMi5kZWZhdWx0LnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIGlmIChyYW5nZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLCBfcXVpbGwyLmRlZmF1bHQuc291cmNlcy5TSUxFTlQpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTeW50YXg7XG59KF9tb2R1bGUyLmRlZmF1bHQpO1xuXG5TeW50YXguREVGQVVMVFMgPSB7XG4gIGhpZ2hsaWdodDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh3aW5kb3cuaGxqcyA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB3aW5kb3cuaGxqcy5oaWdobGlnaHRBdXRvKHRleHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9O1xuICB9KCksXG4gIGludGVydmFsOiAxMDAwXG59O1xuXG5leHBvcnRzLkNvZGVCbG9jayA9IFN5bnRheENvZGVCbG9jaztcbmV4cG9ydHMuQ29kZVRva2VuID0gQ29kZVRva2VuO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3ludGF4O1xuXG4vKioqLyB9KSxcbi8qIDc2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0zIHgyPTE1IHkxPTkgeTI9OT48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0zIHgyPTEzIHkxPTE0IHkyPTE0PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTMgeDI9OSB5MT00IHkyPTQ+PC9saW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA3NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTUgeDI9MyB5MT05IHkyPTk+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTQgeDI9NCB5MT0xNCB5Mj0xND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xMiB4Mj02IHkxPTQgeTI9ND48L2xpbmU+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDc4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xNSB4Mj0zIHkxPTkgeTI9OT48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0xNSB4Mj01IHkxPTE0IHkyPTE0PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTE1IHgyPTkgeTE9NCB5Mj00PjwvbGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogNzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTE1IHgyPTMgeTE9OSB5Mj05PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTE1IHgyPTMgeTE9MTQgeTI9MTQ+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTUgeDI9MyB5MT00IHkyPTQ+PC9saW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA4MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8ZyBjbGFzcz1cXFwicWwtZmlsbCBxbC1jb2xvci1sYWJlbFxcXCI+IDxwb2x5Z29uIHBvaW50cz1cXFwiNiA2Ljg2OCA2IDYgNSA2IDUgNyA1Ljk0MiA3IDYgNi44NjhcXFwiPjwvcG9seWdvbj4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTQgeT00PjwvcmVjdD4gPHBvbHlnb24gcG9pbnRzPVxcXCI2LjgxNyA1IDYgNSA2IDYgNi4zOCA2IDYuODE3IDVcXFwiPjwvcG9seWdvbj4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTIgeT02PjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTMgeT01PjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTQgeT03PjwvcmVjdD4gPHBvbHlnb24gcG9pbnRzPVxcXCI0IDExLjQzOSA0IDExIDMgMTEgMyAxMiAzLjc1NSAxMiA0IDExLjQzOVxcXCI+PC9wb2x5Z29uPiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MiB5PTEyPjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTIgeT05PjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTIgeT0xNT48L3JlY3Q+IDxwb2x5Z29uIHBvaW50cz1cXFwiNC42MyAxMCA0IDEwIDQgMTEgNC4xOTIgMTEgNC42MyAxMFxcXCI+PC9wb2x5Z29uPiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MyB5PTg+PC9yZWN0PiA8cGF0aCBkPU0xMC44MzIsNC4yTDExLDQuNTgyVjRIMTAuNzA4QTEuOTQ4LDEuOTQ4LDAsMCwxLDEwLjgzMiw0LjJaPjwvcGF0aD4gPHBhdGggZD1NNyw0LjU4Mkw3LjE2OCw0LjJBMS45MjksMS45MjksMCwwLDEsNy4yOTIsNEg3VjQuNTgyWj48L3BhdGg+IDxwYXRoIGQ9TTgsMTNINy42ODNsLTAuMzUxLjhhMS45MzMsMS45MzMsMCwwLDEtLjEyNC4ySDhWMTNaPjwvcGF0aD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTEyIHk9Mj48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xMSB5PTM+PC9yZWN0PiA8cGF0aCBkPU05LDNIOFYzLjI4MkExLjk4NSwxLjk4NSwwLDAsMSw5LDNaPjwvcGF0aD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTIgeT0zPjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTYgeT0yPjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTMgeT0yPjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTUgeT0zPjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTkgeT0yPjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTE1IHk9MTQ+PC9yZWN0PiA8cG9seWdvbiBwb2ludHM9XFxcIjEzLjQ0NyAxMC4xNzQgMTMuNDY5IDEwLjIyNSAxMy40NzIgMTAuMjMyIDEzLjgwOCAxMSAxNCAxMSAxNCAxMCAxMy4zNyAxMCAxMy40NDcgMTAuMTc0XFxcIj48L3BvbHlnb24+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xMyB5PTc+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTUgeT01PjwvcmVjdD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTE0IHk9Nj48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xNSB5PTg+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTQgeT05PjwvcmVjdD4gPHBhdGggZD1NMy43NzUsMTRIM3YxSDRWMTQuMzE0QTEuOTcsMS45NywwLDAsMSwzLjc3NSwxNFo+PC9wYXRoPiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTQgeT0zPjwvcmVjdD4gPHBvbHlnb24gcG9pbnRzPVxcXCIxMiA2Ljg2OCAxMiA2IDExLjYyIDYgMTIgNi44NjhcXFwiPjwvcG9seWdvbj4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTE1IHk9Mj48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xMiB5PTU+PC9yZWN0PiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTMgeT00PjwvcmVjdD4gPHBvbHlnb24gcG9pbnRzPVxcXCIxMi45MzMgOSAxMyA5IDEzIDggMTIuNDk1IDggMTIuOTMzIDlcXFwiPjwvcG9seWdvbj4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTkgeT0xND48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD04IHk9MTU+PC9yZWN0PiA8cGF0aCBkPU02LDE0LjkyNlYxNUg3VjE0LjMxNkExLjk5MywxLjk5MywwLDAsMSw2LDE0LjkyNlo+PC9wYXRoPiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9NSB5PTE1PjwvcmVjdD4gPHBhdGggZD1NMTAuNjY4LDEzLjhMMTAuMzE3LDEzSDEwdjFoMC43OTJBMS45NDcsMS45NDcsMCwwLDEsMTAuNjY4LDEzLjhaPjwvcGF0aD4gPHJlY3QgaGVpZ2h0PTEgd2lkdGg9MSB4PTExIHk9MTU+PC9yZWN0PiA8cGF0aCBkPU0xNC4zMzIsMTIuMmExLjk5LDEuOTksMCwwLDEsLjE2Ni44SDE1VjEySDE0LjI0NVo+PC9wYXRoPiA8cmVjdCBoZWlnaHQ9MSB3aWR0aD0xIHg9MTQgeT0xNT48L3JlY3Q+IDxyZWN0IGhlaWdodD0xIHdpZHRoPTEgeD0xNSB5PTExPjwvcmVjdD4gPC9nPiA8cG9seWxpbmUgY2xhc3M9cWwtc3Ryb2tlIHBvaW50cz1cXFwiNS41IDEzIDkgNSAxMi41IDEzXFxcIj48L3BvbHlsaW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTEuNjMgeDI9Ni4zOCB5MT0xMSB5Mj0xMT48L2xpbmU+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDgxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxyZWN0IGNsYXNzPVxcXCJxbC1maWxsIHFsLXN0cm9rZVxcXCIgaGVpZ2h0PTMgd2lkdGg9MyB4PTQgeT01PjwvcmVjdD4gPHJlY3QgY2xhc3M9XFxcInFsLWZpbGwgcWwtc3Ryb2tlXFxcIiBoZWlnaHQ9MyB3aWR0aD0zIHg9MTEgeT01PjwvcmVjdD4gPHBhdGggY2xhc3M9XFxcInFsLWV2ZW4gcWwtZmlsbCBxbC1zdHJva2VcXFwiIGQ9TTcsOGMwLDQuMDMxLTMsNS0zLDU+PC9wYXRoPiA8cGF0aCBjbGFzcz1cXFwicWwtZXZlbiBxbC1maWxsIHFsLXN0cm9rZVxcXCIgZD1NMTQsOGMwLDQuMDMxLTMsNS0zLDU+PC9wYXRoPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA4MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cGF0aCBjbGFzcz1xbC1zdHJva2UgZD1NNSw0SDkuNUEyLjUsMi41LDAsMCwxLDEyLDYuNXYwQTIuNSwyLjUsMCwwLDEsOS41LDlINUEwLDAsMCwwLDEsNSw5VjRBMCwwLDAsMCwxLDUsNFo+PC9wYXRoPiA8cGF0aCBjbGFzcz1xbC1zdHJva2UgZD1NNSw5aDUuNUEyLjUsMi41LDAsMCwxLDEzLDExLjV2MEEyLjUsMi41LDAsMCwxLDEwLjUsMTRINWEwLDAsMCwwLDEsMCwwVjlBMCwwLDAsMCwxLDUsOVo+PC9wYXRoPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA4MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBjbGFzcz1cXFwiXFxcIiB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9NSB4Mj0xMyB5MT0zIHkyPTM+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9NiB4Mj05LjM1IHkxPTEyIHkyPTM+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTEgeDI9MTUgeTE9MTEgeTI9MTU+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTUgeDI9MTEgeTE9MTEgeTI9MTU+PC9saW5lPiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xIHJ4PTAuNSByeT0wLjUgd2lkdGg9NyB4PTIgeT0xND48L3JlY3Q+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDg0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPVxcXCJxbC1jb2xvci1sYWJlbCBxbC1zdHJva2UgcWwtdHJhbnNwYXJlbnRcXFwiIHgxPTMgeDI9MTUgeTE9MTUgeTI9MTU+PC9saW5lPiA8cG9seWxpbmUgY2xhc3M9cWwtc3Ryb2tlIHBvaW50cz1cXFwiNS41IDExIDkgMyAxMi41IDExXFxcIj48L3BvbHlsaW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MTEuNjMgeDI9Ni4zOCB5MT05IHkyPTk+PC9saW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA4NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cG9seWdvbiBjbGFzcz1cXFwicWwtc3Ryb2tlIHFsLWZpbGxcXFwiIHBvaW50cz1cXFwiMyAxMSA1IDkgMyA3IDMgMTFcXFwiPjwvcG9seWdvbj4gPGxpbmUgY2xhc3M9XFxcInFsLXN0cm9rZSBxbC1maWxsXFxcIiB4MT0xNSB4Mj0xMSB5MT00IHkyPTQ+PC9saW5lPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTExLDNhMywzLDAsMCwwLDAsNmgxVjNIMTFaPjwvcGF0aD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MTEgd2lkdGg9MSB4PTExIHk9ND48L3JlY3Q+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTExIHdpZHRoPTEgeD0xMyB5PTQ+PC9yZWN0PiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA4NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cG9seWdvbiBjbGFzcz1cXFwicWwtc3Ryb2tlIHFsLWZpbGxcXFwiIHBvaW50cz1cXFwiMTUgMTIgMTMgMTAgMTUgOCAxNSAxMlxcXCI+PC9wb2x5Z29uPiA8bGluZSBjbGFzcz1cXFwicWwtc3Ryb2tlIHFsLWZpbGxcXFwiIHgxPTkgeDI9NSB5MT00IHkyPTQ+PC9saW5lPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTUsM0EzLDMsMCwwLDAsNSw5SDZWM0g1Wj48L3BhdGg+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTExIHdpZHRoPTEgeD01IHk9ND48L3JlY3Q+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTExIHdpZHRoPTEgeD03IHk9ND48L3JlY3Q+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDg3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTQsMTZINGExLDEsMCwwLDEsMC0ySDE0QTEsMSwwLDAsMSwxNCwxNlogLz4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xNCw0SDRBMSwxLDAsMCwxLDQsMkgxNEExLDEsMCwwLDEsMTQsNFogLz4gPHJlY3QgY2xhc3M9cWwtZmlsbCB4PTMgeT02IHdpZHRoPTEyIGhlaWdodD02IHJ4PTEgcnk9MSAvPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA4OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTEzLDE2SDVhMSwxLDAsMCwxLDAtMmg4QTEsMSwwLDAsMSwxMywxNlogLz4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xMyw0SDVBMSwxLDAsMCwxLDUsMmg4QTEsMSwwLDAsMSwxMyw0WiAvPiA8cmVjdCBjbGFzcz1xbC1maWxsIHg9MiB5PTYgd2lkdGg9MTQgaGVpZ2h0PTYgcng9MSByeT0xIC8+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDg5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTUsOEgxM2ExLDEsMCwwLDEsMC0yaDJBMSwxLDAsMCwxLDE1LDhaIC8+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTUsMTJIMTNhMSwxLDAsMCwxLDAtMmgyQTEsMSwwLDAsMSwxNSwxMlogLz4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xNSwxNkg1YTEsMSwwLDAsMSwwLTJIMTVBMSwxLDAsMCwxLDE1LDE2WiAvPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTE1LDRINUExLDEsMCwwLDEsNSwySDE1QTEsMSwwLDAsMSwxNSw0WiAvPiA8cmVjdCBjbGFzcz1xbC1maWxsIHg9MiB5PTYgd2lkdGg9OCBoZWlnaHQ9NiByeD0xIHJ5PTEgLz4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogOTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU01LDhIM0ExLDEsMCwwLDEsMyw2SDVBMSwxLDAsMCwxLDUsOFogLz4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU01LDEySDNhMSwxLDAsMCwxLDAtMkg1QTEsMSwwLDAsMSw1LDEyWiAvPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTEzLDE2SDNhMSwxLDAsMCwxLDAtMkgxM0ExLDEsMCwwLDEsMTMsMTZaIC8+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTMsNEgzQTEsMSwwLDAsMSwzLDJIMTNBMSwxLDAsMCwxLDEzLDRaIC8+IDxyZWN0IGNsYXNzPXFsLWZpbGwgeD04IHk9NiB3aWR0aD04IGhlaWdodD02IHJ4PTEgcnk9MSB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgyNCAxOCkgcm90YXRlKC0xODApXFxcIi8+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDkxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NMTEuNzU5LDIuNDgyYTIuNTYxLDIuNTYxLDAsMCwwLTMuNTMuNjA3QTcuNjU2LDcuNjU2LDAsMCwwLDYuOCw2LjJDNi4xMDksOS4xODgsNS4yNzUsMTQuNjc3LDQuMTUsMTQuOTI3YTEuNTQ1LDEuNTQ1LDAsMCwwLTEuMy0uOTMzQTAuOTIyLDAuOTIyLDAsMCwwLDIsMTUuMDM2UzEuOTU0LDE2LDQuMTE5LDE2czMuMDkxLTIuNjkxLDMuNy01LjU1M2MwLjE3Ny0uODI2LjM2LTEuNzI2LDAuNTU0LTIuNkw4Ljc3NSw2LjJjMC4zODEtMS40MjEuODA3LTIuNTIxLDEuMzA2LTIuNjc2YTEuMDE0LDEuMDE0LDAsMCwwLDEuMDIuNTZBMC45NjYsMC45NjYsMCwwLDAsMTEuNzU5LDIuNDgyWj48L3BhdGg+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTEuNiByeD0wLjggcnk9MC44IHdpZHRoPTUgeD01LjE1IHk9Ni4yPjwvcmVjdD4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xMy42NjMsMTIuMDI3YTEuNjYyLDEuNjYyLDAsMCwxLC4yNjYtMC4yNzZxMC4xOTMsMC4wNjkuNDU2LDAuMTM4YTIuMSwyLjEsMCwwLDAsLjUzNS4wNjksMS4wNzUsMS4wNzUsMCwwLDAsLjc2Ny0wLjMsMS4wNDQsMS4wNDQsMCwwLDAsLjMxNC0wLjgsMC44NCwwLjg0LDAsMCwwLS4yMzgtMC42MTksMC44LDAuOCwwLDAsMC0uNTk0LTAuMjM5LDEuMTU0LDEuMTU0LDAsMCwwLS43ODEuMyw0LjYwNyw0LjYwNywwLDAsMC0uNzgxLDFxLTAuMDkxLjE1LS4yMTgsMC4zNDZsLTAuMjQ2LjM4Yy0wLjA2OC0uMjg4LTAuMTM3LTAuNTgyLTAuMjEyLTAuODg1LTAuNDU5LTEuODQ3LTIuNDk0LS45ODQtMi45NDEtMC44LTAuNDgyLjItLjM1MywwLjY0Ny0wLjA5NCwwLjUyOWEwLjg2OSwwLjg2OSwwLDAsMSwxLjI4MS41ODVjMC4yMTcsMC43NTEuMzc3LDEuNDM2LDAuNTI3LDIuMDM4YTUuNjg4LDUuNjg4LDAsMCwxLS4zNjIuNDY3LDIuNjksMi42OSwwLDAsMS0uMjY0LjI3MXEtMC4yMjEtLjA4LTAuNDcxLTAuMTQ3YTIuMDI5LDIuMDI5LDAsMCwwLS41MjItMC4wNjYsMS4wNzksMS4wNzksMCwwLDAtLjc2OC4zQTEuMDU4LDEuMDU4LDAsMCwwLDksMTUuMTMxYTAuODIsMC44MiwwLDAsMCwuODMyLjg1MiwxLjEzNCwxLjEzNCwwLDAsMCwuNzg3LTAuMyw1LjExLDUuMTEsMCwwLDAsLjc3Ni0wLjk5M3EwLjE0MS0uMjE5LjIxNS0wLjM0YzAuMDQ2LS4wNzYuMTIyLTAuMTk0LDAuMjIzLTAuMzQ2YTIuNzg2LDIuNzg2LDAsMCwwLC45MTgsMS43MjYsMi41ODIsMi41ODIsMCwwLDAsMi4zNzYtLjE4NWMwLjMxNy0uMTgxLjIxMi0wLjU2NSwwLTAuNDk0QTAuODA3LDAuODA3LDAsMCwxLDE0LjE3NiwxNWE1LjE1OSw1LjE1OSwwLDAsMS0uOTEzLTIuNDQ2bDAsMFExMy40ODcsMTIuMjQsMTMuNjYzLDEyLjAyN1o+PC9wYXRoPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA5MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Qm94PVxcXCIwIDAgMTggMThcXFwiPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTEwLDRWMTRhMSwxLDAsMCwxLTIsMFYxMEgzdjRhMSwxLDAsMCwxLTIsMFY0QTEsMSwwLDAsMSwzLDRWOEg4VjRhMSwxLDAsMCwxLDIsMFptNi4wNjc4Nyw5LjIwOUgxNC45ODk3NVY3LjU5ODYzYS41NDA4NS41NDA4NSwwLDAsMC0uNjA1LS42MDU0N2gtLjYyNzQ0YTEuMDExMTksMS4wMTExOSwwLDAsMC0uNzQ4LjI5Njg4TDExLjY0NSw4LjU2NjQxYS41NDM1LjU0MzUsMCwwLDAtLjAyMi44NTg0bC4yODYxMy4zMDc2MmEuNTM4NjEuNTM4NjEsMCwwLDAsLjg0NzE3LjAzMzJsLjA5OTEyLS4wODc4OWExLjIxMzcsMS4yMTM3LDAsMCwwLC4yNDE3LS4zNTI1NGguMDIyNDZzLS4wMTEyMy4zMDg1OS0uMDExMjMuNjA1NDdWMTMuMjA5SDEyLjA0MWEuNTQwODUuNTQwODUsMCwwLDAtLjYwNS42MDU0N3YuNDM5NDVhLjU0MDg1LjU0MDg1LDAsMCwwLC42MDUuNjA1NDdoNC4wMjY4NmEuNTQwODUuNTQwODUsMCwwLDAsLjYwNS0uNjA1NDd2LS40Mzk0NUEuNTQwODUuNTQwODUsMCwwLDAsMTYuMDY3ODcsMTMuMjA5WiAvPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA5MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Qm94PVxcXCIwIDAgMTggMThcXFwiPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTE2LjczOTc1LDEzLjgxNDQ1di40Mzk0NWEuNTQwODUuNTQwODUsMCwwLDEtLjYwNS42MDU0N0gxMS44NTVhLjU4MzkyLjU4MzkyLDAsMCwxLS42NDg5My0uNjA1NDdWMTQuMDEyN2MwLTIuOTA1MjcsMy4zOTk0MS0zLjQyMTg3LDMuMzk5NDEtNC41NTQ2OWEuNzc2NzUuNzc2NzUsMCwwLDAtLjg0NzE3LS43ODEyNSwxLjE3Njg0LDEuMTc2ODQsMCwwLDAtLjgzNTk0LjM4NDc3Yy0uMjc0OS4yNjM2Ny0uNTYxLjM3NC0uODU3OTEuMTMxODRsLS40MjkyLS4zNDA4MmMtLjMwODExLS4yNDIxOS0uMzg1MjUtLjUxNzU4LS4xNTQzLS44MTQ0NWEyLjk3MTU1LDIuOTcxNTUsMCwwLDEsMi40NTM2MS0xLjE3Njc2LDIuNDUzOTMsMi40NTM5MywwLDAsMSwyLjY4NDA4LDIuNDA5MThjMCwyLjQ1MzEyLTMuMTc5MiwyLjkyNjc2LTMuMjc4MzIsMy45Mzg0OGgyLjc5NDQzQS41NDA4NS41NDA4NSwwLDAsMSwxNi43Mzk3NSwxMy44MTQ0NVpNOSwzQS45OTk3NC45OTk3NCwwLDAsMCw4LDRWOEgzVjRBMSwxLDAsMCwwLDEsNFYxNGExLDEsMCwwLDAsMiwwVjEwSDh2NGExLDEsMCwwLDAsMiwwVjRBLjk5OTc0Ljk5OTc0LDAsMCwwLDksM1ogLz4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogOTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTcgeDI9MTMgeTE9NCB5Mj00PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTUgeDI9MTEgeTE9MTQgeTI9MTQ+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9OCB4Mj0xMCB5MT0xNCB5Mj00PjwvbGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogOTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHJlY3QgY2xhc3M9cWwtc3Ryb2tlIGhlaWdodD0xMCB3aWR0aD0xMiB4PTMgeT00PjwvcmVjdD4gPGNpcmNsZSBjbGFzcz1xbC1maWxsIGN4PTYgY3k9NyByPTE+PC9jaXJjbGU+IDxwb2x5bGluZSBjbGFzcz1cXFwicWwtZXZlbiBxbC1maWxsXFxcIiBwb2ludHM9XFxcIjUgMTIgNSAxMSA3IDkgOCAxMCAxMSA3IDEzIDkgMTMgMTIgNSAxMlxcXCI+PC9wb2x5bGluZT4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogOTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTMgeDI9MTUgeTE9MTQgeTI9MTQ+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MyB4Mj0xNSB5MT00IHkyPTQ+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9OSB4Mj0xNSB5MT05IHkyPTk+PC9saW5lPiA8cG9seWxpbmUgY2xhc3M9XFxcInFsLWZpbGwgcWwtc3Ryb2tlXFxcIiBwb2ludHM9XFxcIjMgNyAzIDExIDUgOSAzIDdcXFwiPjwvcG9seWxpbmU+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDk3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0zIHgyPTE1IHkxPTE0IHkyPTE0PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTMgeDI9MTUgeTE9NCB5Mj00PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTkgeDI9MTUgeTE9OSB5Mj05PjwvbGluZT4gPHBvbHlsaW5lIGNsYXNzPXFsLXN0cm9rZSBwb2ludHM9XFxcIjUgNyA1IDExIDMgOSA1IDdcXFwiPjwvcG9seWxpbmU+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDk4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT03IHgyPTExIHkxPTcgeTI9MTE+PC9saW5lPiA8cGF0aCBjbGFzcz1cXFwicWwtZXZlbiBxbC1zdHJva2VcXFwiIGQ9TTguOSw0LjU3N2EzLjQ3NiwzLjQ3NiwwLDAsMSwuMzYsNC42NzlBMy40NzYsMy40NzYsMCwwLDEsNC41NzcsOC45QzMuMTg1LDcuNSwyLjAzNSw2LjQsNC4yMTcsNC4yMTdTNy41LDMuMTg1LDguOSw0LjU3N1o+PC9wYXRoPiA8cGF0aCBjbGFzcz1cXFwicWwtZXZlbiBxbC1zdHJva2VcXFwiIGQ9TTEzLjQyMyw5LjFhMy40NzYsMy40NzYsMCwwLDAtNC42NzktLjM2LDMuNDc2LDMuNDc2LDAsMCwwLC4zNiw0LjY3OWMxLjM5MiwxLjM5MiwyLjUsMi41NDIsNC42NzkuMzZTMTQuODE1LDEwLjUsMTMuNDIzLDkuMVo+PC9wYXRoPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiA5OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9NyB4Mj0xNSB5MT00IHkyPTQ+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9NyB4Mj0xNSB5MT05IHkyPTk+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9NyB4Mj0xNSB5MT0xNCB5Mj0xND48L2xpbmU+IDxsaW5lIGNsYXNzPVxcXCJxbC1zdHJva2UgcWwtdGhpblxcXCIgeDE9Mi41IHgyPTQuNSB5MT01LjUgeTI9NS41PjwvbGluZT4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0zLjUsNkEwLjUsMC41LDAsMCwxLDMsNS41VjMuMDg1bC0wLjI3Ni4xMzhBMC41LDAuNSwwLDAsMSwyLjA1MywzYy0wLjEyNC0uMjQ3LTAuMDIzLTAuMzI0LjIyNC0wLjQ0N2wxLS41QTAuNSwwLjUsMCwwLDEsNCwyLjV2M0EwLjUsMC41LDAsMCwxLDMuNSw2Wj48L3BhdGg+IDxwYXRoIGNsYXNzPVxcXCJxbC1zdHJva2UgcWwtdGhpblxcXCIgZD1NNC41LDEwLjVoLTJjMC0uMjM0LDEuODUtMS4wNzYsMS44NS0yLjIzNEEwLjk1OSwwLjk1OSwwLDAsMCwyLjUsOC4xNTY+PC9wYXRoPiA8cGF0aCBjbGFzcz1cXFwicWwtc3Ryb2tlIHFsLXRoaW5cXFwiIGQ9TTIuNSwxNC44NDZhMC45NTksMC45NTksMCwwLDAsMS44NS0uMTA5QTAuNywwLjcsMCwwLDAsMy43NSwxNGEwLjY4OCwwLjY4OCwwLDAsMCwuNi0wLjczNiwwLjk1OSwwLjk1OSwwLDAsMC0xLjg1LS4xMDk+PC9wYXRoPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiAxMDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTYgeDI9MTUgeTE9NCB5Mj00PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTYgeDI9MTUgeTE9OSB5Mj05PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTYgeDI9MTUgeTE9MTQgeTI9MTQ+PC9saW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9MyB4Mj0zIHkxPTQgeTI9ND48L2xpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT0zIHgyPTMgeTE9OSB5Mj05PjwvbGluZT4gPGxpbmUgY2xhc3M9cWwtc3Ryb2tlIHgxPTMgeDI9MyB5MT0xNCB5Mj0xND48L2xpbmU+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDEwMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyBjbGFzcz1cXFwiXFxcIiB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9OSB4Mj0xNSB5MT00IHkyPTQ+PC9saW5lPiA8cG9seWxpbmUgY2xhc3M9cWwtc3Ryb2tlIHBvaW50cz1cXFwiMyA0IDQgNSA2IDNcXFwiPjwvcG9seWxpbmU+IDxsaW5lIGNsYXNzPXFsLXN0cm9rZSB4MT05IHgyPTE1IHkxPTE0IHkyPTE0PjwvbGluZT4gPHBvbHlsaW5lIGNsYXNzPXFsLXN0cm9rZSBwb2ludHM9XFxcIjMgMTQgNCAxNSA2IDEzXFxcIj48L3BvbHlsaW5lPiA8bGluZSBjbGFzcz1xbC1zdHJva2UgeDE9OSB4Mj0xNSB5MT05IHkyPTk+PC9saW5lPiA8cG9seWxpbmUgY2xhc3M9cWwtc3Ryb2tlIHBvaW50cz1cXFwiMyA5IDQgMTAgNiA4XFxcIj48L3BvbHlsaW5lPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiAxMDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xNS41LDE1SDEzLjg2MWEzLjg1OCwzLjg1OCwwLDAsMCwxLjkxNC0yLjk3NSwxLjgsMS44LDAsMCwwLTEuNi0xLjc1MUExLjkyMSwxLjkyMSwwLDAsMCwxMi4wMjEsMTEuN2EwLjUwMDEzLDAuNTAwMTMsMCwxLDAsLjk1Ny4yOTFoMGEwLjkxNCwwLjkxNCwwLDAsMSwxLjA1My0uNzI1LDAuODEsMC44MSwwLDAsMSwuNzQ0Ljc2MmMwLDEuMDc2LTEuMTY5NzEsMS44Njk4Mi0xLjkzOTcxLDIuNDMwODJBMS40NTYzOSwxLjQ1NjM5LDAsMCwwLDEyLDE1LjVhMC41LDAuNSwwLDAsMCwuNS41aDNBMC41LDAuNSwwLDAsMCwxNS41LDE1WiAvPiA8cGF0aCBjbGFzcz1xbC1maWxsIGQ9TTkuNjUsNS4yNDFhMSwxLDAsMCwwLTEuNDA5LjEwOEw2LDcuOTY0LDMuNzU5LDUuMzQ5QTEsMSwwLDAsMCwyLjE5Miw2LjU5MTc4UTIuMjE1NDEsNi42MjEzLDIuMjQxLDYuNjQ5TDQuNjg0LDkuNSwyLjI0MSwxMi4zNUExLDEsMCwwLDAsMy43MSwxMy43MDcyMnEwLjAyNTU3LS4wMjc2OC4wNDktMC4wNTcyMkw2LDExLjAzNiw4LjI0MSwxMy42NWExLDEsMCwxLDAsMS41NjctMS4yNDI3N1E5Ljc4NDU5LDEyLjM3NzcsOS43NTksMTIuMzVMNy4zMTYsOS41LDkuNzU5LDYuNjUxQTEsMSwwLDAsMCw5LjY1LDUuMjQxWiAvPiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiAxMDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU0xNS41LDdIMTMuODYxYTQuMDE1LDQuMDE1LDAsMCwwLDEuOTE0LTIuOTc1LDEuOCwxLjgsMCwwLDAtMS42LTEuNzUxQTEuOTIyLDEuOTIyLDAsMCwwLDEyLjAyMSwzLjdhMC41LDAuNSwwLDEsMCwuOTU3LjI5MSwwLjkxNywwLjkxNywwLDAsMSwxLjA1My0uNzI1LDAuODEsMC44MSwwLDAsMSwuNzQ0Ljc2MmMwLDEuMDc3LTEuMTY0LDEuOTI1LTEuOTM0LDIuNDg2QTEuNDIzLDEuNDIzLDAsMCwwLDEyLDcuNWEwLjUsMC41LDAsMCwwLC41LjVoM0EwLjUsMC41LDAsMCwwLDE1LjUsN1ogLz4gPHBhdGggY2xhc3M9cWwtZmlsbCBkPU05LjY1MSw1LjI0MWExLDEsMCwwLDAtMS40MS4xMDhMNiw3Ljk2NCwzLjc1OSw1LjM0OWExLDEsMCwxLDAtMS41MTksMS4zTDQuNjgzLDkuNSwyLjI0MSwxMi4zNWExLDEsMCwxLDAsMS41MTksMS4zTDYsMTEuMDM2LDguMjQxLDEzLjY1YTEsMSwwLDAsMCwxLjUxOS0xLjNMNy4zMTcsOS41LDkuNzU5LDYuNjUxQTEsMSwwLDAsMCw5LjY1MSw1LjI0MVogLz4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogMTA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxsaW5lIGNsYXNzPVxcXCJxbC1zdHJva2UgcWwtdGhpblxcXCIgeDE9MTUuNSB4Mj0yLjUgeTE9OC41IHkyPTkuNT48L2xpbmU+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NOS4wMDcsOEM2LjU0Miw3Ljc5MSw2LDcuNTE5LDYsNi41LDYsNS43OTIsNy4yODMsNSw5LDVjMS41NzEsMCwyLjc2NS42NzksMi45NjksMS4zMDlhMSwxLDAsMCwwLDEuOS0uNjE3QzEzLjM1Niw0LjEwNiwxMS4zNTQsMyw5LDMsNi4yLDMsNCw0LjUzOCw0LDYuNWEzLjIsMy4yLDAsMCwwLC41LDEuODQzWj48L3BhdGg+IDxwYXRoIGNsYXNzPXFsLWZpbGwgZD1NOC45ODQsMTBDMTEuNDU3LDEwLjIwOCwxMiwxMC40NzksMTIsMTEuNWMwLDAuNzA4LTEuMjgzLDEuNS0zLDEuNS0xLjU3MSwwLTIuNzY1LS42NzktMi45NjktMS4zMDlhMSwxLDAsMSwwLTEuOS42MTdDNC42NDQsMTMuODk0LDYuNjQ2LDE1LDksMTVjMi44LDAsNS0xLjUzOCw1LTMuNWEzLjIsMy4yLDAsMCwwLS41LTEuODQzWj48L3BhdGg+IDwvc3ZnPlwiO1xuXG4vKioqLyB9KSxcbi8qIDEwNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiPHN2ZyB2aWV3Ym94PVxcXCIwIDAgMTggMThcXFwiPiA8cGF0aCBjbGFzcz1xbC1zdHJva2UgZD1NNSwzVjlhNC4wMTIsNC4wMTIsMCwwLDAsNCw0SDlhNC4wMTIsNC4wMTIsMCwwLDAsNC00VjM+PC9wYXRoPiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xIHJ4PTAuNSByeT0wLjUgd2lkdGg9MTIgeD0zIHk9MTU+PC9yZWN0PiA8L3N2Zz5cIjtcblxuLyoqKi8gfSksXG4vKiAxMDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBcIjxzdmcgdmlld2JveD1cXFwiMCAwIDE4IDE4XFxcIj4gPHJlY3QgY2xhc3M9cWwtc3Ryb2tlIGhlaWdodD0xMiB3aWR0aD0xMiB4PTMgeT0zPjwvcmVjdD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MTIgd2lkdGg9MSB4PTUgeT0zPjwvcmVjdD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MTIgd2lkdGg9MSB4PTEyIHk9Mz48L3JlY3Q+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTIgd2lkdGg9OCB4PTUgeT04PjwvcmVjdD4gPHJlY3QgY2xhc3M9cWwtZmlsbCBoZWlnaHQ9MSB3aWR0aD0zIHg9MyB5PTU+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xIHdpZHRoPTMgeD0zIHk9Nz48L3JlY3Q+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTEgd2lkdGg9MyB4PTMgeT0xMD48L3JlY3Q+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTEgd2lkdGg9MyB4PTMgeT0xMj48L3JlY3Q+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTEgd2lkdGg9MyB4PTEyIHk9NT48L3JlY3Q+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTEgd2lkdGg9MyB4PTEyIHk9Nz48L3JlY3Q+IDxyZWN0IGNsYXNzPXFsLWZpbGwgaGVpZ2h0PTEgd2lkdGg9MyB4PTEyIHk9MTA+PC9yZWN0PiA8cmVjdCBjbGFzcz1xbC1maWxsIGhlaWdodD0xIHdpZHRoPTMgeD0xMiB5PTEyPjwvcmVjdD4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogMTA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCI8c3ZnIHZpZXdib3g9XFxcIjAgMCAxOCAxOFxcXCI+IDxwb2x5Z29uIGNsYXNzPXFsLXN0cm9rZSBwb2ludHM9XFxcIjcgMTEgOSAxMyAxMSAxMSA3IDExXFxcIj48L3BvbHlnb24+IDxwb2x5Z29uIGNsYXNzPXFsLXN0cm9rZSBwb2ludHM9XFxcIjcgNyA5IDUgMTEgNyA3IDdcXFwiPjwvcG9seWdvbj4gPC9zdmc+XCI7XG5cbi8qKiovIH0pLFxuLyogMTA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLkJ1YmJsZVRvb2x0aXAgPSB1bmRlZmluZWQ7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9leHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2V4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmQpO1xuXG52YXIgX2VtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgX2VtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZW1pdHRlcik7XG5cbnZhciBfYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuXG52YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XG5cbnZhciBfc2VsZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfaWNvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcblxudmFyIF9pY29uczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pY29ucyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFRPT0xCQVJfQ09ORklHID0gW1snYm9sZCcsICdpdGFsaWMnLCAnbGluayddLCBbeyBoZWFkZXI6IDEgfSwgeyBoZWFkZXI6IDIgfSwgJ2Jsb2NrcXVvdGUnXV07XG5cbnZhciBCdWJibGVUaGVtZSA9IGZ1bmN0aW9uIChfQmFzZVRoZW1lKSB7XG4gIF9pbmhlcml0cyhCdWJibGVUaGVtZSwgX0Jhc2VUaGVtZSk7XG5cbiAgZnVuY3Rpb24gQnViYmxlVGhlbWUocXVpbGwsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnViYmxlVGhlbWUpO1xuXG4gICAgaWYgKG9wdGlvbnMubW9kdWxlcy50b29sYmFyICE9IG51bGwgJiYgb3B0aW9ucy5tb2R1bGVzLnRvb2xiYXIuY29udGFpbmVyID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMubW9kdWxlcy50b29sYmFyLmNvbnRhaW5lciA9IFRPT0xCQVJfQ09ORklHO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChCdWJibGVUaGVtZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJ1YmJsZVRoZW1lKSkuY2FsbCh0aGlzLCBxdWlsbCwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMucXVpbGwuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3FsLWJ1YmJsZScpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdWJibGVUaGVtZSwgW3tcbiAgICBrZXk6ICdleHRlbmRUb29sYmFyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kVG9vbGJhcih0b29sYmFyKSB7XG4gICAgICB0aGlzLnRvb2x0aXAgPSBuZXcgQnViYmxlVG9vbHRpcCh0aGlzLnF1aWxsLCB0aGlzLm9wdGlvbnMuYm91bmRzKTtcbiAgICAgIHRoaXMudG9vbHRpcC5yb290LmFwcGVuZENoaWxkKHRvb2xiYXIuY29udGFpbmVyKTtcbiAgICAgIHRoaXMuYnVpbGRCdXR0b25zKFtdLnNsaWNlLmNhbGwodG9vbGJhci5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uJykpLCBfaWNvbnMyLmRlZmF1bHQpO1xuICAgICAgdGhpcy5idWlsZFBpY2tlcnMoW10uc2xpY2UuY2FsbCh0b29sYmFyLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3QnKSksIF9pY29uczIuZGVmYXVsdCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJ1YmJsZVRoZW1lO1xufShfYmFzZTIuZGVmYXVsdCk7XG5cbkJ1YmJsZVRoZW1lLkRFRkFVTFRTID0gKDAsIF9leHRlbmQyLmRlZmF1bHQpKHRydWUsIHt9LCBfYmFzZTIuZGVmYXVsdC5ERUZBVUxUUywge1xuICBtb2R1bGVzOiB7XG4gICAgdG9vbGJhcjoge1xuICAgICAgaGFuZGxlcnM6IHtcbiAgICAgICAgbGluazogZnVuY3Rpb24gbGluayh2YWx1ZSkge1xuICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdsaW5rJywgZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnF1aWxsLnRoZW1lLnRvb2x0aXAuZWRpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBCdWJibGVUb29sdGlwID0gZnVuY3Rpb24gKF9CYXNlVG9vbHRpcCkge1xuICBfaW5oZXJpdHMoQnViYmxlVG9vbHRpcCwgX0Jhc2VUb29sdGlwKTtcblxuICBmdW5jdGlvbiBCdWJibGVUb29sdGlwKHF1aWxsLCBib3VuZHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnViYmxlVG9vbHRpcCk7XG5cbiAgICB2YXIgX3RoaXMyID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJ1YmJsZVRvb2x0aXAuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCdWJibGVUb29sdGlwKSkuY2FsbCh0aGlzLCBxdWlsbCwgYm91bmRzKSk7XG5cbiAgICBfdGhpczIucXVpbGwub24oX2VtaXR0ZXIyLmRlZmF1bHQuZXZlbnRzLkVESVRPUl9DSEFOR0UsIGZ1bmN0aW9uICh0eXBlLCByYW5nZSwgb2xkUmFuZ2UsIHNvdXJjZSkge1xuICAgICAgaWYgKHR5cGUgIT09IF9lbWl0dGVyMi5kZWZhdWx0LmV2ZW50cy5TRUxFQ1RJT05fQ0hBTkdFKSByZXR1cm47XG4gICAgICBpZiAocmFuZ2UgIT0gbnVsbCAmJiByYW5nZS5sZW5ndGggPiAwICYmIHNvdXJjZSA9PT0gX2VtaXR0ZXIyLmRlZmF1bHQuc291cmNlcy5VU0VSKSB7XG4gICAgICAgIF90aGlzMi5zaG93KCk7XG4gICAgICAgIC8vIExvY2sgb3VyIHdpZHRoIHNvIHdlIHdpbGwgZXhwYW5kIGJleW9uZCBvdXIgb2Zmc2V0UGFyZW50IGJvdW5kYXJpZXNcbiAgICAgICAgX3RoaXMyLnJvb3Quc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICBfdGhpczIucm9vdC5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgICBfdGhpczIucm9vdC5zdHlsZS53aWR0aCA9IF90aGlzMi5yb290Lm9mZnNldFdpZHRoICsgJ3B4JztcbiAgICAgICAgdmFyIGxpbmVzID0gX3RoaXMyLnF1aWxsLmdldExpbmVzKHJhbmdlLmluZGV4LCByYW5nZS5sZW5ndGgpO1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgX3RoaXMyLnBvc2l0aW9uKF90aGlzMi5xdWlsbC5nZXRCb3VuZHMocmFuZ2UpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbGFzdExpbmUgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpczIucXVpbGwuZ2V0SW5kZXgobGFzdExpbmUpO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihsYXN0TGluZS5sZW5ndGgoKSAtIDEsIHJhbmdlLmluZGV4ICsgcmFuZ2UubGVuZ3RoIC0gaW5kZXgpO1xuICAgICAgICAgIHZhciBfYm91bmRzID0gX3RoaXMyLnF1aWxsLmdldEJvdW5kcyhuZXcgX3NlbGVjdGlvbi5SYW5nZShpbmRleCwgbGVuZ3RoKSk7XG4gICAgICAgICAgX3RoaXMyLnBvc2l0aW9uKF9ib3VuZHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IF90aGlzMi50ZXh0Ym94ICYmIF90aGlzMi5xdWlsbC5oYXNGb2N1cygpKSB7XG4gICAgICAgIF90aGlzMi5oaWRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdWJibGVUb29sdGlwLCBbe1xuICAgIGtleTogJ2xpc3RlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RlbigpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBfZ2V0KEJ1YmJsZVRvb2x0aXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnViYmxlVG9vbHRpcC5wcm90b3R5cGUpLCAnbGlzdGVuJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKCcucWwtY2xvc2UnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLnJvb3QuY2xhc3NMaXN0LnJlbW92ZSgncWwtZWRpdGluZycpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnF1aWxsLm9uKF9lbWl0dGVyMi5kZWZhdWx0LmV2ZW50cy5TQ1JPTExfT1BUSU1JWkUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTGV0IHNlbGVjdGlvbiBiZSByZXN0b3JlZCBieSB0b29sYmFyIGhhbmRsZXJzIGJlZm9yZSByZXBvc2l0aW9uaW5nXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpczMucm9vdC5jbGFzc0xpc3QuY29udGFpbnMoJ3FsLWhpZGRlbicpKSByZXR1cm47XG4gICAgICAgICAgdmFyIHJhbmdlID0gX3RoaXMzLnF1aWxsLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgIGlmIChyYW5nZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpczMucG9zaXRpb24oX3RoaXMzLnF1aWxsLmdldEJvdW5kcyhyYW5nZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYW5jZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uKHJlZmVyZW5jZSkge1xuICAgICAgdmFyIHNoaWZ0ID0gX2dldChCdWJibGVUb29sdGlwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJ1YmJsZVRvb2x0aXAucHJvdG90eXBlKSwgJ3Bvc2l0aW9uJywgdGhpcykuY2FsbCh0aGlzLCByZWZlcmVuY2UpO1xuICAgICAgdmFyIGFycm93ID0gdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3IoJy5xbC10b29sdGlwLWFycm93Jyk7XG4gICAgICBhcnJvdy5zdHlsZS5tYXJnaW5MZWZ0ID0gJyc7XG4gICAgICBpZiAoc2hpZnQgPT09IDApIHJldHVybiBzaGlmdDtcbiAgICAgIGFycm93LnN0eWxlLm1hcmdpbkxlZnQgPSAtMSAqIHNoaWZ0IC0gYXJyb3cub2Zmc2V0V2lkdGggLyAyICsgJ3B4JztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnViYmxlVG9vbHRpcDtcbn0oX2Jhc2UuQmFzZVRvb2x0aXApO1xuXG5CdWJibGVUb29sdGlwLlRFTVBMQVRFID0gWyc8c3BhbiBjbGFzcz1cInFsLXRvb2x0aXAtYXJyb3dcIj48L3NwYW4+JywgJzxkaXYgY2xhc3M9XCJxbC10b29sdGlwLWVkaXRvclwiPicsICc8aW5wdXQgdHlwZT1cInRleHRcIiBkYXRhLWZvcm11bGE9XCJlPW1jXjJcIiBkYXRhLWxpbms9XCJodHRwczovL3F1aWxsanMuY29tXCIgZGF0YS12aWRlbz1cIkVtYmVkIFVSTFwiPicsICc8YSBjbGFzcz1cInFsLWNsb3NlXCI+PC9hPicsICc8L2Rpdj4nXS5qb2luKCcnKTtcblxuZXhwb3J0cy5CdWJibGVUb29sdGlwID0gQnViYmxlVG9vbHRpcDtcbmV4cG9ydHMuZGVmYXVsdCA9IEJ1YmJsZVRoZW1lO1xuXG4vKioqLyB9KSxcbi8qIDEwOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKVtcImRlZmF1bHRcIl07XG59KTsiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJzZWxmIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsImQiLCJuYW1lIiwiZ2V0dGVyIiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsIm4iLCJfX2VzTW9kdWxlIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJ2YWx1ZSIsImNvbnRhaW5lcl8xIiwiZm9ybWF0XzEiLCJsZWFmXzEiLCJzY3JvbGxfMSIsImlubGluZV8xIiwiYmxvY2tfMSIsImVtYmVkXzEiLCJ0ZXh0XzEiLCJhdHRyaWJ1dG9yXzEiLCJjbGFzc18xIiwic3R5bGVfMSIsInN0b3JlXzEiLCJSZWdpc3RyeSIsIlBhcmNobWVudCIsIlNjb3BlIiwiY3JlYXRlIiwiZmluZCIsInF1ZXJ5IiwicmVnaXN0ZXIiLCJDb250YWluZXIiLCJkZWZhdWx0IiwiRm9ybWF0IiwiTGVhZiIsIkVtYmVkIiwiU2Nyb2xsIiwiQmxvY2siLCJJbmxpbmUiLCJUZXh0IiwiQXR0cmlidXRvciIsIkF0dHJpYnV0ZSIsIkNsYXNzIiwiU3R5bGUiLCJTdG9yZSIsIl9fZXh0ZW5kcyIsImV4dGVuZFN0YXRpY3MiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIkFycmF5IiwiYiIsIl9fIiwiY29uc3RydWN0b3IiLCJQYXJjaG1lbnRFcnJvciIsIl9zdXBlciIsIm1lc3NhZ2UiLCJfdGhpcyIsIkVycm9yIiwiYXR0cmlidXRlcyIsImNsYXNzZXMiLCJ0YWdzIiwidHlwZXMiLCJEQVRBX0tFWSIsImlucHV0IiwibWF0Y2giLCJCbG90Q2xhc3MiLCJub2RlIiwiTm9kZSIsIlRFWFRfTk9ERSIsImJ1YmJsZSIsImJsb3QiLCJwYXJlbnROb2RlIiwic2NvcGUiLCJBTlkiLCJMRVZFTCIsIkJMT0NLIiwiSU5MSU5FIiwiSFRNTEVsZW1lbnQiLCJuYW1lcyIsImdldEF0dHJpYnV0ZSIsInNwbGl0IiwidGFnTmFtZSIsIlRZUEUiLCJEZWZpbml0aW9ucyIsIl9pIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwibWFwIiwiRGVmaW5pdGlvbiIsImJsb3ROYW1lIiwiYXR0ck5hbWUiLCJrZXlOYW1lIiwiY2xhc3NOYW1lIiwiaXNBcnJheSIsInRvVXBwZXJDYXNlIiwidGFnTmFtZXMiLCJmb3JFYWNoIiwidGFnIiwiZGlmZiIsImVxdWFsIiwiZXh0ZW5kIiwib3AiLCJOVUxMX0NIQVJBQ1RFUiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIkRlbHRhIiwib3BzIiwiaW5zZXJ0IiwidGV4dCIsIm5ld09wIiwia2V5cyIsInB1c2giLCJyZXRhaW4iLCJpbmRleCIsImxhc3RPcCIsInVuc2hpZnQiLCJzcGxpY2UiLCJjaG9wIiwicG9wIiwiZmlsdGVyIiwicHJlZGljYXRlIiwicGFydGl0aW9uIiwicGFzc2VkIiwiZmFpbGVkIiwidGFyZ2V0IiwicmVkdWNlIiwiaW5pdGlhbCIsImNoYW5nZUxlbmd0aCIsImVsZW0iLCJkZWxldGUiLCJzbGljZSIsInN0YXJ0IiwiZW5kIiwiSW5maW5pdHkiLCJpdGVyIiwiaXRlcmF0b3IiLCJoYXNOZXh0IiwibmV4dE9wIiwibmV4dCIsImNvbXBvc2UiLCJvdGhlciIsInRoaXNJdGVyIiwib3RoZXJJdGVyIiwiZmlyc3RPdGhlciIsInBlZWsiLCJmaXJzdExlZnQiLCJwZWVrVHlwZSIsInBlZWtMZW5ndGgiLCJkZWx0YSIsIk1hdGgiLCJtaW4iLCJ0aGlzT3AiLCJvdGhlck9wIiwicmVzdCIsImNvbmNhdCIsInN0cmluZ3MiLCJwcmVwIiwiam9pbiIsImRpZmZSZXN1bHQiLCJjb21wb25lbnQiLCJvcExlbmd0aCIsIklOU0VSVCIsIkRFTEVURSIsIkVRVUFMIiwiZWFjaExpbmUiLCJuZXdsaW5lIiwibGluZSIsImluZGV4T2YiLCJ0cmFuc2Zvcm0iLCJwcmlvcml0eSIsInRyYW5zZm9ybVBvc2l0aW9uIiwib2Zmc2V0IiwibmV4dFR5cGUiLCJoYXNPd24iLCJ0b1N0ciIsInRvU3RyaW5nIiwiZ09QRCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImFyciIsImlzUGxhaW5PYmplY3QiLCJvYmoiLCJoYXNPd25Db25zdHJ1Y3RvciIsImhhc0lzUHJvdG90eXBlT2YiLCJrZXkiLCJzZXRQcm9wZXJ0eSIsIm9wdGlvbnMiLCJuZXdWYWx1ZSIsIndyaXRhYmxlIiwiZ2V0UHJvcGVydHkiLCJzcmMiLCJjb3B5IiwiY29weUlzQXJyYXkiLCJjbG9uZSIsImRlZXAiLCJCbG9ja0VtYmVkIiwiYnViYmxlRm9ybWF0cyIsInVuZGVmaW5lZCIsIl9jcmVhdGVDbGFzcyIsImRlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9nZXQiLCJyZWNlaXZlciIsIkZ1bmN0aW9uIiwiZGVzYyIsInBhcmVudCIsImdldFByb3RvdHlwZU9mIiwiX2V4dGVuZCIsIl9leHRlbmQyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9xdWlsbERlbHRhIiwiX3F1aWxsRGVsdGEyIiwiX3BhcmNobWVudCIsIl9wYXJjaG1lbnQyIiwiX2JyZWFrIiwiX2JyZWFrMiIsIl9pbmxpbmUiLCJfaW5saW5lMiIsIl90ZXh0IiwiX3RleHQyIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJUeXBlRXJyb3IiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIlJlZmVyZW5jZUVycm9yIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiTkVXTElORV9MRU5HVEgiLCJfUGFyY2htZW50JEVtYmVkIiwiYXBwbHkiLCJhdHRhY2giLCJkb21Ob2RlIiwiZm9ybWF0cyIsInZhbHVlcyIsImZvcm1hdCIsImF0dHJpYnV0ZSIsIkJMT0NLX0FUVFJJQlVURSIsImZvcm1hdEF0IiwiaW5zZXJ0QXQiLCJkZWYiLCJlbmRzV2l0aCIsImJsb2NrIiwiaW5zZXJ0QmVmb3JlIiwiQkxPQ0tfQkxPVCIsIl9QYXJjaG1lbnQkQmxvY2siLCJfdGhpczIiLCJjYWNoZSIsImRlc2NlbmRhbnRzIiwibGVhZiIsImRlbGV0ZUF0IiwibGluZXMiLCJzaGlmdCIsImNoaWxkcmVuIiwidGFpbCIsInJlZiIsImhlYWQiLCJyZW1vdmUiLCJtb3ZlQ2hpbGRyZW4iLCJvcHRpbWl6ZSIsImNvbnRleHQiLCJwYXRoIiwicmVtb3ZlQ2hpbGQiLCJjaGlsZCIsImZvcmNlIiwiZGVmYXVsdENoaWxkIiwiYWxsb3dlZENoaWxkcmVuIiwic3RhdGljcyIsIm92ZXJsb2FkIiwiZXhwYW5kQ29uZmlnIiwiX3R5cGVvZiIsIlN5bWJvbCIsIl9zbGljZWRUb0FycmF5Iiwic2xpY2VJdGVyYXRvciIsIl9hcnIiLCJfbiIsIl9kIiwiX2UiLCJfcyIsImRvbmUiLCJlcnIiLCJfZWRpdG9yIiwiX2VkaXRvcjIiLCJfZW1pdHRlcjMiLCJfZW1pdHRlcjQiLCJfbW9kdWxlIiwiX21vZHVsZTIiLCJfc2VsZWN0aW9uIiwiX3NlbGVjdGlvbjIiLCJfbG9nZ2VyIiwiX2xvZ2dlcjIiLCJfdGhlbWUiLCJfdGhlbWUyIiwiX2RlZmluZVByb3BlcnR5IiwiZGVidWciLCJRdWlsbCIsImxpbWl0IiwibGV2ZWwiLCJfX3F1aWxsIiwiX2ltcG9ydCIsImltcG9ydHMiLCJlcnJvciIsIm92ZXJ3cml0ZSIsIndhcm4iLCJzdGFydHNXaXRoIiwiY29udGFpbmVyIiwiaHRtbCIsImlubmVySFRNTCIsInRyaW0iLCJjbGFzc0xpc3QiLCJhZGQiLCJhZGRDb250YWluZXIiLCJzZXRBdHRyaWJ1dGUiLCJzY3JvbGxpbmdDb250YWluZXIiLCJlbWl0dGVyIiwic2Nyb2xsIiwid2hpdGVsaXN0IiwiZWRpdG9yIiwic2VsZWN0aW9uIiwidGhlbWUiLCJrZXlib2FyZCIsImFkZE1vZHVsZSIsImNsaXBib2FyZCIsImhpc3RvcnkiLCJpbml0Iiwib24iLCJldmVudHMiLCJFRElUT1JfQ0hBTkdFIiwidHlwZSIsIlRFWFRfQ0hBTkdFIiwidG9nZ2xlIiwiaXNCbGFuayIsIlNDUk9MTF9VUERBVEUiLCJzb3VyY2UiLCJtdXRhdGlvbnMiLCJyYW5nZSIsImxhc3RSYW5nZSIsIm1vZGlmeSIsInVwZGF0ZSIsImNvbnRlbnRzIiwiY29udmVydCIsInNldENvbnRlbnRzIiwiY2xlYXIiLCJwbGFjZWhvbGRlciIsInJlYWRPbmx5IiwiZGlzYWJsZSIsInJlZk5vZGUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJibHVyIiwic2V0UmFuZ2UiLCJkZWxldGVUZXh0IiwiX3RoaXMzIiwiX292ZXJsb2FkIiwiX292ZXJsb2FkMiIsImVuYWJsZSIsImVuYWJsZWQiLCJmb2N1cyIsInNjcm9sbFRvcCIsInNjcm9sbEludG9WaWV3IiwiX3RoaXM0Iiwic291cmNlcyIsIkFQSSIsImdldFNlbGVjdGlvbiIsImNoYW5nZSIsImZvcm1hdExpbmUiLCJmb3JtYXRUZXh0Iiwic2V0U2VsZWN0aW9uIiwiU0lMRU5UIiwiX3RoaXM1IiwiX292ZXJsb2FkMyIsIl9vdmVybG9hZDQiLCJfdGhpczYiLCJfb3ZlcmxvYWQ1IiwiX292ZXJsb2FkNiIsImdldEJvdW5kcyIsImJvdW5kcyIsImNvbnRhaW5lckJvdW5kcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJvdHRvbSIsInRvcCIsImhlaWdodCIsImxlZnQiLCJyaWdodCIsIndpZHRoIiwiZ2V0Q29udGVudHMiLCJnZXRMZW5ndGgiLCJfb3ZlcmxvYWQ3IiwiX292ZXJsb2FkOCIsImdldEZvcm1hdCIsImdldEluZGV4IiwiZ2V0TGVhZiIsImdldExpbmUiLCJnZXRMaW5lcyIsIk51bWJlciIsIk1BWF9WQUxVRSIsImdldE1vZHVsZSIsImdldFJhbmdlIiwiZ2V0VGV4dCIsIl9vdmVybG9hZDkiLCJfb3ZlcmxvYWQxMCIsImhhc0ZvY3VzIiwiaW5zZXJ0RW1iZWQiLCJlbWJlZCIsIl90aGlzNyIsImluc2VydFRleHQiLCJfdGhpczgiLCJfb3ZlcmxvYWQxMSIsIl9vdmVybG9hZDEyIiwiaXNFbmFibGVkIiwiY29udGFpbnMiLCJvZmYiLCJvbmNlIiwicGFzdGVIVE1MIiwiZGFuZ2Vyb3VzbHlQYXN0ZUhUTUwiLCJyZW1vdmVGb3JtYXQiLCJfdGhpczkiLCJfb3ZlcmxvYWQxMyIsIl9vdmVybG9hZDE0IiwiX3RoaXMxMCIsImRlbGV0ZWQiLCJhcHBsaWVkIiwiYXBwbHlEZWx0YSIsInJldCIsIl9vdmVybG9hZDE1IiwiX292ZXJsb2FkMTYiLCJSYW5nZSIsInNldFRleHQiLCJVU0VSIiwidXBkYXRlQ29udGVudHMiLCJfdGhpczExIiwiREVGQVVMVFMiLCJzdHJpY3QiLCJ2ZXJzaW9uIiwidXNlckNvbmZpZyIsImltcG9ydCIsInRoZW1lQ29uZmlnIiwiY29uZmlnIiwibW9kdWxlTmFtZXMiLCJtb2R1bGVDb25maWciLCJtb2R1bGVDbGFzcyIsInRvb2xiYXIiLCJxdWVyeVNlbGVjdG9yIiwibW9kaWZpZXIiLCJvbGREZWx0YSIsInNoaWZ0UmFuZ2UiLCJfZW1pdHRlciIsImFyZ3MiLCJlbWl0IiwiX2VtaXR0ZXIyIiwiX21hcCIsInBvcyIsIl9tYXAyIiwiX21hcDMiLCJtYXgiLCJfbWFwNCIsIl9QYXJjaG1lbnQkSW5saW5lIiwiY29tcGFyZSIsIkJMT1QiLCJpc29sYXRlIiwid3JhcCIsInNlbGZJbmRleCIsIm9yZGVyIiwib3RoZXJJbmRleCIsIlRleHRCbG90IiwiX1BhcmNobWVudCRUZXh0IiwiX2V2ZW50ZW1pdHRlciIsIl9ldmVudGVtaXR0ZXIyIiwiRVZFTlRTIiwiZXZlbnROYW1lIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9sZW4iLCJfa2V5IiwicXVlcnlTZWxlY3RvckFsbCIsIl9ub2RlJF9fcXVpbGwkZW1pdHRlciIsImhhbmRsZURPTSIsIkVtaXR0ZXIiLCJfRXZlbnRFbWl0dGVyIiwibGlzdGVuZXJzIiwibG9nIiwiZXZlbnQiLCJfbGVuMiIsIl9rZXkyIiwiX3JlZiIsImhhbmRsZXIiLCJsaXN0ZW5ET00iLCJTQ1JPTExfQkVGT1JFX1VQREFURSIsIlNDUk9MTF9PUFRJTUlaRSIsIlNFTEVDVElPTl9DSEFOR0UiLCJNb2R1bGUiLCJxdWlsbCIsImxldmVscyIsIm1ldGhvZCIsIl9jb25zb2xlIiwiY29uc29sZSIsIm5hbWVzcGFjZSIsIm5zIiwibG9nZ2VyIiwiYmluZCIsIm5ld0xldmVsIiwicFNsaWNlIiwib2JqZWN0S2V5cyIsImlzQXJndW1lbnRzIiwiZGVlcEVxdWFsIiwiYWN0dWFsIiwiZXhwZWN0ZWQiLCJvcHRzIiwiRGF0ZSIsImdldFRpbWUiLCJvYmpFcXVpdiIsImlzVW5kZWZpbmVkT3JOdWxsIiwiaXNCdWZmZXIiLCJ4IiwiYSIsImthIiwia2IiLCJlIiwic29ydCIsImF0dHJpYnV0ZUJpdCIsIkFUVFJJQlVURSIsIml0ZW0iLCJjYW5BZGQiLCJyZXBsYWNlIiwicmVtb3ZlQXR0cmlidXRlIiwiQ29kZSIsIl9ibG9jayIsIl9ibG9jazIiLCJfSW5saW5lIiwiQ29kZUJsb2NrIiwiX0Jsb2NrIiwidGV4dENvbnRlbnQiLCJmcmFnIiwiX2Rlc2NlbmRhbnQiLCJkZXNjZW5kYW50IiwiX2Rlc2NlbmRhbnQyIiwibmV4dE5ld2xpbmUiLCJuZXdsaW5lSW5kZXgiLCJwcmV2TmV3bGluZSIsImlzb2xhdGVMZW5ndGgiLCJfZGVzY2VuZGFudDMiLCJfZGVzY2VuZGFudDQiLCJzZWFyY2hJbmRleCIsInJldmVyc2UiLCJsYXN0SW5kZXhPZiIsImFwcGVuZENoaWxkIiwicHJldiIsInVud3JhcCIsIlRBQiIsIl9vcCIsIl9vcDIiLCJfY29kZSIsIl9jb2RlMiIsIl9jdXJzb3IiLCJfY3Vyc29yMiIsIl9jbG9uZSIsIl9jbG9uZTIiLCJfZGVlcEVxdWFsIiwiX2RlZXBFcXVhbDIiLCJBU0NJSSIsIkVkaXRvciIsImdldERlbHRhIiwiY29uc3VtZU5leHROZXdsaW5lIiwic2Nyb2xsTGVuZ3RoIiwiYmF0Y2hTdGFydCIsIm5vcm1hbGl6ZURlbHRhIiwiX3Njcm9sbCRsaW5lIiwiX3Njcm9sbCRsaW5lMiIsIl9saW5lJGRlc2NlbmRhbnQiLCJfbGluZSRkZXNjZW5kYW50MiIsImJhdGNoRW5kIiwibGVuZ3RoUmVtYWluaW5nIiwibGluZUxlbmd0aCIsImNvZGVJbmRleCIsImNvZGVMZW5ndGgiLCJsZWF2ZXMiLCJfcGF0aCIsImZvcm1hdHNBcnIiLCJibG90cyIsImNvbWJpbmVGb3JtYXRzIiwiX3Njcm9sbCRsaW5lMyIsIl9zY3JvbGwkbGluZTQiLCJzdWZmaXhMZW5ndGgiLCJzdWZmaXgiLCJjdXJzb3JJbmRleCIsImRhdGEiLCJ0ZXh0QmxvdCIsIm9sZFZhbHVlIiwiQ09OVEVOVFMiLCJvbGRUZXh0IiwibmV3VGV4dCIsImRpZmZEZWx0YSIsImNvbWJpbmVkIiwibWVyZ2VkIiwiaW1hZ2UiLCJsaXN0IiwiYnVsbGV0IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXJyMiIsImZyb20iLCJTZWxlY3Rpb24iLCJjb21wb3NpbmciLCJtb3VzZURvd24iLCJjdXJzb3IiLCJzYXZlZFJhbmdlIiwiaGFuZGxlQ29tcG9zaXRpb24iLCJoYW5kbGVEcmFnZ2luZyIsInNldFRpbWVvdXQiLCJuYXRpdmUiLCJnZXROYXRpdmVSYW5nZSIsInRleHROb2RlIiwic2V0TmF0aXZlUmFuZ2UiLCJpZ25vcmVkIiwiX2NvbnRleHQkcmFuZ2UiLCJzdGFydE5vZGUiLCJzdGFydE9mZnNldCIsImVuZE5vZGUiLCJlbmRPZmZzZXQiLCJyZXN0b3JlIiwiYm9keSIsIl9mb3JtYXQiLCJuYXRpdmVSYW5nZSIsImNvbGxhcHNlZCIsImFmdGVyIiwiX3Njcm9sbCRsZWFmIiwiX3Njcm9sbCRsZWFmMiIsIl9sZWFmJHBvc2l0aW9uIiwicG9zaXRpb24iLCJfbGVhZiRwb3NpdGlvbjIiLCJjcmVhdGVSYW5nZSIsInNldFN0YXJ0IiwiX3Njcm9sbCRsZWFmMyIsIl9zY3JvbGwkbGVhZjQiLCJfbGVhZiRwb3NpdGlvbjMiLCJfbGVhZiRwb3NpdGlvbjQiLCJzZXRFbmQiLCJzaWRlIiwicmVjdCIsInJhbmdlQ291bnQiLCJnZXRSYW5nZUF0Iiwibm9ybWFsaXplTmF0aXZlIiwiaW5mbyIsIm5vcm1hbGl6ZWQiLCJub3JtYWxpemVkVG9SYW5nZSIsImFjdGl2ZUVsZW1lbnQiLCJwb3NpdGlvbnMiLCJpbmRleGVzIiwiX3Bvc2l0aW9uIiwic3RhcnRDb250YWluZXIiLCJlbmRDb250YWluZXIiLCJjaGlsZE5vZGVzIiwibGFzdENoaWxkIiwicmFuZ2VUb05hdGl2ZSIsIl9zY3JvbGwkbGVhZjUiLCJfc2Nyb2xsJGxlYWY2IiwiX2xlYWYkcG9zaXRpb241IiwiX2xlYWYkcG9zaXRpb242IiwiZmlyc3QiLCJsYXN0Iiwic2Nyb2xsQm91bmRzIiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJvbGRSYW5nZSIsIl9nZXRSYW5nZSIsIl9nZXRSYW5nZTIiLCJCcmVhayIsImluc2VydEludG8iLCJsaW5rZWRfbGlzdF8xIiwic2hhZG93XzEiLCJDb250YWluZXJCbG90IiwiYnVpbGQiLCJtYWtlQmxvdCIsImZvckVhY2hBdCIsImNyaXRlcmlhIiwiX2EiLCJsZW5ndGhMZWZ0IiwiZGV0YWNoIiwiY2hpbGRCbG90IiwicmVmQmxvdCIsInNvbWUiLCJtZW1vIiwidGFyZ2V0UGFyZW50IiwiaW5jbHVzaXZlIiwiYWRkZWROb2RlcyIsInJlbW92ZWROb2RlcyIsIm11dGF0aW9uIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkiLCJET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkciLCJuZXh0U2libGluZyIsInJlcGxhY2VDaGlsZCIsIkZvcm1hdEJsb3QiLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2VXaXRoIiwicmVwbGFjZW1lbnQiLCJ3cmFwcGVyIiwibW92ZSIsIkxlYWZCbG90IiwiSU5MSU5FX0JMT1QiLCJsaWIiLCJrZWVwTnVsbCIsIkl0ZXJhdG9yIiwicmV0T3AiLCJzdWJzdHIiLCJfaW5zdGFuY2VvZiIsIm5hdGl2ZU1hcCIsIk1hcCIsIl8iLCJuYXRpdmVTZXQiLCJTZXQiLCJuYXRpdmVQcm9taXNlIiwiUHJvbWlzZSIsImNpcmN1bGFyIiwiZGVwdGgiLCJpbmNsdWRlTm9uRW51bWVyYWJsZSIsImFsbFBhcmVudHMiLCJhbGxDaGlsZHJlbiIsInVzZUJ1ZmZlciIsIkJ1ZmZlciIsInByb3RvIiwicmVzb2x2ZSIsInJlamVjdCIsInRoZW4iLCJfX2lzQXJyYXkiLCJfX2lzUmVnRXhwIiwiUmVnRXhwIiwiX19nZXRSZWdFeHBGbGFncyIsImxhc3RJbmRleCIsIl9faXNEYXRlIiwiYWxsb2NVbnNhZmUiLCJrZXlDaGlsZCIsInZhbHVlQ2hpbGQiLCJzZXQiLCJlbnRyeUNoaWxkIiwiYXR0cnMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwic3ltYm9sIiwiYWxsUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0eU5hbWUiLCJjbG9uZVByb3RvdHlwZSIsIl9fb2JqVG9TdHIiLCJyZSIsImZsYWdzIiwiZ2xvYmFsIiwiaWdub3JlQ2FzZSIsIm11bHRpbGluZSIsIl9jb250YWluZXIiLCJfY29udGFpbmVyMiIsImlzTGluZSIsIl9QYXJjaG1lbnQkU2Nyb2xsIiwiYmF0Y2giLCJfbGluZSIsIl9saW5lMiIsIl9saW5lMyIsIl9saW5lNCIsIl9uZXdsaW5lSW5kZXgiLCJvYnNlcnZlciIsInRha2VSZWNvcmRzIiwiU0hPUlRLRVkiLCJfcXVpbGwiLCJfcXVpbGwyIiwidGVzdCIsIm5hdmlnYXRvciIsInBsYXRmb3JtIiwiS2V5Ym9hcmQiLCJfTW9kdWxlIiwiZXZ0IiwiYmluZGluZyIsIm5vcm1hbGl6ZSIsIndoaWNoIiwia2V5Q29kZSIsImJpbmRpbmdzIiwiYWRkQmluZGluZyIsIkVOVEVSIiwic2hpZnRLZXkiLCJoYW5kbGVFbnRlciIsIm1ldGFLZXkiLCJjdHJsS2V5IiwiYWx0S2V5IiwidXNlckFnZW50IiwiQkFDS1NQQUNFIiwiaGFuZGxlQmFja3NwYWNlIiwiaGFuZGxlRGVsZXRlIiwicHJlZml4IiwiaGFuZGxlRGVsZXRlUmFuZ2UiLCJsaXN0ZW4iLCJkZWZhdWx0UHJldmVudGVkIiwiX3F1aWxsJGdldExpbmUiLCJfcXVpbGwkZ2V0TGluZTIiLCJfcXVpbGwkZ2V0TGVhZiIsIl9xdWlsbCRnZXRMZWFmMiIsImxlYWZTdGFydCIsIm9mZnNldFN0YXJ0IiwiX3JlZjIiLCJsZWFmRW5kIiwib2Zmc2V0RW5kIiwicHJlZml4VGV4dCIsInN1ZmZpeFRleHQiLCJjdXJDb250ZXh0IiwiZW1wdHkiLCJwcmV2ZW50ZWQiLCJldmVyeSIsInByZXZlbnREZWZhdWx0IiwiRVNDQVBFIiwiTEVGVCIsIlVQIiwiUklHSFQiLCJET1dOIiwibWFrZUZvcm1hdEhhbmRsZXIiLCJpbmRlbnQiLCJtYWtlQ29kZUJsb2NrSGFuZGxlciIsImN1dG9mZiIsIl9xdWlsbCRnZXRMaW5lMyIsIl9xdWlsbCRnZXRMaW5lNCIsIl9xdWlsbCRnZXRMaW5lNSIsIl9xdWlsbCRnZXRMaW5lNiIsImhlYWRlciIsIl9xdWlsbCRnZXRMaW5lNyIsIl9xdWlsbCRnZXRMaW5lOCIsIl9xdWlsbCRnZXRMaW5lOSIsIl9xdWlsbCRnZXRMaW5lMTAiLCJtYWtlRW1iZWRBcnJvd0hhbmRsZXIiLCJfcmVmMyIsIndoZXJlIiwiX3F1aWxsJGdldExlYWYzIiwiX3F1aWxsJGdldExlYWY0IiwiX3F1aWxsJGdldExpbmUxMSIsIl9xdWlsbCRnZXRMaW5lMTIiLCJfcXVpbGwkZ2V0TGluZTEzIiwiX3F1aWxsJGdldExpbmUxNCIsImN1ckZvcm1hdHMiLCJwcmV2Rm9ybWF0cyIsIm5leHRMZW5ndGgiLCJfcXVpbGwkZ2V0TGluZTE1IiwiX3F1aWxsJGdldExpbmUxNiIsIl9xdWlsbCRnZXRMaW5lMTciLCJfcXVpbGwkZ2V0TGluZTE4IiwibmV4dEZvcm1hdHMiLCJmaXJzdEZvcm1hdHMiLCJsYXN0Rm9ybWF0cyIsImxpbmVGb3JtYXRzIiwiX3F1aWxsJHNjcm9sbCRkZXNjZW5kIiwiX3F1aWxsJHNjcm9sbCRkZXNjZW5kMiIsInNjcm9sbEluZGV4Iiwic2hvcnRLZXkiLCJjaGFyQ29kZUF0IiwiQ3Vyc29yIiwiY3JlYXRlVGV4dE5vZGUiLCJfbGVuZ3RoIiwicmVzdG9yZVRleHQiLCJfUGFyY2htZW50JENvbnRhaW5lciIsIkNvbG9yU3R5bGUiLCJDb2xvckNsYXNzIiwiQ29sb3JBdHRyaWJ1dG9yIiwiX1BhcmNobWVudCRBdHRyaWJ1dG9yIiwicGFyc2VJbnQiLCJzYW5pdGl6ZSIsIkxpbmsiLCJ1cmwiLCJfc2FuaXRpemUiLCJQUk9UT0NPTF9XSElURUxJU1QiLCJTQU5JVElaRURfVVJMIiwicHJvdG9jb2xzIiwiYW5jaG9yIiwiaHJlZiIsInByb3RvY29sIiwiX2tleWJvYXJkIiwiX2tleWJvYXJkMiIsIl9kcm9wZG93biIsIl9kcm9wZG93bjIiLCJvcHRpb25zQ291bnRlciIsInRvZ2dsZUFyaWFBdHRyaWJ1dGUiLCJlbGVtZW50IiwiUGlja2VyIiwic2VsZWN0IiwiYnVpbGRQaWNrZXIiLCJzdHlsZSIsImRpc3BsYXkiLCJsYWJlbCIsInRvZ2dsZVBpY2tlciIsImVzY2FwZSIsImJ1aWxkSXRlbSIsIm9wdGlvbiIsInRhYkluZGV4IiwiaGFzQXR0cmlidXRlIiwic2VsZWN0SXRlbSIsImJ1aWxkTGFiZWwiLCJidWlsZE9wdGlvbnMiLCJpZCIsInNlbGVjdGVkIiwiY2xvc2UiLCJ0cmlnZ2VyIiwic2VsZWN0ZWRJbmRleCIsIkV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiaXNBY3RpdmUiLCJfZW1iZWQiLCJfZW1iZWQyIiwiX3Njcm9sbCIsIl9zY3JvbGwyIiwiX2NsaXBib2FyZCIsIl9jbGlwYm9hcmQyIiwiX2hpc3RvcnkiLCJfaGlzdG9yeTIiLCJTaGFkb3dCbG90IiwiY2xvbmVOb2RlIiwicGFyZW50QmxvdCIsInJlZkRvbU5vZGUiLCJBdHRyaWJ1dG9yU3RvcmUiLCJzdHlsZXMiLCJhdHRyIiwiQ2xhc3NBdHRyaWJ1dG9yIiwibWF0Y2hlcyIsInJlc3VsdCIsImNhbWVsaXplIiwicGFydHMiLCJwYXJ0IiwiU3R5bGVBdHRyaWJ1dG9yIiwiVGhlbWUiLCJ0aGVtZXMiLCJHVUFSRF9URVhUIiwiY29udGVudE5vZGUiLCJjaGlsZE5vZGUiLCJsZWZ0R3VhcmQiLCJyaWdodEd1YXJkIiwicHJldkxlbmd0aCIsIkFsaWduU3R5bGUiLCJBbGlnbkNsYXNzIiwiQWxpZ25BdHRyaWJ1dGUiLCJCYWNrZ3JvdW5kU3R5bGUiLCJCYWNrZ3JvdW5kQ2xhc3MiLCJfY29sb3IiLCJEaXJlY3Rpb25TdHlsZSIsIkRpcmVjdGlvbkNsYXNzIiwiRGlyZWN0aW9uQXR0cmlidXRlIiwiRm9udENsYXNzIiwiRm9udFN0eWxlIiwiRm9udFN0eWxlQXR0cmlidXRvciIsIlNpemVTdHlsZSIsIlNpemVDbGFzcyIsImdldExhc3RDaGFuZ2VJbmRleCIsIkhpc3RvcnkiLCJsYXN0UmVjb3JkZWQiLCJpZ25vcmVDaGFuZ2UiLCJ1c2VyT25seSIsInJlY29yZCIsInVuZG8iLCJyZWRvIiwiZGVzdCIsInN0YWNrIiwiY2hhbmdlRGVsdGEiLCJ1bmRvRGVsdGEiLCJ0aW1lc3RhbXAiLCJub3ciLCJkZWxheSIsIm1heFN0YWNrIiwiZW5kc1dpdGhOZXdsaW5lQ2hhbmdlIiwiZGVsZXRlTGVuZ3RoIiwiY2hhbmdlSW5kZXgiLCJCYXNlVG9vbHRpcCIsIl9jb2xvclBpY2tlciIsIl9jb2xvclBpY2tlcjIiLCJfaWNvblBpY2tlciIsIl9pY29uUGlja2VyMiIsIl9waWNrZXIiLCJfcGlja2VyMiIsIl90b29sdGlwIiwiX3Rvb2x0aXAyIiwiQUxJR05TIiwiQ09MT1JTIiwiRk9OVFMiLCJIRUFERVJTIiwiU0laRVMiLCJCYXNlVGhlbWUiLCJfVGhlbWUiLCJsaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0b29sdGlwIiwidGV4dGJveCIsImhpZGUiLCJwaWNrZXJzIiwicGlja2VyIiwiZXh0ZW5kVG9vbGJhciIsImJ1aWxkQnV0dG9ucyIsImJ1dHRvbnMiLCJpY29ucyIsImJ1dHRvbiIsImJ1aWxkUGlja2VycyIsInNlbGVjdHMiLCJmaWxsU2VsZWN0IiwiYWxpZ24iLCJoYW5kbGVycyIsImZvcm11bGEiLCJlZGl0IiwiZmlsZUlucHV0IiwiZmlsZXMiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwicmVhZEFzRGF0YVVSTCIsImNsaWNrIiwidmlkZW8iLCJfVG9vbHRpcCIsImJvdW5kc0NvbnRhaW5lciIsInNhdmUiLCJjYW5jZWwiLCJtb2RlIiwicHJldmlldyIsInJlc3RvcmVGb2N1cyIsImxpbmtSYW5nZSIsImV4dHJhY3RWaWRlb1VybCIsImRlZmF1bHRWYWx1ZSIsIkxpbmtlZExpc3QiLCJhcHBlbmQiLCJub2RlcyIsImN1ciIsImN1ck5vZGUiLCJjYWxsYmFjayIsImN1ckluZGV4IiwiY3VyTGVuZ3RoIiwiT0JTRVJWRVJfQ09ORklHIiwiY2hhcmFjdGVyRGF0YSIsImNoYXJhY3RlckRhdGFPbGRWYWx1ZSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJNQVhfT1BUSU1JWkVfSVRFUkFUSU9OUyIsIlNjcm9sbEJsb3QiLCJNdXRhdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJyZWNvcmRzIiwibWFyayIsIm1hcmtQYXJlbnQiLCJyZW1haW5pbmciLCJwcmV2aW91c1NpYmxpbmciLCJncmFuZENoaWxkIiwiaXNFcXVhbCIsIm9iajEiLCJvYmoyIiwicHJvcCIsIklubGluZUJsb3QiLCJCbG9ja0Jsb3QiLCJFbWJlZEJsb3QiLCJzcGxpdFRleHQiLCJfdG9nZ2xlIiwiRE9NVG9rZW5MaXN0IiwidG9rZW4iLCJzZWFyY2hTdHJpbmciLCJzdWJqZWN0U3RyaW5nIiwiaXNGaW5pdGUiLCJmbG9vciIsInRoaXNBcmciLCJleGVjQ29tbWFuZCIsIkRJRkZfREVMRVRFIiwiRElGRl9JTlNFUlQiLCJESUZGX0VRVUFMIiwiZGlmZl9tYWluIiwidGV4dDEiLCJ0ZXh0MiIsImN1cnNvcl9wb3MiLCJjb21tb25sZW5ndGgiLCJkaWZmX2NvbW1vblByZWZpeCIsImNvbW1vbnByZWZpeCIsInN1YnN0cmluZyIsImRpZmZfY29tbW9uU3VmZml4IiwiY29tbW9uc3VmZml4IiwiZGlmZnMiLCJkaWZmX2NvbXB1dGVfIiwiZGlmZl9jbGVhbnVwTWVyZ2UiLCJmaXhfY3Vyc29yIiwiZml4X2Vtb2ppIiwibG9uZ3RleHQiLCJzaG9ydHRleHQiLCJobSIsImRpZmZfaGFsZk1hdGNoXyIsInRleHQxX2EiLCJ0ZXh0MV9iIiwidGV4dDJfYSIsInRleHQyX2IiLCJtaWRfY29tbW9uIiwiZGlmZnNfYSIsImRpZmZzX2IiLCJkaWZmX2Jpc2VjdF8iLCJ0ZXh0MV9sZW5ndGgiLCJ0ZXh0Ml9sZW5ndGgiLCJtYXhfZCIsImNlaWwiLCJ2X29mZnNldCIsInZfbGVuZ3RoIiwidjEiLCJ2MiIsImZyb250IiwiazFzdGFydCIsImsxZW5kIiwiazJzdGFydCIsImsyZW5kIiwiazEiLCJrMV9vZmZzZXQiLCJ4MSIsInkxIiwiY2hhckF0IiwiazJfb2Zmc2V0IiwieDIiLCJkaWZmX2Jpc2VjdFNwbGl0XyIsImsyIiwieTIiLCJ5IiwidGV4dDFhIiwidGV4dDJhIiwidGV4dDFiIiwidGV4dDJiIiwiZGlmZnNiIiwicG9pbnRlcm1pbiIsInBvaW50ZXJtYXgiLCJwb2ludGVybWlkIiwicG9pbnRlcnN0YXJ0IiwicG9pbnRlcmVuZCIsImRpZmZfaGFsZk1hdGNoSV8iLCJzZWVkIiwiaiIsImJlc3RfY29tbW9uIiwiYmVzdF9sb25ndGV4dF9hIiwiYmVzdF9sb25ndGV4dF9iIiwiYmVzdF9zaG9ydHRleHRfYSIsImJlc3Rfc2hvcnR0ZXh0X2IiLCJwcmVmaXhMZW5ndGgiLCJobTEiLCJobTIiLCJwb2ludGVyIiwiY291bnRfZGVsZXRlIiwiY291bnRfaW5zZXJ0IiwidGV4dF9kZWxldGUiLCJ0ZXh0X2luc2VydCIsImNoYW5nZXMiLCJjdXJzb3Jfbm9ybWFsaXplX2RpZmYiLCJjdXJyZW50X3BvcyIsIm5leHRfcG9zIiwic3BsaXRfcG9zIiwiZF9sZWZ0IiwiZF9yaWdodCIsIm5vcm0iLCJuZGlmZnMiLCJjdXJzb3JfcG9pbnRlciIsImRfbmV4dCIsIm1lcmdlX3R1cGxlcyIsImNvbXBhY3QiLCJzdGFydHNfd2l0aF9wYWlyX2VuZCIsInN0ciIsImVuZHNfd2l0aF9wYWlyX3N0YXJ0IiwiZml4ZWRfZGlmZnMiLCJsZWZ0X2QiLCJyaWdodF9kIiwic2hpbSIsInN1cHBvcnRzQXJndW1lbnRzQ2xhc3MiLCJzdXBwb3J0ZWQiLCJ1bnN1cHBvcnRlZCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaGFzIiwiRXZlbnRzIiwiRUUiLCJmbiIsIkV2ZW50RW1pdHRlciIsIl9ldmVudHMiLCJfZXZlbnRzQ291bnQiLCJldmVudE5hbWVzIiwiZXhpc3RzIiwiYXZhaWxhYmxlIiwiZWUiLCJhMSIsImEyIiwiYTMiLCJhNCIsImE1IiwibGVuIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJhZGRMaXN0ZW5lciIsInNldE1heExpc3RlbmVycyIsInByZWZpeGVkIiwibWF0Y2hUZXh0IiwibWF0Y2hTcGFjaW5nIiwibWF0Y2hOZXdsaW5lIiwibWF0Y2hCbG90IiwibWF0Y2hBdHRyaWJ1dG9yIiwiX2V4dGVuZDMiLCJfYWxpZ24iLCJfYmFja2dyb3VuZCIsIl9kaXJlY3Rpb24iLCJfZm9udCIsIl9zaXplIiwiRE9NX0tFWSIsIkNMSVBCT0FSRF9DT05GSUciLCJtYXRjaEJyZWFrIiwiRUxFTUVOVF9OT0RFIiwibWF0Y2hTdHlsZXMiLCJtYXRjaEluZGVudCIsIm1hdGNoQWxpYXMiLCJtYXRjaElnbm9yZSIsIkFUVFJJQlVURV9BVFRSSUJVVE9SUyIsIlNUWUxFX0FUVFJJQlVUT1JTIiwiQ2xpcGJvYXJkIiwib25QYXN0ZSIsIm1hdGNoZXJzIiwic2VsZWN0b3IiLCJtYXRjaGVyIiwibWF0Y2hWaXN1YWwiLCJhZGRNYXRjaGVyIiwiaW5uZXJUZXh0IiwiX3ByZXBhcmVNYXRjaGluZyIsInByZXBhcmVNYXRjaGluZyIsIl9wcmVwYXJlTWF0Y2hpbmcyIiwiZWxlbWVudE1hdGNoZXJzIiwidGV4dE1hdGNoZXJzIiwidHJhdmVyc2UiLCJkZWx0YUVuZHNXaXRoIiwicGFzdGUiLCJwYWlyIiwiX3BhaXIiLCJhcHBseUZvcm1hdCIsImNvbXB1dGVTdHlsZSIsIm5vZGVUeXBlIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImVuZFRleHQiLCJjaGlsZHJlbkRlbHRhIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwibm9kZUhlaWdodCIsIm9mZnNldEhlaWdodCIsInBhcnNlRmxvYXQiLCJtYXJnaW5Ub3AiLCJtYXJnaW5Cb3R0b20iLCJvZmZzZXRUb3AiLCJmb250U3R5bGUiLCJpdGFsaWMiLCJmb250V2VpZ2h0IiwiYm9sZCIsInRleHRJbmRlbnQiLCJ3aGl0ZVNwYWNlIiwicmVwbGFjZXIiLCJjb2xsYXBzZSIsIkJvbGQiLCJhZGRDb250cm9scyIsIlRvb2xiYXIiLCJfcmV0IiwiY29udHJvbHMiLCJhZGRIYW5kbGVyIiwiX3RoaXMkcXVpbGwkc2VsZWN0aW9uIiwiX3RoaXMkcXVpbGwkc2VsZWN0aW9uMiIsIl9xdWlsbCRzZWxlY3Rpb24kZ2V0UiIsIl9xdWlsbCRzZWxlY3Rpb24kZ2V0UjIiLCJwcm9tcHQiLCJhZGRCdXR0b24iLCJncm91cHMiLCJncm91cCIsImNvbnRyb2wiLCJhZGRTZWxlY3QiLCJjbGVhbiIsImRpcmVjdGlvbiIsImxpbmsiLCJDb2xvclBpY2tlciIsIl9QaWNrZXIiLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2xvckxhYmVsIiwic3Ryb2tlIiwiZmlsbCIsIkljb25QaWNrZXIiLCJkZWZhdWx0SXRlbSIsIlRvb2x0aXAiLCJURU1QTEFURSIsInJlZmVyZW5jZSIsIm9mZnNldFdpZHRoIiwicm9vdEJvdW5kcyIsInZlcnRpY2FsU2hpZnQiLCJzaG93IiwiX2Jhc2UiLCJfYmFzZTIiLCJfbGluayIsIl9saW5rMiIsIl9pY29ucyIsIl9pY29uczIiLCJUT09MQkFSX0NPTkZJRyIsIlNub3dUaGVtZSIsIl9CYXNlVGhlbWUiLCJTbm93VG9vbHRpcCIsIl9CYXNlVG9vbHRpcCIsIl9jb3JlIiwiX2NvcmUyIiwiX2luZGVudCIsIl9ibG9ja3F1b3RlIiwiX2Jsb2NrcXVvdGUyIiwiX2hlYWRlciIsIl9oZWFkZXIyIiwiX2xpc3QiLCJfbGlzdDIiLCJfYm9sZCIsIl9ib2xkMiIsIl9pdGFsaWMiLCJfaXRhbGljMiIsIl9zY3JpcHQiLCJfc2NyaXB0MiIsIl9zdHJpa2UiLCJfc3RyaWtlMiIsIl91bmRlcmxpbmUiLCJfdW5kZXJsaW5lMiIsIl9pbWFnZSIsIl9pbWFnZTIiLCJfdmlkZW8iLCJfdmlkZW8yIiwiX2Zvcm11bGEiLCJfZm9ybXVsYTIiLCJfc3ludGF4IiwiX3N5bnRheDIiLCJfdG9vbGJhciIsIl90b29sYmFyMiIsIl9idWJibGUiLCJfYnViYmxlMiIsIl9zbm93IiwiX3Nub3cyIiwiSW5kZW50Q2xhc3MiLCJMaXN0SXRlbSIsIklkZW50QXR0cmlidXRvciIsIkJsb2NrcXVvdGUiLCJIZWFkZXIiLCJMaXN0IiwiX0NvbnRhaW5lciIsImxpc3RFdmVudEhhbmRsZXIiLCJJdGFsaWMiLCJfQm9sZCIsIlNjcmlwdCIsIlN0cmlrZSIsIlVuZGVybGluZSIsIkFUVFJJQlVURVMiLCJJbWFnZSIsIlZpZGVvIiwiX0Jsb2NrRW1iZWQiLCJGb3JtdWxhQmxvdCIsIl9FbWJlZCIsImthdGV4IiwicmVuZGVyIiwidGhyb3dPbkVycm9yIiwiZXJyb3JDb2xvciIsIkZvcm11bGEiLCJDb2RlVG9rZW4iLCJTeW50YXhDb2RlQmxvY2siLCJfQ29kZUJsb2NrIiwiaGlnaGxpZ2h0IiwiX2hpZ2hsaWdodCIsImNhY2hlZFRleHQiLCJTeW50YXgiLCJ0aW1lciIsImNsZWFyVGltZW91dCIsImludGVydmFsIiwiY29kZSIsImhsanMiLCJoaWdobGlnaHRBdXRvIiwiQnViYmxlVG9vbHRpcCIsIkJ1YmJsZVRoZW1lIiwibGFzdExpbmUiLCJfYm91bmRzIiwiYXJyb3ciLCJtYXJnaW5MZWZ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/quill/dist/quill.js\n");

/***/ })

};
;